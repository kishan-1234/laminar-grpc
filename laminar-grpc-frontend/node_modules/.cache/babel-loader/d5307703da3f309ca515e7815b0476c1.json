{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar isScalarAndEqual = require('../util/isScalarAndEqual');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('../query/fetchQueryInternal'),\n    getPromiseForActiveRequest = _require.getPromiseForActiveRequest;\n\nvar _require2 = require('./RelayModernOperationDescriptor'),\n    createRequestDescriptor = _require2.createRequestDescriptor;\n\nvar _require3 = require('./RelayModernSelector'),\n    areEqualSelectors = _require3.areEqualSelectors,\n    createReaderSelector = _require3.createReaderSelector,\n    getSelectorsFromObject = _require3.getSelectorsFromObject;\n/**\n * A utility for resolving and subscribing to the results of a fragment spec\n * (key -> fragment mapping) given some \"props\" that determine the root ID\n * and variables to use when reading each fragment. When props are changed via\n * `setProps()`, the resolver will update its results and subscriptions\n * accordingly. Internally, the resolver:\n * - Converts the fragment map & props map into a map of `Selector`s.\n * - Removes any resolvers for any props that became null.\n * - Creates resolvers for any props that became non-null.\n * - Updates resolvers with the latest props.\n *\n * This utility is implemented as an imperative, stateful API for performance\n * reasons: reusing previous resolvers, callback functions, and subscriptions\n * all helps to reduce object allocation and thereby decrease GC time.\n *\n * The `resolve()` function is also lazy and memoized: changes in the store mark\n * the resolver as stale and notify the caller, and the actual results are\n * recomputed the first time `resolve()` is called.\n */\n\n\nvar RelayModernFragmentSpecResolver = /*#__PURE__*/function () {\n  function RelayModernFragmentSpecResolver(context, fragments, props, callback) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function () {\n      _this._stale = true;\n\n      if (typeof _this._callback === 'function') {\n        _this._callback();\n      }\n    });\n    this._callback = callback;\n    this._context = context;\n    this._data = {};\n    this._fragments = fragments;\n    this._props = {};\n    this._resolvers = {};\n    this._stale = false;\n    this.setProps(props);\n  }\n\n  var _proto = RelayModernFragmentSpecResolver.prototype;\n\n  _proto.dispose = function dispose() {\n    for (var _key in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key)) {\n        disposeCallback(this._resolvers[_key]);\n      }\n    }\n  };\n\n  _proto.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the object multiple times, which could occur if data for\n      // multiple keys changes in the same event loop.\n      var prevData = this._data;\n      var nextData;\n\n      for (var _key2 in this._resolvers) {\n        if (this._resolvers.hasOwnProperty(_key2)) {\n          var resolver = this._resolvers[_key2];\n          var prevItem = prevData[_key2];\n\n          if (resolver) {\n            var nextItem = resolver.resolve();\n\n            if (nextData || nextItem !== prevItem) {\n              nextData = nextData || _objectSpread({}, prevData);\n              nextData[_key2] = nextItem;\n            }\n          } else {\n            var prop = this._props[_key2];\n\n            var _nextItem = prop !== undefined ? prop : null;\n\n            if (nextData || !isScalarAndEqual(_nextItem, prevItem)) {\n              nextData = nextData || _objectSpread({}, prevData);\n              nextData[_key2] = _nextItem;\n            }\n          }\n        }\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  _proto.setCallback = function setCallback(callback) {\n    this._callback = callback;\n  };\n\n  _proto.setProps = function setProps(props) {\n    var ownedSelectors = getSelectorsFromObject(this._fragments, props);\n    this._props = {};\n\n    for (var _key3 in ownedSelectors) {\n      if (ownedSelectors.hasOwnProperty(_key3)) {\n        var ownedSelector = ownedSelectors[_key3];\n        var resolver = this._resolvers[_key3];\n\n        if (ownedSelector == null) {\n          if (resolver != null) {\n            resolver.dispose();\n          }\n\n          resolver = null;\n        } else if (ownedSelector.kind === 'PluralReaderSelector') {\n          if (resolver == null) {\n            resolver = new SelectorListResolver(this._context.environment, ownedSelector, this._onChange);\n          } else {\n            !(resolver instanceof SelectorListResolver) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.', _key3) : invariant(false) : void 0;\n            resolver.setSelector(ownedSelector);\n          }\n        } else {\n          if (resolver == null) {\n            resolver = new SelectorResolver(this._context.environment, ownedSelector, this._onChange);\n          } else {\n            !(resolver instanceof SelectorResolver) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.', _key3) : invariant(false) : void 0;\n            resolver.setSelector(ownedSelector);\n          }\n        }\n\n        this._props[_key3] = props[_key3];\n        this._resolvers[_key3] = resolver;\n      }\n    }\n\n    this._stale = true;\n  };\n\n  _proto.setVariables = function setVariables(variables, request) {\n    for (var _key4 in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key4)) {\n        var resolver = this._resolvers[_key4];\n\n        if (resolver) {\n          resolver.setVariables(variables, request);\n        }\n      }\n    }\n\n    this._stale = true;\n  };\n\n  return RelayModernFragmentSpecResolver;\n}();\n/**\n * A resolver for a single Selector.\n */\n\n\nvar SelectorResolver = /*#__PURE__*/function () {\n  function SelectorResolver(environment, selector, callback) {\n    var _this2 = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function (snapshot) {\n      _this2._data = snapshot.data;\n      _this2._isMissingData = snapshot.isMissingData;\n\n      _this2._callback();\n    });\n\n    var _snapshot = environment.lookup(selector);\n\n    this._callback = callback;\n    this._data = _snapshot.data;\n    this._isMissingData = _snapshot.isMissingData;\n    this._environment = environment;\n    this._selector = selector;\n    this._subscription = environment.subscribe(_snapshot, this._onChange);\n  }\n\n  var _proto2 = SelectorResolver.prototype;\n\n  _proto2.dispose = function dispose() {\n    if (this._subscription) {\n      this._subscription.dispose();\n\n      this._subscription = null;\n    }\n  };\n\n  _proto2.resolve = function resolve() {\n    if (RelayFeatureFlags.ENABLE_RELAY_CONTAINERS_SUSPENSE === true && this._isMissingData === true) {\n      var _getPromiseForActiveR; // NOTE: This branch exists to handle the case in which:\n      // - A RelayModern container is rendered as a descendant of a Relay Hook\n      //   root using a \"partial\" renderPolicy (this means that eargerly\n      //   reading any cached data that is available instead of blocking\n      //   at the root until the whole query is fetched).\n      // - A parent Relay Hook didnt' suspend earlier on data being fetched,\n      //   either because the fragment data for the parent was available, or\n      //   the parent fragment didn't have any data dependencies.\n      // Even though our Flow types reflect the possiblity of null data, there\n      // might still be cases where it's not handled at runtime becuase the\n      // Flow types are being ignored, or simply not being used (for example,\n      // the case reported here: https://fburl.com/srnbucf8, was due to\n      // misuse of Flow types here: https://fburl.com/g3m0mqqh).\n      // Additionally, even though the null data might be handled without a\n      // runtime error, we might not suspend when we intended to if a parent\n      // Relay Hook (e.g. that is using @defer) decided not to suspend becuase\n      // it's immediate data was already available (even if it was deferred),\n      // or it didn't actually need any data (was just spreading other fragments).\n      // This should eventually go away with something like @optional, where we only\n      // suspend at specific boundaries depending on whether the boundary\n      // can be fulfilled or not.\n\n\n      var promise = (_getPromiseForActiveR = getPromiseForActiveRequest(this._environment, this._selector.owner)) !== null && _getPromiseForActiveR !== void 0 ? _getPromiseForActiveR : this._environment.getOperationTracker().getPromiseForPendingOperationsAffectingOwner(this._selector.owner);\n\n      if (promise != null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Relay Container for fragment `%s` suspended. When using ' + 'features such as @defer or @module, use `useFragment` instead ' + 'of a Relay Container.', this._selector.node.name) : void 0;\n        throw promise;\n      }\n    }\n\n    return this._data;\n  };\n\n  _proto2.setSelector = function setSelector(selector) {\n    if (this._subscription != null && areEqualSelectors(selector, this._selector)) {\n      return;\n    }\n\n    this.dispose();\n\n    var snapshot = this._environment.lookup(selector);\n\n    this._data = snapshot.data;\n    this._isMissingData = snapshot.isMissingData;\n    this._selector = selector;\n    this._subscription = this._environment.subscribe(snapshot, this._onChange);\n  };\n\n  _proto2.setVariables = function setVariables(variables, request) {\n    if (areEqual(variables, this._selector.variables)) {\n      // If we're not actually setting new variables, we don't actually want\n      // to create a new fragment owner, since areEqualSelectors relies on\n      // owner identity.\n      // In fact, we don't even need to try to attempt to set a new selector.\n      // When fragment ownership is not enabled, setSelector will also bail\n      // out since the selector doesn't really change, so we're doing it here\n      // earlier.\n      return;\n    } // NOTE: We manually create the request descriptor here instead of\n    // calling createOperationDescriptor() because we want to set a\n    // descriptor with *unaltered* variables as the fragment owner.\n    // This is a hack that allows us to preserve exisiting (broken)\n    // behavior of RelayModern containers while using fragment ownership\n    // to propagate variables instead of Context.\n    // For more details, see the summary of D13999308\n\n\n    var requestDescriptor = createRequestDescriptor(request, variables);\n    var selector = createReaderSelector(this._selector.node, this._selector.dataID, variables, requestDescriptor);\n    this.setSelector(selector);\n  };\n\n  return SelectorResolver;\n}();\n/**\n * A resolver for an array of Selectors.\n */\n\n\nvar SelectorListResolver = /*#__PURE__*/function () {\n  function SelectorListResolver(environment, selector, callback) {\n    var _this3 = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function (data) {\n      _this3._stale = true;\n\n      _this3._callback();\n    });\n    this._callback = callback;\n    this._data = [];\n    this._environment = environment;\n    this._resolvers = [];\n    this._stale = true;\n    this.setSelector(selector);\n  }\n\n  var _proto3 = SelectorListResolver.prototype;\n\n  _proto3.dispose = function dispose() {\n    this._resolvers.forEach(disposeCallback);\n  };\n\n  _proto3.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the array multiple times, which could occur if data for\n      // multiple indices changes in the same event loop.\n      var prevData = this._data;\n      var nextData;\n\n      for (var ii = 0; ii < this._resolvers.length; ii++) {\n        var prevItem = prevData[ii];\n\n        var nextItem = this._resolvers[ii].resolve();\n\n        if (nextData || nextItem !== prevItem) {\n          nextData = nextData || prevData.slice(0, ii);\n          nextData.push(nextItem);\n        }\n      }\n\n      if (!nextData && this._resolvers.length !== prevData.length) {\n        nextData = prevData.slice(0, this._resolvers.length);\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  _proto3.setSelector = function setSelector(selector) {\n    var selectors = selector.selectors;\n\n    while (this._resolvers.length > selectors.length) {\n      var resolver = this._resolvers.pop();\n\n      resolver.dispose();\n    }\n\n    for (var ii = 0; ii < selectors.length; ii++) {\n      if (ii < this._resolvers.length) {\n        this._resolvers[ii].setSelector(selectors[ii]);\n      } else {\n        this._resolvers[ii] = new SelectorResolver(this._environment, selectors[ii], this._onChange);\n      }\n    }\n\n    this._stale = true;\n  };\n\n  _proto3.setVariables = function setVariables(variables, request) {\n    this._resolvers.forEach(function (resolver) {\n      return resolver.setVariables(variables, request);\n    });\n\n    this._stale = true;\n  };\n\n  return SelectorListResolver;\n}();\n\nfunction disposeCallback(disposable) {\n  disposable && disposable.dispose();\n}\n\nmodule.exports = RelayModernFragmentSpecResolver;","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/RelayModernFragmentSpecResolver.js"],"names":["_interopRequireDefault","require","_defineProperty2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","RelayFeatureFlags","areEqual","invariant","isScalarAndEqual","warning","_require","getPromiseForActiveRequest","_require2","createRequestDescriptor","_require3","areEqualSelectors","createReaderSelector","getSelectorsFromObject","RelayModernFragmentSpecResolver","context","fragments","props","callback","_this","_stale","_callback","_context","_data","_fragments","_props","_resolvers","setProps","_proto","prototype","dispose","_key","hasOwnProperty","disposeCallback","resolve","prevData","nextData","_key2","resolver","prevItem","nextItem","prop","_nextItem","undefined","setCallback","ownedSelectors","_key3","ownedSelector","kind","SelectorListResolver","environment","_onChange","process","env","NODE_ENV","setSelector","SelectorResolver","setVariables","variables","request","_key4","selector","_this2","snapshot","data","_isMissingData","isMissingData","_snapshot","lookup","_environment","_selector","_subscription","subscribe","_proto2","ENABLE_RELAY_CONTAINERS_SUSPENSE","_getPromiseForActiveR","promise","owner","getOperationTracker","getPromiseForPendingOperationsAffectingOwner","node","name","requestDescriptor","dataID","_this3","_proto3","ii","slice","selectors","pop","disposable","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar isScalarAndEqual = require('../util/isScalarAndEqual');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('../query/fetchQueryInternal'),\n    getPromiseForActiveRequest = _require.getPromiseForActiveRequest;\n\nvar _require2 = require('./RelayModernOperationDescriptor'),\n    createRequestDescriptor = _require2.createRequestDescriptor;\n\nvar _require3 = require('./RelayModernSelector'),\n    areEqualSelectors = _require3.areEqualSelectors,\n    createReaderSelector = _require3.createReaderSelector,\n    getSelectorsFromObject = _require3.getSelectorsFromObject;\n\n/**\n * A utility for resolving and subscribing to the results of a fragment spec\n * (key -> fragment mapping) given some \"props\" that determine the root ID\n * and variables to use when reading each fragment. When props are changed via\n * `setProps()`, the resolver will update its results and subscriptions\n * accordingly. Internally, the resolver:\n * - Converts the fragment map & props map into a map of `Selector`s.\n * - Removes any resolvers for any props that became null.\n * - Creates resolvers for any props that became non-null.\n * - Updates resolvers with the latest props.\n *\n * This utility is implemented as an imperative, stateful API for performance\n * reasons: reusing previous resolvers, callback functions, and subscriptions\n * all helps to reduce object allocation and thereby decrease GC time.\n *\n * The `resolve()` function is also lazy and memoized: changes in the store mark\n * the resolver as stale and notify the caller, and the actual results are\n * recomputed the first time `resolve()` is called.\n */\nvar RelayModernFragmentSpecResolver = /*#__PURE__*/function () {\n  function RelayModernFragmentSpecResolver(context, fragments, props, callback) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function () {\n      _this._stale = true;\n\n      if (typeof _this._callback === 'function') {\n        _this._callback();\n      }\n    });\n    this._callback = callback;\n    this._context = context;\n    this._data = {};\n    this._fragments = fragments;\n    this._props = {};\n    this._resolvers = {};\n    this._stale = false;\n    this.setProps(props);\n  }\n\n  var _proto = RelayModernFragmentSpecResolver.prototype;\n\n  _proto.dispose = function dispose() {\n    for (var _key in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key)) {\n        disposeCallback(this._resolvers[_key]);\n      }\n    }\n  };\n\n  _proto.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the object multiple times, which could occur if data for\n      // multiple keys changes in the same event loop.\n      var prevData = this._data;\n      var nextData;\n\n      for (var _key2 in this._resolvers) {\n        if (this._resolvers.hasOwnProperty(_key2)) {\n          var resolver = this._resolvers[_key2];\n          var prevItem = prevData[_key2];\n\n          if (resolver) {\n            var nextItem = resolver.resolve();\n\n            if (nextData || nextItem !== prevItem) {\n              nextData = nextData || _objectSpread({}, prevData);\n              nextData[_key2] = nextItem;\n            }\n          } else {\n            var prop = this._props[_key2];\n\n            var _nextItem = prop !== undefined ? prop : null;\n\n            if (nextData || !isScalarAndEqual(_nextItem, prevItem)) {\n              nextData = nextData || _objectSpread({}, prevData);\n              nextData[_key2] = _nextItem;\n            }\n          }\n        }\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  _proto.setCallback = function setCallback(callback) {\n    this._callback = callback;\n  };\n\n  _proto.setProps = function setProps(props) {\n    var ownedSelectors = getSelectorsFromObject(this._fragments, props);\n    this._props = {};\n\n    for (var _key3 in ownedSelectors) {\n      if (ownedSelectors.hasOwnProperty(_key3)) {\n        var ownedSelector = ownedSelectors[_key3];\n        var resolver = this._resolvers[_key3];\n\n        if (ownedSelector == null) {\n          if (resolver != null) {\n            resolver.dispose();\n          }\n\n          resolver = null;\n        } else if (ownedSelector.kind === 'PluralReaderSelector') {\n          if (resolver == null) {\n            resolver = new SelectorListResolver(this._context.environment, ownedSelector, this._onChange);\n          } else {\n            !(resolver instanceof SelectorListResolver) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.', _key3) : invariant(false) : void 0;\n            resolver.setSelector(ownedSelector);\n          }\n        } else {\n          if (resolver == null) {\n            resolver = new SelectorResolver(this._context.environment, ownedSelector, this._onChange);\n          } else {\n            !(resolver instanceof SelectorResolver) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.', _key3) : invariant(false) : void 0;\n            resolver.setSelector(ownedSelector);\n          }\n        }\n\n        this._props[_key3] = props[_key3];\n        this._resolvers[_key3] = resolver;\n      }\n    }\n\n    this._stale = true;\n  };\n\n  _proto.setVariables = function setVariables(variables, request) {\n    for (var _key4 in this._resolvers) {\n      if (this._resolvers.hasOwnProperty(_key4)) {\n        var resolver = this._resolvers[_key4];\n\n        if (resolver) {\n          resolver.setVariables(variables, request);\n        }\n      }\n    }\n\n    this._stale = true;\n  };\n\n  return RelayModernFragmentSpecResolver;\n}();\n/**\n * A resolver for a single Selector.\n */\n\n\nvar SelectorResolver = /*#__PURE__*/function () {\n  function SelectorResolver(environment, selector, callback) {\n    var _this2 = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function (snapshot) {\n      _this2._data = snapshot.data;\n      _this2._isMissingData = snapshot.isMissingData;\n\n      _this2._callback();\n    });\n\n    var _snapshot = environment.lookup(selector);\n\n    this._callback = callback;\n    this._data = _snapshot.data;\n    this._isMissingData = _snapshot.isMissingData;\n    this._environment = environment;\n    this._selector = selector;\n    this._subscription = environment.subscribe(_snapshot, this._onChange);\n  }\n\n  var _proto2 = SelectorResolver.prototype;\n\n  _proto2.dispose = function dispose() {\n    if (this._subscription) {\n      this._subscription.dispose();\n\n      this._subscription = null;\n    }\n  };\n\n  _proto2.resolve = function resolve() {\n    if (RelayFeatureFlags.ENABLE_RELAY_CONTAINERS_SUSPENSE === true && this._isMissingData === true) {\n      var _getPromiseForActiveR;\n\n      // NOTE: This branch exists to handle the case in which:\n      // - A RelayModern container is rendered as a descendant of a Relay Hook\n      //   root using a \"partial\" renderPolicy (this means that eargerly\n      //   reading any cached data that is available instead of blocking\n      //   at the root until the whole query is fetched).\n      // - A parent Relay Hook didnt' suspend earlier on data being fetched,\n      //   either because the fragment data for the parent was available, or\n      //   the parent fragment didn't have any data dependencies.\n      // Even though our Flow types reflect the possiblity of null data, there\n      // might still be cases where it's not handled at runtime becuase the\n      // Flow types are being ignored, or simply not being used (for example,\n      // the case reported here: https://fburl.com/srnbucf8, was due to\n      // misuse of Flow types here: https://fburl.com/g3m0mqqh).\n      // Additionally, even though the null data might be handled without a\n      // runtime error, we might not suspend when we intended to if a parent\n      // Relay Hook (e.g. that is using @defer) decided not to suspend becuase\n      // it's immediate data was already available (even if it was deferred),\n      // or it didn't actually need any data (was just spreading other fragments).\n      // This should eventually go away with something like @optional, where we only\n      // suspend at specific boundaries depending on whether the boundary\n      // can be fulfilled or not.\n      var promise = (_getPromiseForActiveR = getPromiseForActiveRequest(this._environment, this._selector.owner)) !== null && _getPromiseForActiveR !== void 0 ? _getPromiseForActiveR : this._environment.getOperationTracker().getPromiseForPendingOperationsAffectingOwner(this._selector.owner);\n\n      if (promise != null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Relay Container for fragment `%s` suspended. When using ' + 'features such as @defer or @module, use `useFragment` instead ' + 'of a Relay Container.', this._selector.node.name) : void 0;\n        throw promise;\n      }\n    }\n\n    return this._data;\n  };\n\n  _proto2.setSelector = function setSelector(selector) {\n    if (this._subscription != null && areEqualSelectors(selector, this._selector)) {\n      return;\n    }\n\n    this.dispose();\n\n    var snapshot = this._environment.lookup(selector);\n\n    this._data = snapshot.data;\n    this._isMissingData = snapshot.isMissingData;\n    this._selector = selector;\n    this._subscription = this._environment.subscribe(snapshot, this._onChange);\n  };\n\n  _proto2.setVariables = function setVariables(variables, request) {\n    if (areEqual(variables, this._selector.variables)) {\n      // If we're not actually setting new variables, we don't actually want\n      // to create a new fragment owner, since areEqualSelectors relies on\n      // owner identity.\n      // In fact, we don't even need to try to attempt to set a new selector.\n      // When fragment ownership is not enabled, setSelector will also bail\n      // out since the selector doesn't really change, so we're doing it here\n      // earlier.\n      return;\n    } // NOTE: We manually create the request descriptor here instead of\n    // calling createOperationDescriptor() because we want to set a\n    // descriptor with *unaltered* variables as the fragment owner.\n    // This is a hack that allows us to preserve exisiting (broken)\n    // behavior of RelayModern containers while using fragment ownership\n    // to propagate variables instead of Context.\n    // For more details, see the summary of D13999308\n\n\n    var requestDescriptor = createRequestDescriptor(request, variables);\n    var selector = createReaderSelector(this._selector.node, this._selector.dataID, variables, requestDescriptor);\n    this.setSelector(selector);\n  };\n\n  return SelectorResolver;\n}();\n/**\n * A resolver for an array of Selectors.\n */\n\n\nvar SelectorListResolver = /*#__PURE__*/function () {\n  function SelectorListResolver(environment, selector, callback) {\n    var _this3 = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_onChange\", function (data) {\n      _this3._stale = true;\n\n      _this3._callback();\n    });\n    this._callback = callback;\n    this._data = [];\n    this._environment = environment;\n    this._resolvers = [];\n    this._stale = true;\n    this.setSelector(selector);\n  }\n\n  var _proto3 = SelectorListResolver.prototype;\n\n  _proto3.dispose = function dispose() {\n    this._resolvers.forEach(disposeCallback);\n  };\n\n  _proto3.resolve = function resolve() {\n    if (this._stale) {\n      // Avoid mapping the array multiple times, which could occur if data for\n      // multiple indices changes in the same event loop.\n      var prevData = this._data;\n      var nextData;\n\n      for (var ii = 0; ii < this._resolvers.length; ii++) {\n        var prevItem = prevData[ii];\n\n        var nextItem = this._resolvers[ii].resolve();\n\n        if (nextData || nextItem !== prevItem) {\n          nextData = nextData || prevData.slice(0, ii);\n          nextData.push(nextItem);\n        }\n      }\n\n      if (!nextData && this._resolvers.length !== prevData.length) {\n        nextData = prevData.slice(0, this._resolvers.length);\n      }\n\n      this._data = nextData || prevData;\n      this._stale = false;\n    }\n\n    return this._data;\n  };\n\n  _proto3.setSelector = function setSelector(selector) {\n    var selectors = selector.selectors;\n\n    while (this._resolvers.length > selectors.length) {\n      var resolver = this._resolvers.pop();\n\n      resolver.dispose();\n    }\n\n    for (var ii = 0; ii < selectors.length; ii++) {\n      if (ii < this._resolvers.length) {\n        this._resolvers[ii].setSelector(selectors[ii]);\n      } else {\n        this._resolvers[ii] = new SelectorResolver(this._environment, selectors[ii], this._onChange);\n      }\n    }\n\n    this._stale = true;\n  };\n\n  _proto3.setVariables = function setVariables(variables, request) {\n    this._resolvers.forEach(function (resolver) {\n      return resolver.setVariables(variables, request);\n    });\n\n    this._stale = true;\n  };\n\n  return SelectorListResolver;\n}();\n\nfunction disposeCallback(disposable) {\n  disposable && disposable.dispose();\n}\n\nmodule.exports = RelayModernFragmentSpecResolver;"]},"metadata":{},"sourceType":"script"}