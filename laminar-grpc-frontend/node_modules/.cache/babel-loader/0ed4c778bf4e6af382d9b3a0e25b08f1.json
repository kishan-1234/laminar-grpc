{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar DataChecker = require('./DataChecker');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayProfiler = require('../util/RelayProfiler');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar _require = require('./RelayStoreUtils'),\n    ROOT_ID = _require.ROOT_ID,\n    ROOT_TYPE = _require.ROOT_TYPE;\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 0;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore = /*#__PURE__*/function () {\n  function RelayModernStore(source, options) {\n    var _this = this;\n\n    var _options$gcReleaseBuf, _options$gcScheduler, _options$UNSTABLE_DO_, _options$log, _options$operationLoa;\n\n    (0, _defineProperty2[\"default\"])(this, \"_gcStep\", function () {\n      if (_this._gcRun) {\n        if (_this._gcRun.next().done) {\n          _this._gcRun = null;\n        } else {\n          _this._gcScheduler(_this._gcStep);\n        }\n      }\n    }); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcRun = null;\n    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;\n    this._getDataID = (_options$UNSTABLE_DO_ = options === null || options === void 0 ? void 0 : options.UNSTABLE_DO_NOT_USE_getDataID) !== null && _options$UNSTABLE_DO_ !== void 0 ? _options$UNSTABLE_DO_ : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;\n    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;\n    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._subscriptions = new Set();\n    this._updatedRecordIDs = {};\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _this$_optimisticSour2, _options$target, _options$handlers;\n\n    var selector = operation.root;\n    var source = (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occured.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation occurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        // (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var target = (_options$target = options === null || options === void 0 ? void 0 : options.target) !== null && _options$target !== void 0 ? _options$target : source;\n    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];\n    var operationAvailability = DataChecker.check(source, target, selector, handlers, this._operationLoader, this._getDataID);\n    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this2 = this;\n\n    var id = operation.request.identifier;\n    var disposed = false;\n\n    var dispose = function dispose() {\n      // Ensure each retain can only dispose once\n      if (disposed) {\n        return;\n      }\n\n      disposed = true; // For Flow: guard against the entry somehow not existing\n\n      var rootEntry = _this2._roots.get(id);\n\n      if (rootEntry == null) {\n        return;\n      } // Decrement the ref count: if it becomes zero it is eligible\n      // for release.\n\n\n      rootEntry.refCount--;\n\n      if (rootEntry.refCount === 0) {\n        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;\n\n        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;\n\n        if (rootEntryIsStale) {\n          _this2._roots[\"delete\"](id);\n\n          _this2._scheduleGC();\n        } else {\n          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently\n          // added entry and schedule a GC. Note that all items in the release\n          // buffer have a refCount of 0.\n\n\n          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n            var _id = _this2._releaseBuffer.shift();\n\n            _this2._roots[\"delete\"](_id);\n\n            _this2._scheduleGC();\n          }\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      if (rootEntry.refCount === 0) {\n        // This entry should be in the release buffer, but it no longer belongs\n        // there since it's retained. Remove it to maintain the invariant that\n        // all release buffer entries have a refCount of 0.\n        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {\n          return _id !== id;\n        });\n      } // If we've previously retained this operation, increment the refCount\n\n\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 1,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners from the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this3 = this;\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.notify.start'\n      });\n    } // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    if (log != null) {\n      log({\n        name: 'store.notify.complete',\n        updatedRecordIDs: this._updatedRecordIDs,\n        invalidatedRecordIDs: this._invalidatedRecordIDs\n      });\n    }\n\n    this._updatedRecordIDs = {};\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = Date.now();\n      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {\n        // The operation isn't retained but there is space in the release buffer:\n        // temporarily track this operation in case the data can be reused soon.\n        var temporaryRootEntry = {\n          operation: sourceOperation,\n          refCount: 0,\n          epoch: this._currentWriteEpoch,\n          fetchTime: Date.now()\n        };\n\n        this._releaseBuffer.push(id);\n\n        this._roots.set(id, temporaryRootEntry);\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var _this$_optimisticSour3;\n\n    var target = (_this$_optimisticSour3 = this._optimisticSource) !== null && _this$_optimisticSour3 !== void 0 ? _this$_optimisticSour3 : this._recordSource;\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function\n    // mutates the source, it doesn't affect Relay processing of it.\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.publish',\n        source: source,\n        optimistic: target === this._optimisticSource\n      });\n    }\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this4 = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this4._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this5 = this;\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this5._gcHoldCounter > 0) {\n        _this5._gcHoldCounter--;\n\n        if (_this5._gcHoldCounter === 0 && _this5._shouldScheduleGC) {\n          _this5._scheduleGC();\n\n          _this5._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  } // Returns the owner (RequestDescriptor) if the subscription was affected by the\n  // latest update, or null if it was not affected.\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasOverlappingIDs(snapshot.seenRecords, this._updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this6 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this6.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iterator = _createForOfIteratorHelper(prevInvalidationState.dataIDs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this7 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this7._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this8 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this8._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    var _this9 = this;\n\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.snapshot'\n      });\n    }\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value than\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(_this9.getSource(), snapshot.selector);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.restore'\n      });\n    }\n\n    this._optimisticSource = null;\n\n    if (this._shouldScheduleGC) {\n      this._scheduleGC();\n    }\n\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto._scheduleGC = function _scheduleGC() {\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._gcRun) {\n      return;\n    }\n\n    this._gcRun = this._collect();\n\n    this._gcScheduler(this._gcStep);\n  }\n  /**\n   * Run a full GC synchronously.\n   */\n  ;\n\n  _proto.__gc = function __gc() {\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var gcRun = this._collect();\n\n    while (!gcRun.next().done) {}\n  };\n\n  _proto._collect = function* _collect() {\n    /* eslint-disable no-labels */\n    top: while (true) {\n      var startEpoch = this._currentWriteEpoch;\n      var references = new Set(); // Mark all records that are traversable from a root\n\n      var _iterator2 = _createForOfIteratorHelper(this._roots.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operation = _step2.value.operation;\n          var selector = operation.root;\n          RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader); // Yield for other work after each operation\n\n          yield; // If the store was updated, restart\n\n          if (startEpoch !== this._currentWriteEpoch) {\n            continue top;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var log = this.__log;\n\n      if (log != null) {\n        log({\n          name: 'store.gc',\n          references: references\n        });\n      } // Sweep records without references\n\n\n      if (references.size === 0) {\n        // Short-circuit if *nothing* is referenced\n        this._recordSource.clear();\n      } else {\n        // Evict any unreferenced nodes\n        var storeIDs = this._recordSource.getRecordIDs();\n\n        for (var ii = 0; ii < storeIDs.length; ii++) {\n          var dataID = storeIDs[ii];\n\n          if (!references.has(dataID)) {\n            this._recordSource.remove(dataID);\n          }\n        }\n      }\n\n      return;\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will marc records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID);\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      var nextRecord = RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs[dataID] = true;\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs[dataID] = true;\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs[dataID] = true;\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availability of an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {\n  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,\n      status = operationAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  }\n\n  if (status === 'missing') {\n    return {\n      status: 'missing'\n    };\n  }\n\n  if (operationFetchTime != null && queryCacheExpirationTime != null) {\n    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;\n\n    if (isStale) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return {\n    status: 'available',\n    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null\n  };\n}\n\nRelayProfiler.instrumentMethods(RelayModernStore.prototype, {\n  lookup: 'RelayModernStore.prototype.lookup'\n});\nmodule.exports = RelayModernStore;","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/RelayModernStore.js"],"names":["_interopRequireDefault","require","_defineProperty2","_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","i","F","s","n","length","done","value","e","_e","f","TypeError","it","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","DataChecker","RelayModernRecord","RelayOptimisticRecordSource","RelayProfiler","RelayReader","RelayReferenceMarker","RelayStoreUtils","deepFreeze","defaultGetDataID","hasOverlappingIDs","invariant","recycleNodesInto","resolveImmediate","_require","ROOT_ID","ROOT_TYPE","DEFAULT_RELEASE_BUFFER_SIZE","RelayModernStore","source","options","_this","_options$gcReleaseBuf","_options$gcScheduler","_options$UNSTABLE_DO_","_options$log","_options$operationLoa","_gcRun","_gcScheduler","_gcStep","process","env","NODE_ENV","storeIDs","getRecordIDs","ii","record","get","freeze","_currentWriteEpoch","_gcHoldCounter","_gcReleaseBufferSize","gcReleaseBufferSize","gcScheduler","_getDataID","UNSTABLE_DO_NOT_USE_getDataID","_globalInvalidationEpoch","_invalidationSubscriptions","Set","_invalidatedRecordIDs","__log","log","_queryCacheExpirationTime","queryCacheExpirationTime","_operationLoader","operationLoader","_optimisticSource","_recordSource","_releaseBuffer","_roots","Map","_shouldScheduleGC","_subscriptions","_updatedRecordIDs","initializeRecordSource","_proto","getSource","_this$_optimisticSour","check","operation","_this$_optimisticSour2","_options$target","_options$handlers","selector","root","globalInvalidationEpoch","rootEntry","request","identifier","operationLastWrittenAt","epoch","status","target","handlers","operationAvailability","getAvailabilityStatus","fetchTime","retain","_this2","id","disposed","dispose","refCount","rootEntryIsStale","Date","now","_scheduleGC","push","_id","shift","filter","set","lookup","snapshot","read","notify","sourceOperation","invalidateStore","_this3","updatedOwners","forEach","subscription","owner","_updateSubscription","_updateInvalidationSubscription","updatedRecordIDs","invalidatedRecordIDs","clear","node","params","operationKind","temporaryRootEntry","publish","idsMarkedForInvalidation","_this$_optimisticSour3","updateTargetFromSource","optimistic","subscribe","callback","_this4","backup","stale","add","holdGC","_this5","toJSON","__getUpdatedRecordIDs","hasOverlappingUpdates","seenRecords","nextSnapshot","nextData","data","isMissingData","lookupInvalidationState","dataIDs","_this6","invalidations","dataID","_RelayModernRecord$ge","getInvalidationEpoch","checkInvalidationState","prevInvalidationState","latestInvalidationState","currentInvalidations","prevInvalidations","_iterator","_step","subscribeToInvalidationState","invalidationState","_this7","invalidatedStore","_this8","isSubscribedToInvalidatedIDs","some","has","_this9","create","restore","_collect","__gc","gcRun","top","startEpoch","references","_iterator2","values","_step2","mark","size","remove","rootRecord","currentWriteEpoch","targetRecord","sourceRecord","nextRecord","clone","setValue","INVALIDATED_AT_KEY","update","operationFetchTime","mostRecentlyInvalidatedAt","isStale","instrumentMethods","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar DataChecker = require('./DataChecker');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayOptimisticRecordSource = require('./RelayOptimisticRecordSource');\n\nvar RelayProfiler = require('../util/RelayProfiler');\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayReferenceMarker = require('./RelayReferenceMarker');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar defaultGetDataID = require('./defaultGetDataID');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar resolveImmediate = require('../util/resolveImmediate');\n\nvar _require = require('./RelayStoreUtils'),\n    ROOT_ID = _require.ROOT_ID,\n    ROOT_TYPE = _require.ROOT_TYPE;\n\nvar DEFAULT_RELEASE_BUFFER_SIZE = 0;\n/**\n * @public\n *\n * An implementation of the `Store` interface defined in `RelayStoreTypes`.\n *\n * Note that a Store takes ownership of all records provided to it: other\n * objects may continue to hold a reference to such records but may not mutate\n * them. The static Relay core is architected to avoid mutating records that may have been\n * passed to a store: operations that mutate records will either create fresh\n * records or clone existing records and modify the clones. Record immutability\n * is also enforced in development mode by freezing all records passed to a store.\n */\n\nvar RelayModernStore = /*#__PURE__*/function () {\n  function RelayModernStore(source, options) {\n    var _this = this;\n\n    var _options$gcReleaseBuf, _options$gcScheduler, _options$UNSTABLE_DO_, _options$log, _options$operationLoa;\n\n    (0, _defineProperty2[\"default\"])(this, \"_gcStep\", function () {\n      if (_this._gcRun) {\n        if (_this._gcRun.next().done) {\n          _this._gcRun = null;\n        } else {\n          _this._gcScheduler(_this._gcStep);\n        }\n      }\n    });\n\n    // Prevent mutation of a record from outside the store.\n    if (process.env.NODE_ENV !== \"production\") {\n      var storeIDs = source.getRecordIDs();\n\n      for (var ii = 0; ii < storeIDs.length; ii++) {\n        var record = source.get(storeIDs[ii]);\n\n        if (record) {\n          RelayModernRecord.freeze(record);\n        }\n      }\n    }\n\n    this._currentWriteEpoch = 0;\n    this._gcHoldCounter = 0;\n    this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;\n    this._gcRun = null;\n    this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;\n    this._getDataID = (_options$UNSTABLE_DO_ = options === null || options === void 0 ? void 0 : options.UNSTABLE_DO_NOT_USE_getDataID) !== null && _options$UNSTABLE_DO_ !== void 0 ? _options$UNSTABLE_DO_ : defaultGetDataID;\n    this._globalInvalidationEpoch = null;\n    this._invalidationSubscriptions = new Set();\n    this._invalidatedRecordIDs = new Set();\n    this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;\n    this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;\n    this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;\n    this._optimisticSource = null;\n    this._recordSource = source;\n    this._releaseBuffer = [];\n    this._roots = new Map();\n    this._shouldScheduleGC = false;\n    this._subscriptions = new Set();\n    this._updatedRecordIDs = {};\n    initializeRecordSource(this._recordSource);\n  }\n\n  var _proto = RelayModernStore.prototype;\n\n  _proto.getSource = function getSource() {\n    var _this$_optimisticSour;\n\n    return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;\n  };\n\n  _proto.check = function check(operation, options) {\n    var _this$_optimisticSour2, _options$target, _options$handlers;\n\n    var selector = operation.root;\n    var source = (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;\n    var globalInvalidationEpoch = this._globalInvalidationEpoch;\n\n    var rootEntry = this._roots.get(operation.request.identifier);\n\n    var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null; // Check if store has been globally invalidated\n\n    if (globalInvalidationEpoch != null) {\n      // If so, check if the operation we're checking was last written\n      // before or after invalidation occured.\n      if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {\n        // If the operation was written /before/ global invalidation occurred,\n        // or if this operation has never been written to the store before,\n        // we will consider the data for this operation to be stale\n        // (i.e. not resolvable from the store).\n        return {\n          status: 'stale'\n        };\n      }\n    }\n\n    var target = (_options$target = options === null || options === void 0 ? void 0 : options.target) !== null && _options$target !== void 0 ? _options$target : source;\n    var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];\n    var operationAvailability = DataChecker.check(source, target, selector, handlers, this._operationLoader, this._getDataID);\n    return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);\n  };\n\n  _proto.retain = function retain(operation) {\n    var _this2 = this;\n\n    var id = operation.request.identifier;\n    var disposed = false;\n\n    var dispose = function dispose() {\n      // Ensure each retain can only dispose once\n      if (disposed) {\n        return;\n      }\n\n      disposed = true; // For Flow: guard against the entry somehow not existing\n\n      var rootEntry = _this2._roots.get(id);\n\n      if (rootEntry == null) {\n        return;\n      } // Decrement the ref count: if it becomes zero it is eligible\n      // for release.\n\n\n      rootEntry.refCount--;\n\n      if (rootEntry.refCount === 0) {\n        var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;\n\n        var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;\n\n        if (rootEntryIsStale) {\n          _this2._roots[\"delete\"](id);\n\n          _this2._scheduleGC();\n        } else {\n          _this2._releaseBuffer.push(id); // If the release buffer is now over-full, remove the least-recently\n          // added entry and schedule a GC. Note that all items in the release\n          // buffer have a refCount of 0.\n\n\n          if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {\n            var _id = _this2._releaseBuffer.shift();\n\n            _this2._roots[\"delete\"](_id);\n\n            _this2._scheduleGC();\n          }\n        }\n      }\n    };\n\n    var rootEntry = this._roots.get(id);\n\n    if (rootEntry != null) {\n      if (rootEntry.refCount === 0) {\n        // This entry should be in the release buffer, but it no longer belongs\n        // there since it's retained. Remove it to maintain the invariant that\n        // all release buffer entries have a refCount of 0.\n        this._releaseBuffer = this._releaseBuffer.filter(function (_id) {\n          return _id !== id;\n        });\n      } // If we've previously retained this operation, increment the refCount\n\n\n      rootEntry.refCount += 1;\n    } else {\n      // Otherwise create a new entry for the operation\n      this._roots.set(id, {\n        operation: operation,\n        refCount: 1,\n        epoch: null,\n        fetchTime: null\n      });\n    }\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.lookup = function lookup(selector) {\n    var source = this.getSource();\n    var snapshot = RelayReader.read(source, selector);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(snapshot);\n    }\n\n    return snapshot;\n  } // This method will return a list of updated owners from the subscriptions\n  ;\n\n  _proto.notify = function notify(sourceOperation, invalidateStore) {\n    var _this3 = this;\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.notify.start'\n      });\n    } // Increment the current write when notifying after executing\n    // a set of changes to the store.\n\n\n    this._currentWriteEpoch++;\n\n    if (invalidateStore === true) {\n      this._globalInvalidationEpoch = this._currentWriteEpoch;\n    }\n\n    var source = this.getSource();\n    var updatedOwners = [];\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n\n    this._invalidationSubscriptions.forEach(function (subscription) {\n      _this3._updateInvalidationSubscription(subscription, invalidateStore === true);\n    });\n\n    if (log != null) {\n      log({\n        name: 'store.notify.complete',\n        updatedRecordIDs: this._updatedRecordIDs,\n        invalidatedRecordIDs: this._invalidatedRecordIDs\n      });\n    }\n\n    this._updatedRecordIDs = {};\n\n    this._invalidatedRecordIDs.clear(); // If a source operation was provided (indicating the operation\n    // that produced this update to the store), record the current epoch\n    // at which this operation was written.\n\n\n    if (sourceOperation != null) {\n      // We only track the epoch at which the operation was written if\n      // it was previously retained, to keep the size of our operation\n      // epoch map bounded. If a query wasn't retained, we assume it can\n      // may be deleted at any moment and thus is not relevant for us to track\n      // for the purposes of invalidation.\n      var id = sourceOperation.request.identifier;\n\n      var rootEntry = this._roots.get(id);\n\n      if (rootEntry != null) {\n        rootEntry.epoch = this._currentWriteEpoch;\n        rootEntry.fetchTime = Date.now();\n      } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {\n        // The operation isn't retained but there is space in the release buffer:\n        // temporarily track this operation in case the data can be reused soon.\n        var temporaryRootEntry = {\n          operation: sourceOperation,\n          refCount: 0,\n          epoch: this._currentWriteEpoch,\n          fetchTime: Date.now()\n        };\n\n        this._releaseBuffer.push(id);\n\n        this._roots.set(id, temporaryRootEntry);\n      }\n    }\n\n    return updatedOwners;\n  };\n\n  _proto.publish = function publish(source, idsMarkedForInvalidation) {\n    var _this$_optimisticSour3;\n\n    var target = (_this$_optimisticSour3 = this._optimisticSource) !== null && _this$_optimisticSour3 !== void 0 ? _this$_optimisticSour3 : this._recordSource;\n    updateTargetFromSource(target, source, // We increment the current epoch at the end of the set of updates,\n    // in notify(). Here, we pass what will be the incremented value of\n    // the epoch to use to write to invalidated records.\n    this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs); // NOTE: log *after* processing the source so that even if a bad log function\n    // mutates the source, it doesn't affect Relay processing of it.\n\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.publish',\n        source: source,\n        optimistic: target === this._optimisticSource\n      });\n    }\n  };\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this4 = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this4._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.holdGC = function holdGC() {\n    var _this5 = this;\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._gcHoldCounter++;\n\n    var dispose = function dispose() {\n      if (_this5._gcHoldCounter > 0) {\n        _this5._gcHoldCounter--;\n\n        if (_this5._gcHoldCounter === 0 && _this5._shouldScheduleGC) {\n          _this5._scheduleGC();\n\n          _this5._shouldScheduleGC = false;\n        }\n      }\n    };\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return 'RelayModernStore()';\n  } // Internal API\n  ;\n\n  _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {\n    return this._updatedRecordIDs;\n  } // Returns the owner (RequestDescriptor) if the subscription was affected by the\n  // latest update, or null if it was not affected.\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasOverlappingIDs(snapshot.seenRecords, this._updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {\n    var _this6 = this;\n\n    var invalidations = new Map();\n    dataIDs.forEach(function (dataID) {\n      var _RelayModernRecord$ge;\n\n      var record = _this6.getSource().get(dataID);\n\n      invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);\n    });\n    invalidations.set('global', this._globalInvalidationEpoch);\n    return {\n      dataIDs: dataIDs,\n      invalidations: invalidations\n    };\n  };\n\n  _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {\n    var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);\n    var currentInvalidations = latestInvalidationState.invalidations;\n    var prevInvalidations = prevInvalidationState.invalidations; // Check if global invalidation has changed\n\n    if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {\n      return true;\n    } // Check if the invalidation state for any of the ids has changed.\n\n\n    var _iterator = _createForOfIteratorHelper(prevInvalidationState.dataIDs),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dataID = _step.value;\n\n        if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return false;\n  };\n\n  _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {\n    var _this7 = this;\n\n    var subscription = {\n      callback: callback,\n      invalidationState: invalidationState\n    };\n\n    var dispose = function dispose() {\n      _this7._invalidationSubscriptions[\"delete\"](subscription);\n    };\n\n    this._invalidationSubscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {\n    var _this8 = this;\n\n    var callback = subscription.callback,\n        invalidationState = subscription.invalidationState;\n    var dataIDs = invalidationState.dataIDs;\n    var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function (dataID) {\n      return _this8._invalidatedRecordIDs.has(dataID);\n    });\n\n    if (!isSubscribedToInvalidatedIDs) {\n      return;\n    }\n\n    callback();\n  };\n\n  _proto.snapshot = function snapshot() {\n    var _this9 = this;\n\n    !(this._optimisticSource == null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.snapshot'\n      });\n    }\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value than\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(_this9.getSource(), snapshot.selector);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n\n    if (this._gcRun) {\n      this._gcRun = null;\n      this._shouldScheduleGC = true;\n    }\n\n    this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());\n  };\n\n  _proto.restore = function restore() {\n    !(this._optimisticSource != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : invariant(false) : void 0;\n    var log = this.__log;\n\n    if (log != null) {\n      log({\n        name: 'store.restore'\n      });\n    }\n\n    this._optimisticSource = null;\n\n    if (this._shouldScheduleGC) {\n      this._scheduleGC();\n    }\n\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto._scheduleGC = function _scheduleGC() {\n    if (this._gcHoldCounter > 0) {\n      this._shouldScheduleGC = true;\n      return;\n    }\n\n    if (this._gcRun) {\n      return;\n    }\n\n    this._gcRun = this._collect();\n\n    this._gcScheduler(this._gcStep);\n  }\n  /**\n   * Run a full GC synchronously.\n   */\n  ;\n\n  _proto.__gc = function __gc() {\n    // Don't run GC while there are optimistic updates applied\n    if (this._optimisticSource != null) {\n      return;\n    }\n\n    var gcRun = this._collect();\n\n    while (!gcRun.next().done) {}\n  };\n\n  _proto._collect = function* _collect() {\n    /* eslint-disable no-labels */\n    top: while (true) {\n      var startEpoch = this._currentWriteEpoch;\n      var references = new Set(); // Mark all records that are traversable from a root\n\n      var _iterator2 = _createForOfIteratorHelper(this._roots.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var operation = _step2.value.operation;\n          var selector = operation.root;\n          RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader); // Yield for other work after each operation\n\n          yield; // If the store was updated, restart\n\n          if (startEpoch !== this._currentWriteEpoch) {\n            continue top;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var log = this.__log;\n\n      if (log != null) {\n        log({\n          name: 'store.gc',\n          references: references\n        });\n      } // Sweep records without references\n\n\n      if (references.size === 0) {\n        // Short-circuit if *nothing* is referenced\n        this._recordSource.clear();\n      } else {\n        // Evict any unreferenced nodes\n        var storeIDs = this._recordSource.getRecordIDs();\n\n        for (var ii = 0; ii < storeIDs.length; ii++) {\n          var dataID = storeIDs[ii];\n\n          if (!references.has(dataID)) {\n            this._recordSource.remove(dataID);\n          }\n        }\n      }\n\n      return;\n    }\n  };\n\n  return RelayModernStore;\n}();\n\nfunction initializeRecordSource(target) {\n  if (!target.has(ROOT_ID)) {\n    var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);\n    target.set(ROOT_ID, rootRecord);\n  }\n}\n/**\n * Updates the target with information from source, also updating a mapping of\n * which records in the target were changed as a result.\n * Additionally, will marc records as invalidated at the current write epoch\n * given the set of record ids marked as stale in this update.\n */\n\n\nfunction updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {\n  // First, update any records that were marked for invalidation.\n  // For each provided dataID that was invalidated, we write the\n  // INVALIDATED_AT_KEY on the record, indicating\n  // the epoch at which the record was invalidated.\n  if (idsMarkedForInvalidation) {\n    idsMarkedForInvalidation.forEach(function (dataID) {\n      var targetRecord = target.get(dataID);\n      var sourceRecord = source.get(dataID); // If record was deleted during the update (and also invalidated),\n      // we don't need to count it as an invalidated id\n\n      if (sourceRecord === null) {\n        return;\n      }\n\n      var nextRecord;\n\n      if (targetRecord != null) {\n        // If the target record exists, use it to set the epoch\n        // at which it was invalidated. This record will be updated with\n        // any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = RelayModernRecord.clone(targetRecord);\n      } else {\n        // If the target record doesn't exist, it means that a new record\n        // in the source was created (and also invalidated), so we use that\n        // record to set the epoch at which it was invalidated. This record\n        // will be updated with any changes from source in the section below\n        // where we update the target records based on the source.\n        nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;\n      }\n\n      if (!nextRecord) {\n        return;\n      }\n\n      RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);\n      invalidatedRecordIDs.add(dataID);\n      target.set(dataID, nextRecord);\n    });\n  } // Update the target based on the changes present in source\n\n\n  var dataIDs = source.getRecordIDs();\n\n  for (var ii = 0; ii < dataIDs.length; ii++) {\n    var dataID = dataIDs[ii];\n    var sourceRecord = source.get(dataID);\n    var targetRecord = target.get(dataID); // Prevent mutation of a record from outside the store.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (sourceRecord) {\n        RelayModernRecord.freeze(sourceRecord);\n      }\n    }\n\n    if (sourceRecord && targetRecord) {\n      var nextRecord = RelayModernRecord.update(targetRecord, sourceRecord);\n\n      if (nextRecord !== targetRecord) {\n        // Prevent mutation of a record from outside the store.\n        if (process.env.NODE_ENV !== \"production\") {\n          RelayModernRecord.freeze(nextRecord);\n        }\n\n        updatedRecordIDs[dataID] = true;\n        target.set(dataID, nextRecord);\n      }\n    } else if (sourceRecord === null) {\n      target[\"delete\"](dataID);\n\n      if (targetRecord !== null) {\n        updatedRecordIDs[dataID] = true;\n      }\n    } else if (sourceRecord) {\n      target.set(dataID, sourceRecord);\n      updatedRecordIDs[dataID] = true;\n    } // don't add explicit undefined\n\n  }\n}\n/**\n * Returns an OperationAvailability given the Availability returned\n * by checking an operation, and when that operation was last written to the store.\n * Specifically, the provided Availability of an operation will contain the\n * value of when a record referenced by the operation was most recently\n * invalidated; given that value, and given when this operation was last\n * written to the store, this function will return the overall\n * OperationAvailability for the operation.\n */\n\n\nfunction getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {\n  var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt,\n      status = operationAvailability.status;\n\n  if (typeof mostRecentlyInvalidatedAt === 'number') {\n    // If some record referenced by this operation is stale, then the operation itself is stale\n    // if either the operation itself was never written *or* the operation was last written\n    // before the most recent invalidation of its reachable records.\n    if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {\n      return {\n        status: 'stale'\n      };\n    }\n  }\n\n  if (status === 'missing') {\n    return {\n      status: 'missing'\n    };\n  }\n\n  if (operationFetchTime != null && queryCacheExpirationTime != null) {\n    var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;\n\n    if (isStale) {\n      return {\n        status: 'stale'\n      };\n    }\n  } // There were no invalidations of any reachable records *or* the operation is known to have\n  // been fetched after the most recent record invalidation.\n\n\n  return {\n    status: 'available',\n    fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null\n  };\n}\n\nRelayProfiler.instrumentMethods(RelayModernStore.prototype, {\n  lookup: 'RelayModernStore.prototype.lookup'\n});\nmodule.exports = RelayModernStore;"]},"metadata":{},"sourceType":"script"}