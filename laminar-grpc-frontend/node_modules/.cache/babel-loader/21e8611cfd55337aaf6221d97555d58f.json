{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar React = require('react');\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    deepFreeze = _require.deepFreeze,\n    getRequest = _require.getRequest;\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\n\n\nvar requestCache = {};\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\n\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n\n    _this.state = _objectSpread({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      var query = nextProps.query;\n      var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n      prevState.queryFetcher.disposeRequest();\n      var queryFetcher;\n\n      if (query) {\n        var request = getRequest(query);\n        var requestCacheKey = getRequestCacheKey(request.params, nextProps.variables);\n        queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n      } else {\n        queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n      }\n\n      return _objectSpread({\n        prevQuery: nextProps.query,\n        prevPropsEnvironment: nextProps.environment,\n        prevPropsVariables: nextProps.variables,\n        queryFetcher: queryFetcher\n      }, fetchQueryAndComputeStateFromProps(nextProps, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally\n      // and we want the updated requestCacheKey, since variables may have changed\n      ));\n    }\n\n    return null;\n  };\n\n  var _proto = ReactRelayQueryRenderer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _this$state = this.state,\n        retryCallbacks = _this$state.retryCallbacks,\n        queryFetcher = _this$state.queryFetcher,\n        requestCacheKey = _this$state.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n\n    retryCallbacks.handleDataChange = function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        } // Don't update state if nothing has changed.\n\n\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    };\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(retryCallbacks.handleDataChange);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // We don't need to cache the request after the component commits\n    var requestCacheKey = this.state.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey]; // HACK\n\n      delete this.state.requestCacheKey;\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n  };\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  _proto.render = function render() {\n    var _this$state2 = this.state,\n        renderProps = _this$state2.renderProps,\n        relayContext = _this$state2.relayContext; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, this.props.render(renderProps));\n  };\n\n  return ReactRelayQueryRenderer;\n}(React.Component);\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables;\n  var genericEnvironment = environment;\n\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n      var snapshot = requestCache[requestCacheKey].snapshot;\n\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        cacheConfig: props.cacheConfig,\n        environment: genericEnvironment,\n        onDataChange: retryCallbacks.handleDataChange,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests\n\n\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/react-relay/lib/ReactRelayQueryRenderer.js"],"names":["_interopRequireDefault","require","_defineProperty2","_inheritsLoose2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","React","ReactRelayContext","ReactRelayQueryFetcher","areEqual","_require","createOperationDescriptor","deepFreeze","getRequest","requestCache","ReactRelayQueryRenderer","_React$Component","props","_this","call","retryCallbacks","handleDataChange","handleRetryAfterError","queryFetcher","requestCacheKey","query","request","getRequestCacheKey","params","variables","state","prevPropsEnvironment","environment","prevPropsVariables","prevQuery","fetchQueryAndComputeStateFromProps","getDerivedStateFromProps","nextProps","prevState","prevSelectionReferences","getSelectionReferences","disposeRequest","_proto","prototype","componentDidMount","_this2","_this$state","error","snapshot","setState","prevRequestCacheKey","renderProps","getRenderProps","getLoadingRenderProps","setOnDataChange","componentDidUpdate","componentWillUnmount","dispose","shouldComponentUpdate","nextState","render","_this$state2","relayContext","process","env","NODE_ENV","createElement","Provider","value","Component","retry","getEmptyRenderProps","data","cacheConfigOverride","syncSnapshot","JSON","stringify","id","cacheID","genericEnvironment","operation","storeSnapshot","lookupInStore","fetchPolicy","querySnapshot","fetch","cacheConfig","onDataChange","_snapshot","_relayContext","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar React = require('react');\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    deepFreeze = _require.deepFreeze,\n    getRequest = _require.getRequest;\n\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\nvar requestCache = {};\n\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n\n    _this.state = _objectSpread({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      var query = nextProps.query;\n      var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n      prevState.queryFetcher.disposeRequest();\n      var queryFetcher;\n\n      if (query) {\n        var request = getRequest(query);\n        var requestCacheKey = getRequestCacheKey(request.params, nextProps.variables);\n        queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n      } else {\n        queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n      }\n\n      return _objectSpread({\n        prevQuery: nextProps.query,\n        prevPropsEnvironment: nextProps.environment,\n        prevPropsVariables: nextProps.variables,\n        queryFetcher: queryFetcher\n      }, fetchQueryAndComputeStateFromProps(nextProps, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally\n      // and we want the updated requestCacheKey, since variables may have changed\n      ));\n    }\n\n    return null;\n  };\n\n  var _proto = ReactRelayQueryRenderer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _this$state = this.state,\n        retryCallbacks = _this$state.retryCallbacks,\n        queryFetcher = _this$state.queryFetcher,\n        requestCacheKey = _this$state.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n\n    retryCallbacks.handleDataChange = function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        } // Don't update state if nothing has changed.\n\n\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    };\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(retryCallbacks.handleDataChange);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // We don't need to cache the request after the component commits\n    var requestCacheKey = this.state.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey]; // HACK\n\n      delete this.state.requestCacheKey;\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n  };\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  _proto.render = function render() {\n    var _this$state2 = this.state,\n        renderProps = _this$state2.renderProps,\n        relayContext = _this$state2.relayContext; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, this.props.render(renderProps));\n  };\n\n  return ReactRelayQueryRenderer;\n}(React.Component);\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables;\n  var genericEnvironment = environment;\n\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n      var snapshot = requestCache[requestCacheKey].snapshot;\n\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        cacheConfig: props.cacheConfig,\n        environment: genericEnvironment,\n        onDataChange: retryCallbacks.handleDataChange,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests\n\n\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;"]},"metadata":{},"sourceType":"script"}