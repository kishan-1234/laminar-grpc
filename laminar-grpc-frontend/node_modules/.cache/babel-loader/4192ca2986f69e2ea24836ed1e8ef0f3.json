{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar ErrorUtils = require(\"fbjs/lib/ErrorUtils\");\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar RelayRecordSourceSelectorProxy = require('../mutations/RelayRecordSourceSelectorProxy');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n/**\n * Coordinates the concurrent modification of a `Store` due to optimistic and\n * non-revertable client updates and server payloads:\n * - Applies optimistic updates.\n * - Reverts optimistic updates, rebasing any subsequent updates.\n * - Commits client updates (typically for client schema extensions).\n * - Commits server updates:\n *   - Normalizes query/mutation/subscription responses.\n *   - Executes handlers for \"handle\" fields.\n *   - Reverts and reapplies pending optimistic updates.\n */\n\n\nvar RelayPublishQueue = /*#__PURE__*/function () {\n  // True if the next `run()` should apply the backup and rerun all optimistic\n  // updates performing a rebase.\n  // Payloads to apply or Sources to publish to the store with the next `run()`.\n  // Optimistic updaters to add with the next `run()`.\n  // Optimistic updaters that are already added and might be rerun in order to\n  // rebase them.\n  // Garbage collection hold, should rerun gc on dispose\n  function RelayPublishQueue(store, handlerProvider, getDataID) {\n    this._hasStoreSnapshot = false;\n    this._handlerProvider = handlerProvider || null;\n    this._pendingBackupRebase = false;\n    this._pendingData = new Set();\n    this._pendingOptimisticUpdates = new Set();\n    this._store = store;\n    this._appliedOptimisticUpdates = new Set();\n    this._gcHold = null;\n    this._getDataID = getDataID;\n  }\n  /**\n   * Schedule applying an optimistic updates on the next `run()`.\n   */\n\n\n  var _proto = RelayPublishQueue.prototype;\n\n  _proto.applyUpdate = function applyUpdate(updater) {\n    !(!this._appliedOptimisticUpdates.has(updater) && !this._pendingOptimisticUpdates.has(updater)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayPublishQueue: Cannot apply the same update function more than ' + 'once concurrently.') : invariant(false) : void 0;\n\n    this._pendingOptimisticUpdates.add(updater);\n  }\n  /**\n   * Schedule reverting an optimistic updates on the next `run()`.\n   */\n  ;\n\n  _proto.revertUpdate = function revertUpdate(updater) {\n    if (this._pendingOptimisticUpdates.has(updater)) {\n      // Reverted before it was applied\n      this._pendingOptimisticUpdates[\"delete\"](updater);\n    } else if (this._appliedOptimisticUpdates.has(updater)) {\n      this._pendingBackupRebase = true;\n\n      this._appliedOptimisticUpdates[\"delete\"](updater);\n    }\n  }\n  /**\n   * Schedule a revert of all optimistic updates on the next `run()`.\n   */\n  ;\n\n  _proto.revertAll = function revertAll() {\n    this._pendingBackupRebase = true;\n\n    this._pendingOptimisticUpdates.clear();\n\n    this._appliedOptimisticUpdates.clear();\n  }\n  /**\n   * Schedule applying a payload to the store on the next `run()`.\n   */\n  ;\n\n  _proto.commitPayload = function commitPayload(operation, payload, updater) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'payload',\n      operation: operation,\n      payload: payload,\n      updater: updater\n    });\n  }\n  /**\n   * Schedule an updater to mutate the store on the next `run()` typically to\n   * update client schema fields.\n   */\n  ;\n\n  _proto.commitUpdate = function commitUpdate(updater) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'updater',\n      updater: updater\n    });\n  }\n  /**\n   * Schedule a publish to the store from the provided source on the next\n   * `run()`. As an example, to update the store with substituted fields that\n   * are missing in the store.\n   */\n  ;\n\n  _proto.commitSource = function commitSource(source) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'source',\n      source: source\n    });\n  }\n  /**\n   * Execute all queued up operations from the other public methods.\n   */\n  ;\n\n  _proto.run = function run(sourceOperation) {\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(this._isRunning !== true, 'A store update was detected within another store update. Please ' + 'make sure new store updates arenâ€™t being executed within an ' + 'updater function for a different update.') : void 0;\n      this._isRunning = true;\n    }\n\n    if (this._pendingBackupRebase) {\n      if (this._hasStoreSnapshot) {\n        this._store.restore();\n\n        this._hasStoreSnapshot = false;\n      }\n    }\n\n    var invalidatedStore = this._commitData();\n\n    if (this._pendingOptimisticUpdates.size || this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {\n      if (!this._hasStoreSnapshot) {\n        this._store.snapshot();\n\n        this._hasStoreSnapshot = true;\n      }\n\n      this._applyUpdates();\n    }\n\n    this._pendingBackupRebase = false;\n\n    if (this._appliedOptimisticUpdates.size > 0) {\n      if (!this._gcHold) {\n        this._gcHold = this._store.holdGC();\n      }\n    } else {\n      if (this._gcHold) {\n        this._gcHold.dispose();\n\n        this._gcHold = null;\n      }\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this._isRunning = false;\n    }\n\n    return this._store.notify(sourceOperation, invalidatedStore);\n  }\n  /**\n   * _publishSourceFromPayload will return a boolean indicating if the\n   * publish caused the store to be globally invalidated.\n   */\n  ;\n\n  _proto._publishSourceFromPayload = function _publishSourceFromPayload(pendingPayload) {\n    var _this = this;\n\n    var payload = pendingPayload.payload,\n        operation = pendingPayload.operation,\n        updater = pendingPayload.updater;\n    var source = payload.source,\n        fieldPayloads = payload.fieldPayloads;\n    var mutator = new RelayRecordSourceMutator(this._store.getSource(), source);\n    var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID);\n\n    if (fieldPayloads && fieldPayloads.length) {\n      fieldPayloads.forEach(function (fieldPayload) {\n        var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);\n\n        !handler ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected a handler to be provided for ' + 'handle `%s`.', fieldPayload.handle) : invariant(false) : void 0;\n        handler.update(recordSourceProxy, fieldPayload);\n      });\n    }\n\n    if (updater) {\n      var selector = operation.fragment;\n      !(selector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected a selector to be provided with updater function.') : invariant(false) : void 0;\n      var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, selector);\n      var selectorData = lookupSelector(source, selector);\n      updater(recordSourceSelectorProxy, selectorData);\n    }\n\n    var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();\n\n    this._store.publish(source, idsMarkedForInvalidation);\n\n    return recordSourceProxy.isStoreMarkedForInvalidation();\n  }\n  /**\n   * _commitData will return a boolean indicating if any of\n   * the pending commits caused the store to be globally invalidated.\n   */\n  ;\n\n  _proto._commitData = function _commitData() {\n    var _this2 = this;\n\n    if (!this._pendingData.size) {\n      return false;\n    }\n\n    var invalidatedStore = false;\n\n    this._pendingData.forEach(function (data) {\n      if (data.kind === 'payload') {\n        var payloadInvalidatedStore = _this2._publishSourceFromPayload(data);\n\n        invalidatedStore = invalidatedStore || payloadInvalidatedStore;\n      } else if (data.kind === 'source') {\n        var source = data.source;\n\n        _this2._store.publish(source);\n      } else {\n        var updater = data.updater;\n        var sink = RelayRecordSource.create();\n        var mutator = new RelayRecordSourceMutator(_this2._store.getSource(), sink);\n        var recordSourceProxy = new RelayRecordSourceProxy(mutator, _this2._getDataID);\n        ErrorUtils.applyWithGuard(updater, null, [recordSourceProxy], null, 'RelayPublishQueue:commitData');\n        invalidatedStore = invalidatedStore || recordSourceProxy.isStoreMarkedForInvalidation();\n        var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();\n\n        _this2._store.publish(sink, idsMarkedForInvalidation);\n      }\n    });\n\n    this._pendingData.clear();\n\n    return invalidatedStore;\n  }\n  /**\n   * Note that unlike _commitData, _applyUpdates will NOT return a boolean\n   * indicating if the store was globally invalidated, since invalidating the\n   * store during an optimistic update is a no-op.\n   */\n  ;\n\n  _proto._applyUpdates = function _applyUpdates() {\n    var _this3 = this;\n\n    var sink = RelayRecordSource.create();\n    var mutator = new RelayRecordSourceMutator(this._store.getSource(), sink);\n    var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider);\n\n    var processUpdate = function processUpdate(optimisticUpdate) {\n      if (optimisticUpdate.storeUpdater) {\n        var storeUpdater = optimisticUpdate.storeUpdater;\n        ErrorUtils.applyWithGuard(storeUpdater, null, [recordSourceProxy], null, 'RelayPublishQueue:applyUpdates');\n      } else {\n        var operation = optimisticUpdate.operation,\n            payload = optimisticUpdate.payload,\n            updater = optimisticUpdate.updater;\n        var source = payload.source,\n            fieldPayloads = payload.fieldPayloads;\n        var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, operation.fragment);\n        var selectorData;\n\n        if (source) {\n          recordSourceProxy.publishSource(source, fieldPayloads);\n          selectorData = lookupSelector(source, operation.fragment);\n        }\n\n        if (updater) {\n          ErrorUtils.applyWithGuard(updater, null, [recordSourceSelectorProxy, selectorData], null, 'RelayPublishQueue:applyUpdates');\n        }\n      }\n    }; // rerun all updaters in case we are running a rebase\n\n\n    if (this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {\n      this._appliedOptimisticUpdates.forEach(processUpdate);\n    } // apply any new updaters\n\n\n    if (this._pendingOptimisticUpdates.size) {\n      this._pendingOptimisticUpdates.forEach(function (optimisticUpdate) {\n        processUpdate(optimisticUpdate);\n\n        _this3._appliedOptimisticUpdates.add(optimisticUpdate);\n      });\n\n      this._pendingOptimisticUpdates.clear();\n    }\n\n    this._store.publish(sink);\n  };\n\n  return RelayPublishQueue;\n}();\n\nfunction lookupSelector(source, selector) {\n  var selectorData = RelayReader.read(source, selector).data;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var deepFreeze = require('../util/deepFreeze');\n\n    if (selectorData) {\n      deepFreeze(selectorData);\n    }\n  }\n\n  return selectorData;\n}\n\nmodule.exports = RelayPublishQueue;","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/RelayPublishQueue.js"],"names":["ErrorUtils","require","RelayReader","RelayRecordSource","RelayRecordSourceMutator","RelayRecordSourceProxy","RelayRecordSourceSelectorProxy","invariant","warning","RelayPublishQueue","store","handlerProvider","getDataID","_hasStoreSnapshot","_handlerProvider","_pendingBackupRebase","_pendingData","Set","_pendingOptimisticUpdates","_store","_appliedOptimisticUpdates","_gcHold","_getDataID","_proto","prototype","applyUpdate","updater","has","process","env","NODE_ENV","add","revertUpdate","revertAll","clear","commitPayload","operation","payload","kind","commitUpdate","commitSource","source","run","sourceOperation","_isRunning","restore","invalidatedStore","_commitData","size","snapshot","_applyUpdates","holdGC","dispose","notify","_publishSourceFromPayload","pendingPayload","_this","fieldPayloads","mutator","getSource","recordSourceProxy","length","forEach","fieldPayload","handler","handle","update","selector","fragment","recordSourceSelectorProxy","selectorData","lookupSelector","idsMarkedForInvalidation","getIDsMarkedForInvalidation","publish","isStoreMarkedForInvalidation","_this2","data","payloadInvalidatedStore","sink","create","applyWithGuard","_this3","processUpdate","optimisticUpdate","storeUpdater","publishSource","read","deepFreeze","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar ErrorUtils = require(\"fbjs/lib/ErrorUtils\");\n\nvar RelayReader = require('./RelayReader');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar RelayRecordSourceSelectorProxy = require('../mutations/RelayRecordSourceSelectorProxy');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n\n/**\n * Coordinates the concurrent modification of a `Store` due to optimistic and\n * non-revertable client updates and server payloads:\n * - Applies optimistic updates.\n * - Reverts optimistic updates, rebasing any subsequent updates.\n * - Commits client updates (typically for client schema extensions).\n * - Commits server updates:\n *   - Normalizes query/mutation/subscription responses.\n *   - Executes handlers for \"handle\" fields.\n *   - Reverts and reapplies pending optimistic updates.\n */\nvar RelayPublishQueue = /*#__PURE__*/function () {\n  // True if the next `run()` should apply the backup and rerun all optimistic\n  // updates performing a rebase.\n  // Payloads to apply or Sources to publish to the store with the next `run()`.\n  // Optimistic updaters to add with the next `run()`.\n  // Optimistic updaters that are already added and might be rerun in order to\n  // rebase them.\n  // Garbage collection hold, should rerun gc on dispose\n  function RelayPublishQueue(store, handlerProvider, getDataID) {\n    this._hasStoreSnapshot = false;\n    this._handlerProvider = handlerProvider || null;\n    this._pendingBackupRebase = false;\n    this._pendingData = new Set();\n    this._pendingOptimisticUpdates = new Set();\n    this._store = store;\n    this._appliedOptimisticUpdates = new Set();\n    this._gcHold = null;\n    this._getDataID = getDataID;\n  }\n  /**\n   * Schedule applying an optimistic updates on the next `run()`.\n   */\n\n\n  var _proto = RelayPublishQueue.prototype;\n\n  _proto.applyUpdate = function applyUpdate(updater) {\n    !(!this._appliedOptimisticUpdates.has(updater) && !this._pendingOptimisticUpdates.has(updater)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayPublishQueue: Cannot apply the same update function more than ' + 'once concurrently.') : invariant(false) : void 0;\n\n    this._pendingOptimisticUpdates.add(updater);\n  }\n  /**\n   * Schedule reverting an optimistic updates on the next `run()`.\n   */\n  ;\n\n  _proto.revertUpdate = function revertUpdate(updater) {\n    if (this._pendingOptimisticUpdates.has(updater)) {\n      // Reverted before it was applied\n      this._pendingOptimisticUpdates[\"delete\"](updater);\n    } else if (this._appliedOptimisticUpdates.has(updater)) {\n      this._pendingBackupRebase = true;\n\n      this._appliedOptimisticUpdates[\"delete\"](updater);\n    }\n  }\n  /**\n   * Schedule a revert of all optimistic updates on the next `run()`.\n   */\n  ;\n\n  _proto.revertAll = function revertAll() {\n    this._pendingBackupRebase = true;\n\n    this._pendingOptimisticUpdates.clear();\n\n    this._appliedOptimisticUpdates.clear();\n  }\n  /**\n   * Schedule applying a payload to the store on the next `run()`.\n   */\n  ;\n\n  _proto.commitPayload = function commitPayload(operation, payload, updater) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'payload',\n      operation: operation,\n      payload: payload,\n      updater: updater\n    });\n  }\n  /**\n   * Schedule an updater to mutate the store on the next `run()` typically to\n   * update client schema fields.\n   */\n  ;\n\n  _proto.commitUpdate = function commitUpdate(updater) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'updater',\n      updater: updater\n    });\n  }\n  /**\n   * Schedule a publish to the store from the provided source on the next\n   * `run()`. As an example, to update the store with substituted fields that\n   * are missing in the store.\n   */\n  ;\n\n  _proto.commitSource = function commitSource(source) {\n    this._pendingBackupRebase = true;\n\n    this._pendingData.add({\n      kind: 'source',\n      source: source\n    });\n  }\n  /**\n   * Execute all queued up operations from the other public methods.\n   */\n  ;\n\n  _proto.run = function run(sourceOperation) {\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(this._isRunning !== true, 'A store update was detected within another store update. Please ' + 'make sure new store updates arenâ€™t being executed within an ' + 'updater function for a different update.') : void 0;\n      this._isRunning = true;\n    }\n\n    if (this._pendingBackupRebase) {\n      if (this._hasStoreSnapshot) {\n        this._store.restore();\n\n        this._hasStoreSnapshot = false;\n      }\n    }\n\n    var invalidatedStore = this._commitData();\n\n    if (this._pendingOptimisticUpdates.size || this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {\n      if (!this._hasStoreSnapshot) {\n        this._store.snapshot();\n\n        this._hasStoreSnapshot = true;\n      }\n\n      this._applyUpdates();\n    }\n\n    this._pendingBackupRebase = false;\n\n    if (this._appliedOptimisticUpdates.size > 0) {\n      if (!this._gcHold) {\n        this._gcHold = this._store.holdGC();\n      }\n    } else {\n      if (this._gcHold) {\n        this._gcHold.dispose();\n\n        this._gcHold = null;\n      }\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this._isRunning = false;\n    }\n\n    return this._store.notify(sourceOperation, invalidatedStore);\n  }\n  /**\n   * _publishSourceFromPayload will return a boolean indicating if the\n   * publish caused the store to be globally invalidated.\n   */\n  ;\n\n  _proto._publishSourceFromPayload = function _publishSourceFromPayload(pendingPayload) {\n    var _this = this;\n\n    var payload = pendingPayload.payload,\n        operation = pendingPayload.operation,\n        updater = pendingPayload.updater;\n    var source = payload.source,\n        fieldPayloads = payload.fieldPayloads;\n    var mutator = new RelayRecordSourceMutator(this._store.getSource(), source);\n    var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID);\n\n    if (fieldPayloads && fieldPayloads.length) {\n      fieldPayloads.forEach(function (fieldPayload) {\n        var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);\n\n        !handler ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected a handler to be provided for ' + 'handle `%s`.', fieldPayload.handle) : invariant(false) : void 0;\n        handler.update(recordSourceProxy, fieldPayload);\n      });\n    }\n\n    if (updater) {\n      var selector = operation.fragment;\n      !(selector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected a selector to be provided with updater function.') : invariant(false) : void 0;\n      var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, selector);\n      var selectorData = lookupSelector(source, selector);\n      updater(recordSourceSelectorProxy, selectorData);\n    }\n\n    var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();\n\n    this._store.publish(source, idsMarkedForInvalidation);\n\n    return recordSourceProxy.isStoreMarkedForInvalidation();\n  }\n  /**\n   * _commitData will return a boolean indicating if any of\n   * the pending commits caused the store to be globally invalidated.\n   */\n  ;\n\n  _proto._commitData = function _commitData() {\n    var _this2 = this;\n\n    if (!this._pendingData.size) {\n      return false;\n    }\n\n    var invalidatedStore = false;\n\n    this._pendingData.forEach(function (data) {\n      if (data.kind === 'payload') {\n        var payloadInvalidatedStore = _this2._publishSourceFromPayload(data);\n\n        invalidatedStore = invalidatedStore || payloadInvalidatedStore;\n      } else if (data.kind === 'source') {\n        var source = data.source;\n\n        _this2._store.publish(source);\n      } else {\n        var updater = data.updater;\n        var sink = RelayRecordSource.create();\n        var mutator = new RelayRecordSourceMutator(_this2._store.getSource(), sink);\n        var recordSourceProxy = new RelayRecordSourceProxy(mutator, _this2._getDataID);\n        ErrorUtils.applyWithGuard(updater, null, [recordSourceProxy], null, 'RelayPublishQueue:commitData');\n        invalidatedStore = invalidatedStore || recordSourceProxy.isStoreMarkedForInvalidation();\n        var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();\n\n        _this2._store.publish(sink, idsMarkedForInvalidation);\n      }\n    });\n\n    this._pendingData.clear();\n\n    return invalidatedStore;\n  }\n  /**\n   * Note that unlike _commitData, _applyUpdates will NOT return a boolean\n   * indicating if the store was globally invalidated, since invalidating the\n   * store during an optimistic update is a no-op.\n   */\n  ;\n\n  _proto._applyUpdates = function _applyUpdates() {\n    var _this3 = this;\n\n    var sink = RelayRecordSource.create();\n    var mutator = new RelayRecordSourceMutator(this._store.getSource(), sink);\n    var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider);\n\n    var processUpdate = function processUpdate(optimisticUpdate) {\n      if (optimisticUpdate.storeUpdater) {\n        var storeUpdater = optimisticUpdate.storeUpdater;\n        ErrorUtils.applyWithGuard(storeUpdater, null, [recordSourceProxy], null, 'RelayPublishQueue:applyUpdates');\n      } else {\n        var operation = optimisticUpdate.operation,\n            payload = optimisticUpdate.payload,\n            updater = optimisticUpdate.updater;\n        var source = payload.source,\n            fieldPayloads = payload.fieldPayloads;\n        var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, operation.fragment);\n        var selectorData;\n\n        if (source) {\n          recordSourceProxy.publishSource(source, fieldPayloads);\n          selectorData = lookupSelector(source, operation.fragment);\n        }\n\n        if (updater) {\n          ErrorUtils.applyWithGuard(updater, null, [recordSourceSelectorProxy, selectorData], null, 'RelayPublishQueue:applyUpdates');\n        }\n      }\n    }; // rerun all updaters in case we are running a rebase\n\n\n    if (this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {\n      this._appliedOptimisticUpdates.forEach(processUpdate);\n    } // apply any new updaters\n\n\n    if (this._pendingOptimisticUpdates.size) {\n      this._pendingOptimisticUpdates.forEach(function (optimisticUpdate) {\n        processUpdate(optimisticUpdate);\n\n        _this3._appliedOptimisticUpdates.add(optimisticUpdate);\n      });\n\n      this._pendingOptimisticUpdates.clear();\n    }\n\n    this._store.publish(sink);\n  };\n\n  return RelayPublishQueue;\n}();\n\nfunction lookupSelector(source, selector) {\n  var selectorData = RelayReader.read(source, selector).data;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var deepFreeze = require('../util/deepFreeze');\n\n    if (selectorData) {\n      deepFreeze(selectorData);\n    }\n  }\n\n  return selectorData;\n}\n\nmodule.exports = RelayPublishQueue;"]},"metadata":{},"sourceType":"script"}