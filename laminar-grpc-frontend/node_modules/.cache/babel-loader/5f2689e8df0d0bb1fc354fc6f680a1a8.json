{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nfunction emptyFunction() {}\n\nvar aggregateHandlersByName = {\n  '*': []\n};\nvar profileHandlersByName = {\n  '*': []\n};\nvar NOT_INVOKED = {};\nvar defaultProfiler = {\n  stop: emptyFunction\n};\n\nvar shouldInstrument = function shouldInstrument(name) {\n  if (process.env.NODE_ENV !== \"production\") {\n    return true;\n  }\n\n  return name.charAt(0) !== '@';\n};\n/**\n * @public\n *\n * Instruments methods to allow profiling various parts of Relay. Profiling code\n * in Relay consists of three steps:\n *\n *  - Instrument the function to be profiled.\n *  - Attach handlers to the instrumented function.\n *  - Run the code which triggers the handlers.\n *\n * Handlers attached to instrumented methods are called with an instrumentation\n * name and a callback that must be synchronously executed:\n *\n *   instrumentedMethod.attachHandler(function(name, callback) {\n *     const start = performance.now();\n *     callback();\n *     console.log('Duration', performance.now() - start);\n *   });\n *\n * Handlers for profiles are callbacks that return a stop method:\n *\n *   RelayProfiler.attachProfileHandler('profileName', (name, state) => {\n *     const start = performance.now();\n *     return function stop(name, state) {\n *       console.log(`Duration (${name})`, performance.now() - start);\n *     }\n *   });\n *\n * In order to reduce the impact on performance in production, instrumented\n * methods and profilers with names that begin with `@` will only be measured\n * if `__DEV__` is true. This should be used for very hot functions.\n */\n\n\nvar RelayProfiler = {\n  /**\n   * Instruments methods on a class or object. This re-assigns the method in\n   * order to preserve function names in stack traces (which are detected by\n   * modern debuggers via heuristics). Example usage:\n   *\n   *   const RelayStore = { primeCache: function() {...} };\n   *   RelayProfiler.instrumentMethods(RelayStore, {\n   *     primeCache: 'RelayStore.primeCache'\n   *   });\n   *\n   *   RelayStore.primeCache.attachHandler(...);\n   *\n   * As a result, the methods will be replaced by wrappers that provide the\n   * `attachHandler` and `detachHandler` methods.\n   */\n  instrumentMethods: function instrumentMethods(object, names) {\n    for (var _key in names) {\n      if (names.hasOwnProperty(_key)) {\n        if (typeof object[_key] === 'function') {\n          object[_key] = RelayProfiler.instrument(names[_key], object[_key]);\n        }\n      }\n    }\n  },\n\n  /**\n   * Wraps the supplied function with one that provides the `attachHandler` and\n   * `detachHandler` methods. Example usage:\n   *\n   *   const printRelayQuery =\n   *     RelayProfiler.instrument('printRelayQuery', printRelayQuery);\n   *\n   *   printRelayQuery.attachHandler(...);\n   *\n   * NOTE: The instrumentation assumes that no handlers are attached or detached\n   * in the course of executing another handler.\n   */\n  instrument: function instrument(name, originalFunction) {\n    if (!shouldInstrument(name)) {\n      originalFunction.attachHandler = emptyFunction;\n      originalFunction.detachHandler = emptyFunction;\n      return originalFunction;\n    }\n\n    if (!aggregateHandlersByName.hasOwnProperty(name)) {\n      aggregateHandlersByName[name] = [];\n    }\n\n    var catchallHandlers = aggregateHandlersByName['*'];\n    var aggregateHandlers = aggregateHandlersByName[name];\n    var handlers = [];\n    var contexts = [];\n\n    var invokeHandlers = function invokeHandlers() {\n      var context = contexts[contexts.length - 1];\n\n      if (context[0]) {\n        context[0]--;\n        catchallHandlers[context[0]](name, invokeHandlers);\n      } else if (context[1]) {\n        context[1]--;\n        aggregateHandlers[context[1]](name, invokeHandlers);\n      } else if (context[2]) {\n        context[2]--;\n        handlers[context[2]](name, invokeHandlers);\n      } else {\n        context[5] = originalFunction.apply(context[3], context[4]);\n      }\n    };\n\n    var instrumentedCallback = function instrumentedCallback() {\n      var returnValue;\n\n      if (aggregateHandlers.length === 0 && handlers.length === 0 && catchallHandlers.length === 0) {\n        returnValue = originalFunction.apply(this, arguments);\n      } else {\n        contexts.push([catchallHandlers.length, aggregateHandlers.length, handlers.length, this, arguments, NOT_INVOKED]);\n        invokeHandlers();\n        var context = contexts.pop();\n        returnValue = context[5];\n\n        if (returnValue === NOT_INVOKED) {\n          throw new Error('RelayProfiler: Handler did not invoke original function.');\n        }\n      }\n\n      return returnValue;\n    };\n\n    instrumentedCallback.attachHandler = function (handler) {\n      handlers.push(handler);\n    };\n\n    instrumentedCallback.detachHandler = function (handler) {\n      removeFromArray(handlers, handler);\n    };\n\n    instrumentedCallback.displayName = '(instrumented ' + name + ')';\n    return instrumentedCallback;\n  },\n\n  /**\n   * Attaches a handler to all methods instrumented with the supplied name.\n   *\n   *   function createRenderer() {\n   *     return RelayProfiler.instrument('render', function() {...});\n   *   }\n   *   const renderA = createRenderer();\n   *   const renderB = createRenderer();\n   *\n   *   // Only profiles `renderA`.\n   *   renderA.attachHandler(...);\n   *\n   *   // Profiles both `renderA` and `renderB`.\n   *   RelayProfiler.attachAggregateHandler('render', ...);\n   *\n   */\n  attachAggregateHandler: function attachAggregateHandler(name, handler) {\n    if (shouldInstrument(name)) {\n      if (!aggregateHandlersByName.hasOwnProperty(name)) {\n        aggregateHandlersByName[name] = [];\n      }\n\n      aggregateHandlersByName[name].push(handler);\n    }\n  },\n\n  /**\n   * Detaches a handler attached via `attachAggregateHandler`.\n   */\n  detachAggregateHandler: function detachAggregateHandler(name, handler) {\n    if (shouldInstrument(name)) {\n      if (aggregateHandlersByName.hasOwnProperty(name)) {\n        removeFromArray(aggregateHandlersByName[name], handler);\n      }\n    }\n  },\n\n  /**\n   * Instruments profiling for arbitrarily asynchronous code by a name.\n   *\n   *   const timerProfiler = RelayProfiler.profile('timeout');\n   *   setTimeout(function() {\n   *     timerProfiler.stop();\n   *   }, 1000);\n   *\n   *   RelayProfiler.attachProfileHandler('timeout', ...);\n   *\n   * Arbitrary state can also be passed into `profile` as a second argument. The\n   * attached profile handlers will receive this as the second argument.\n   */\n  profile: function profile(name, state) {\n    var hasCatchAllHandlers = profileHandlersByName['*'].length > 0;\n    var hasNamedHandlers = profileHandlersByName.hasOwnProperty(name);\n\n    if (hasNamedHandlers || hasCatchAllHandlers) {\n      var profileHandlers = hasNamedHandlers && hasCatchAllHandlers ? profileHandlersByName[name].concat(profileHandlersByName['*']) : hasNamedHandlers ? profileHandlersByName[name] : profileHandlersByName['*'];\n      var stopHandlers;\n\n      for (var ii = profileHandlers.length - 1; ii >= 0; ii--) {\n        var profileHandler = profileHandlers[ii];\n        var stopHandler = profileHandler(name, state);\n        stopHandlers = stopHandlers || [];\n        stopHandlers.unshift(stopHandler);\n      }\n\n      return {\n        stop: function stop(error) {\n          if (stopHandlers) {\n            stopHandlers.forEach(function (stopHandler) {\n              return stopHandler(error);\n            });\n          }\n        }\n      };\n    }\n\n    return defaultProfiler;\n  },\n\n  /**\n   * Attaches a handler to profiles with the supplied name. You can also\n   * attach to the special name '*' which is a catch all.\n   */\n  attachProfileHandler: function attachProfileHandler(name, handler) {\n    if (shouldInstrument(name)) {\n      if (!profileHandlersByName.hasOwnProperty(name)) {\n        profileHandlersByName[name] = [];\n      }\n\n      profileHandlersByName[name].push(handler);\n    }\n  },\n\n  /**\n   * Detaches a handler attached via `attachProfileHandler`.\n   */\n  detachProfileHandler: function detachProfileHandler(name, handler) {\n    if (shouldInstrument(name)) {\n      if (profileHandlersByName.hasOwnProperty(name)) {\n        removeFromArray(profileHandlersByName[name], handler);\n      }\n    }\n  }\n};\n\nfunction removeFromArray(array, element) {\n  var index = array.indexOf(element);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nmodule.exports = RelayProfiler;","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/util/RelayProfiler.js"],"names":["emptyFunction","aggregateHandlersByName","profileHandlersByName","NOT_INVOKED","defaultProfiler","stop","shouldInstrument","name","process","env","NODE_ENV","charAt","RelayProfiler","instrumentMethods","object","names","_key","hasOwnProperty","instrument","originalFunction","attachHandler","detachHandler","catchallHandlers","aggregateHandlers","handlers","contexts","invokeHandlers","context","length","apply","instrumentedCallback","returnValue","arguments","push","pop","Error","handler","removeFromArray","displayName","attachAggregateHandler","detachAggregateHandler","profile","state","hasCatchAllHandlers","hasNamedHandlers","profileHandlers","concat","stopHandlers","ii","profileHandler","stopHandler","unshift","error","forEach","attachProfileHandler","detachProfileHandler","array","element","index","indexOf","splice","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nfunction emptyFunction() {}\n\nvar aggregateHandlersByName = {\n  '*': []\n};\nvar profileHandlersByName = {\n  '*': []\n};\nvar NOT_INVOKED = {};\nvar defaultProfiler = {\n  stop: emptyFunction\n};\n\nvar shouldInstrument = function shouldInstrument(name) {\n  if (process.env.NODE_ENV !== \"production\") {\n    return true;\n  }\n\n  return name.charAt(0) !== '@';\n};\n/**\n * @public\n *\n * Instruments methods to allow profiling various parts of Relay. Profiling code\n * in Relay consists of three steps:\n *\n *  - Instrument the function to be profiled.\n *  - Attach handlers to the instrumented function.\n *  - Run the code which triggers the handlers.\n *\n * Handlers attached to instrumented methods are called with an instrumentation\n * name and a callback that must be synchronously executed:\n *\n *   instrumentedMethod.attachHandler(function(name, callback) {\n *     const start = performance.now();\n *     callback();\n *     console.log('Duration', performance.now() - start);\n *   });\n *\n * Handlers for profiles are callbacks that return a stop method:\n *\n *   RelayProfiler.attachProfileHandler('profileName', (name, state) => {\n *     const start = performance.now();\n *     return function stop(name, state) {\n *       console.log(`Duration (${name})`, performance.now() - start);\n *     }\n *   });\n *\n * In order to reduce the impact on performance in production, instrumented\n * methods and profilers with names that begin with `@` will only be measured\n * if `__DEV__` is true. This should be used for very hot functions.\n */\n\n\nvar RelayProfiler = {\n  /**\n   * Instruments methods on a class or object. This re-assigns the method in\n   * order to preserve function names in stack traces (which are detected by\n   * modern debuggers via heuristics). Example usage:\n   *\n   *   const RelayStore = { primeCache: function() {...} };\n   *   RelayProfiler.instrumentMethods(RelayStore, {\n   *     primeCache: 'RelayStore.primeCache'\n   *   });\n   *\n   *   RelayStore.primeCache.attachHandler(...);\n   *\n   * As a result, the methods will be replaced by wrappers that provide the\n   * `attachHandler` and `detachHandler` methods.\n   */\n  instrumentMethods: function instrumentMethods(object, names) {\n    for (var _key in names) {\n      if (names.hasOwnProperty(_key)) {\n        if (typeof object[_key] === 'function') {\n          object[_key] = RelayProfiler.instrument(names[_key], object[_key]);\n        }\n      }\n    }\n  },\n\n  /**\n   * Wraps the supplied function with one that provides the `attachHandler` and\n   * `detachHandler` methods. Example usage:\n   *\n   *   const printRelayQuery =\n   *     RelayProfiler.instrument('printRelayQuery', printRelayQuery);\n   *\n   *   printRelayQuery.attachHandler(...);\n   *\n   * NOTE: The instrumentation assumes that no handlers are attached or detached\n   * in the course of executing another handler.\n   */\n  instrument: function instrument(name, originalFunction) {\n    if (!shouldInstrument(name)) {\n      originalFunction.attachHandler = emptyFunction;\n      originalFunction.detachHandler = emptyFunction;\n      return originalFunction;\n    }\n\n    if (!aggregateHandlersByName.hasOwnProperty(name)) {\n      aggregateHandlersByName[name] = [];\n    }\n\n    var catchallHandlers = aggregateHandlersByName['*'];\n    var aggregateHandlers = aggregateHandlersByName[name];\n    var handlers = [];\n    var contexts = [];\n\n    var invokeHandlers = function invokeHandlers() {\n      var context = contexts[contexts.length - 1];\n\n      if (context[0]) {\n        context[0]--;\n        catchallHandlers[context[0]](name, invokeHandlers);\n      } else if (context[1]) {\n        context[1]--;\n        aggregateHandlers[context[1]](name, invokeHandlers);\n      } else if (context[2]) {\n        context[2]--;\n        handlers[context[2]](name, invokeHandlers);\n      } else {\n        context[5] = originalFunction.apply(context[3], context[4]);\n      }\n    };\n\n    var instrumentedCallback = function instrumentedCallback() {\n      var returnValue;\n\n      if (aggregateHandlers.length === 0 && handlers.length === 0 && catchallHandlers.length === 0) {\n        returnValue = originalFunction.apply(this, arguments);\n      } else {\n        contexts.push([catchallHandlers.length, aggregateHandlers.length, handlers.length, this, arguments, NOT_INVOKED]);\n        invokeHandlers();\n        var context = contexts.pop();\n        returnValue = context[5];\n\n        if (returnValue === NOT_INVOKED) {\n          throw new Error('RelayProfiler: Handler did not invoke original function.');\n        }\n      }\n\n      return returnValue;\n    };\n\n    instrumentedCallback.attachHandler = function (handler) {\n      handlers.push(handler);\n    };\n\n    instrumentedCallback.detachHandler = function (handler) {\n      removeFromArray(handlers, handler);\n    };\n\n    instrumentedCallback.displayName = '(instrumented ' + name + ')';\n    return instrumentedCallback;\n  },\n\n  /**\n   * Attaches a handler to all methods instrumented with the supplied name.\n   *\n   *   function createRenderer() {\n   *     return RelayProfiler.instrument('render', function() {...});\n   *   }\n   *   const renderA = createRenderer();\n   *   const renderB = createRenderer();\n   *\n   *   // Only profiles `renderA`.\n   *   renderA.attachHandler(...);\n   *\n   *   // Profiles both `renderA` and `renderB`.\n   *   RelayProfiler.attachAggregateHandler('render', ...);\n   *\n   */\n  attachAggregateHandler: function attachAggregateHandler(name, handler) {\n    if (shouldInstrument(name)) {\n      if (!aggregateHandlersByName.hasOwnProperty(name)) {\n        aggregateHandlersByName[name] = [];\n      }\n\n      aggregateHandlersByName[name].push(handler);\n    }\n  },\n\n  /**\n   * Detaches a handler attached via `attachAggregateHandler`.\n   */\n  detachAggregateHandler: function detachAggregateHandler(name, handler) {\n    if (shouldInstrument(name)) {\n      if (aggregateHandlersByName.hasOwnProperty(name)) {\n        removeFromArray(aggregateHandlersByName[name], handler);\n      }\n    }\n  },\n\n  /**\n   * Instruments profiling for arbitrarily asynchronous code by a name.\n   *\n   *   const timerProfiler = RelayProfiler.profile('timeout');\n   *   setTimeout(function() {\n   *     timerProfiler.stop();\n   *   }, 1000);\n   *\n   *   RelayProfiler.attachProfileHandler('timeout', ...);\n   *\n   * Arbitrary state can also be passed into `profile` as a second argument. The\n   * attached profile handlers will receive this as the second argument.\n   */\n  profile: function profile(name, state) {\n    var hasCatchAllHandlers = profileHandlersByName['*'].length > 0;\n    var hasNamedHandlers = profileHandlersByName.hasOwnProperty(name);\n\n    if (hasNamedHandlers || hasCatchAllHandlers) {\n      var profileHandlers = hasNamedHandlers && hasCatchAllHandlers ? profileHandlersByName[name].concat(profileHandlersByName['*']) : hasNamedHandlers ? profileHandlersByName[name] : profileHandlersByName['*'];\n      var stopHandlers;\n\n      for (var ii = profileHandlers.length - 1; ii >= 0; ii--) {\n        var profileHandler = profileHandlers[ii];\n        var stopHandler = profileHandler(name, state);\n        stopHandlers = stopHandlers || [];\n        stopHandlers.unshift(stopHandler);\n      }\n\n      return {\n        stop: function stop(error) {\n          if (stopHandlers) {\n            stopHandlers.forEach(function (stopHandler) {\n              return stopHandler(error);\n            });\n          }\n        }\n      };\n    }\n\n    return defaultProfiler;\n  },\n\n  /**\n   * Attaches a handler to profiles with the supplied name. You can also\n   * attach to the special name '*' which is a catch all.\n   */\n  attachProfileHandler: function attachProfileHandler(name, handler) {\n    if (shouldInstrument(name)) {\n      if (!profileHandlersByName.hasOwnProperty(name)) {\n        profileHandlersByName[name] = [];\n      }\n\n      profileHandlersByName[name].push(handler);\n    }\n  },\n\n  /**\n   * Detaches a handler attached via `attachProfileHandler`.\n   */\n  detachProfileHandler: function detachProfileHandler(name, handler) {\n    if (shouldInstrument(name)) {\n      if (profileHandlersByName.hasOwnProperty(name)) {\n        removeFromArray(profileHandlersByName[name], handler);\n      }\n    }\n  }\n};\n\nfunction removeFromArray(array, element) {\n  var index = array.indexOf(element);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nmodule.exports = RelayProfiler;"]},"metadata":{},"sourceType":"script"}