{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar getRelayHandleKey = require('../util/getRelayHandleKey');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar stableCopy = require('../util/stableCopy');\n\nvar VARIABLE = RelayConcreteNode.VARIABLE,\n    LITERAL = RelayConcreteNode.LITERAL,\n    OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE,\n    LIST_VALUE = RelayConcreteNode.LIST_VALUE;\nvar MODULE_COMPONENT_KEY_PREFIX = '__module_component_';\nvar MODULE_OPERATION_KEY_PREFIX = '__module_operation_';\n\nfunction getArgumentValue(arg, variables) {\n  if (arg.kind === VARIABLE) {\n    // Variables are provided at runtime and are not guaranteed to be stable.\n    return getStableVariableValue(arg.variableName, variables);\n  } else if (arg.kind === LITERAL) {\n    // The Relay compiler generates stable ConcreteArgument values.\n    return arg.value;\n  } else if (arg.kind === OBJECT_VALUE) {\n    var value = {};\n    arg.fields.forEach(function (field) {\n      value[field.name] = getArgumentValue(field, variables);\n    });\n    return value;\n  } else if (arg.kind === LIST_VALUE) {\n    var _value = [];\n    arg.items.forEach(function (item) {\n      item != null ? _value.push(getArgumentValue(item, variables)) : null;\n    });\n    return _value;\n  }\n}\n/**\n * Returns the values of field/fragment arguments as an object keyed by argument\n * names. Guaranteed to return a result with stable ordered nested values.\n */\n\n\nfunction getArgumentValues(args, variables) {\n  var values = {};\n  args.forEach(function (arg) {\n    values[arg.name] = getArgumentValue(arg, variables);\n  });\n  return values;\n}\n/**\n * Given a handle field and variable values, returns a key that can be used to\n * uniquely identify the combination of the handle name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getHandleStorageKey(handleField, variables) {\n  var dynamicKey = handleField.dynamicKey,\n      handle = handleField.handle,\n      key = handleField.key,\n      name = handleField.name,\n      args = handleField.args,\n      filters = handleField.filters;\n  var handleName = getRelayHandleKey(handle, key, name);\n  var filterArgs = null;\n\n  if (args && filters && args.length !== 0 && filters.length !== 0) {\n    filterArgs = args.filter(function (arg) {\n      return filters.indexOf(arg.name) > -1;\n    });\n  }\n\n  if (dynamicKey) {\n    // \"Sort\" the arguments by argument name: this is done by the compiler for\n    // user-supplied arguments but the dynamic argument must also be in sorted\n    // order.  Note that dynamic key argument name is double-underscore-\n    // -prefixed, and a double-underscore prefix is disallowed for user-supplied\n    // argument names, so there's no need to actually sort.\n    filterArgs = filterArgs != null ? [dynamicKey].concat((0, _toConsumableArray2[\"default\"])(filterArgs)) : [dynamicKey];\n  }\n\n  if (filterArgs === null) {\n    return handleName;\n  } else {\n    return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));\n  }\n}\n/**\n * Given a field and variable values, returns a key that can be used to\n * uniquely identify the combination of the field name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getStorageKey(field, variables) {\n  if (field.storageKey) {\n    // TODO T23663664: Handle nodes do not yet define a static storageKey.\n    return field.storageKey;\n  }\n\n  var args = field.args,\n      name = field.name;\n  return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;\n}\n/**\n * Given a `name` (eg. \"foo\") and an object representing argument values\n * (eg. `{orberBy: \"name\", first: 10}`) returns a unique storage key\n * (ie. `foo{\"first\":10,\"orderBy\":\"name\"}`).\n *\n * This differs from getStorageKey which requires a ConcreteNode where arguments\n * are assumed to already be sorted into a stable order.\n */\n\n\nfunction getStableStorageKey(name, args) {\n  return formatStorageKey(name, stableCopy(args));\n}\n/**\n * Given a name and argument values, format a storage key.\n *\n * Arguments and the values within them are expected to be ordered in a stable\n * alphabetical ordering.\n */\n\n\nfunction formatStorageKey(name, argValues) {\n  if (!argValues) {\n    return name;\n  }\n\n  var values = [];\n\n  for (var argName in argValues) {\n    if (argValues.hasOwnProperty(argName)) {\n      var value = argValues[argName];\n\n      if (value != null) {\n        var _JSON$stringify;\n\n        values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));\n      }\n    }\n  }\n\n  return values.length === 0 ? name : name + \"(\".concat(values.join(','), \")\");\n}\n/**\n * Given Variables and a variable name, return a variable value with\n * all values in a stable order.\n */\n\n\nfunction getStableVariableValue(name, variables) {\n  !variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'getVariableValue(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n  return stableCopy(variables[name]);\n}\n\nfunction getModuleComponentKey(documentName) {\n  return \"\".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);\n}\n\nfunction getModuleOperationKey(documentName) {\n  return \"\".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);\n}\n/**\n * Constants shared by all implementations of RecordSource/MutableRecordSource/etc.\n */\n\n\nvar RelayStoreUtils = {\n  FRAGMENTS_KEY: '__fragments',\n  FRAGMENT_OWNER_KEY: '__fragmentOwner',\n  FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',\n  MODULE_COMPONENT_KEY: '__module_component',\n  // alias returned by Reader\n  ID_KEY: '__id',\n  REF_KEY: '__ref',\n  REFS_KEY: '__refs',\n  ROOT_ID: 'client:root',\n  ROOT_TYPE: '__Root',\n  TYPENAME_KEY: '__typename',\n  INVALIDATED_AT_KEY: '__invalidated_at',\n  IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '__isWithinUnmatchedTypeRefinement',\n  formatStorageKey: formatStorageKey,\n  getArgumentValue: getArgumentValue,\n  getArgumentValues: getArgumentValues,\n  getHandleStorageKey: getHandleStorageKey,\n  getStorageKey: getStorageKey,\n  getStableStorageKey: getStableStorageKey,\n  getModuleComponentKey: getModuleComponentKey,\n  getModuleOperationKey: getModuleOperationKey\n};\nmodule.exports = RelayStoreUtils;","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/RelayStoreUtils.js"],"names":["_interopRequireDefault","require","_toConsumableArray2","RelayConcreteNode","getRelayHandleKey","invariant","stableCopy","VARIABLE","LITERAL","OBJECT_VALUE","LIST_VALUE","MODULE_COMPONENT_KEY_PREFIX","MODULE_OPERATION_KEY_PREFIX","getArgumentValue","arg","variables","kind","getStableVariableValue","variableName","value","fields","forEach","field","name","_value","items","item","push","getArgumentValues","args","values","getHandleStorageKey","handleField","dynamicKey","handle","key","filters","handleName","filterArgs","length","filter","indexOf","concat","formatStorageKey","getStorageKey","storageKey","getStableStorageKey","argValues","argName","hasOwnProperty","_JSON$stringify","JSON","stringify","join","process","env","NODE_ENV","getModuleComponentKey","documentName","getModuleOperationKey","RelayStoreUtils","FRAGMENTS_KEY","FRAGMENT_OWNER_KEY","FRAGMENT_PROP_NAME_KEY","MODULE_COMPONENT_KEY","ID_KEY","REF_KEY","REFS_KEY","ROOT_ID","ROOT_TYPE","TYPENAME_KEY","INVALIDATED_AT_KEY","IS_WITHIN_UNMATCHED_TYPE_REFINEMENT","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar getRelayHandleKey = require('../util/getRelayHandleKey');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar stableCopy = require('../util/stableCopy');\n\nvar VARIABLE = RelayConcreteNode.VARIABLE,\n    LITERAL = RelayConcreteNode.LITERAL,\n    OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE,\n    LIST_VALUE = RelayConcreteNode.LIST_VALUE;\nvar MODULE_COMPONENT_KEY_PREFIX = '__module_component_';\nvar MODULE_OPERATION_KEY_PREFIX = '__module_operation_';\n\nfunction getArgumentValue(arg, variables) {\n  if (arg.kind === VARIABLE) {\n    // Variables are provided at runtime and are not guaranteed to be stable.\n    return getStableVariableValue(arg.variableName, variables);\n  } else if (arg.kind === LITERAL) {\n    // The Relay compiler generates stable ConcreteArgument values.\n    return arg.value;\n  } else if (arg.kind === OBJECT_VALUE) {\n    var value = {};\n    arg.fields.forEach(function (field) {\n      value[field.name] = getArgumentValue(field, variables);\n    });\n    return value;\n  } else if (arg.kind === LIST_VALUE) {\n    var _value = [];\n    arg.items.forEach(function (item) {\n      item != null ? _value.push(getArgumentValue(item, variables)) : null;\n    });\n    return _value;\n  }\n}\n/**\n * Returns the values of field/fragment arguments as an object keyed by argument\n * names. Guaranteed to return a result with stable ordered nested values.\n */\n\n\nfunction getArgumentValues(args, variables) {\n  var values = {};\n  args.forEach(function (arg) {\n    values[arg.name] = getArgumentValue(arg, variables);\n  });\n  return values;\n}\n/**\n * Given a handle field and variable values, returns a key that can be used to\n * uniquely identify the combination of the handle name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getHandleStorageKey(handleField, variables) {\n  var dynamicKey = handleField.dynamicKey,\n      handle = handleField.handle,\n      key = handleField.key,\n      name = handleField.name,\n      args = handleField.args,\n      filters = handleField.filters;\n  var handleName = getRelayHandleKey(handle, key, name);\n  var filterArgs = null;\n\n  if (args && filters && args.length !== 0 && filters.length !== 0) {\n    filterArgs = args.filter(function (arg) {\n      return filters.indexOf(arg.name) > -1;\n    });\n  }\n\n  if (dynamicKey) {\n    // \"Sort\" the arguments by argument name: this is done by the compiler for\n    // user-supplied arguments but the dynamic argument must also be in sorted\n    // order.  Note that dynamic key argument name is double-underscore-\n    // -prefixed, and a double-underscore prefix is disallowed for user-supplied\n    // argument names, so there's no need to actually sort.\n    filterArgs = filterArgs != null ? [dynamicKey].concat((0, _toConsumableArray2[\"default\"])(filterArgs)) : [dynamicKey];\n  }\n\n  if (filterArgs === null) {\n    return handleName;\n  } else {\n    return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));\n  }\n}\n/**\n * Given a field and variable values, returns a key that can be used to\n * uniquely identify the combination of the field name and argument values.\n *\n * Note: the word \"storage\" here refers to the fact this key is primarily used\n * when writing the results of a key in a normalized graph or \"store\". This\n * name was used in previous implementations of Relay internals and is also\n * used here for consistency.\n */\n\n\nfunction getStorageKey(field, variables) {\n  if (field.storageKey) {\n    // TODO T23663664: Handle nodes do not yet define a static storageKey.\n    return field.storageKey;\n  }\n\n  var args = field.args,\n      name = field.name;\n  return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;\n}\n/**\n * Given a `name` (eg. \"foo\") and an object representing argument values\n * (eg. `{orberBy: \"name\", first: 10}`) returns a unique storage key\n * (ie. `foo{\"first\":10,\"orderBy\":\"name\"}`).\n *\n * This differs from getStorageKey which requires a ConcreteNode where arguments\n * are assumed to already be sorted into a stable order.\n */\n\n\nfunction getStableStorageKey(name, args) {\n  return formatStorageKey(name, stableCopy(args));\n}\n/**\n * Given a name and argument values, format a storage key.\n *\n * Arguments and the values within them are expected to be ordered in a stable\n * alphabetical ordering.\n */\n\n\nfunction formatStorageKey(name, argValues) {\n  if (!argValues) {\n    return name;\n  }\n\n  var values = [];\n\n  for (var argName in argValues) {\n    if (argValues.hasOwnProperty(argName)) {\n      var value = argValues[argName];\n\n      if (value != null) {\n        var _JSON$stringify;\n\n        values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));\n      }\n    }\n  }\n\n  return values.length === 0 ? name : name + \"(\".concat(values.join(','), \")\");\n}\n/**\n * Given Variables and a variable name, return a variable value with\n * all values in a stable order.\n */\n\n\nfunction getStableVariableValue(name, variables) {\n  !variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'getVariableValue(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n  return stableCopy(variables[name]);\n}\n\nfunction getModuleComponentKey(documentName) {\n  return \"\".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);\n}\n\nfunction getModuleOperationKey(documentName) {\n  return \"\".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);\n}\n/**\n * Constants shared by all implementations of RecordSource/MutableRecordSource/etc.\n */\n\n\nvar RelayStoreUtils = {\n  FRAGMENTS_KEY: '__fragments',\n  FRAGMENT_OWNER_KEY: '__fragmentOwner',\n  FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',\n  MODULE_COMPONENT_KEY: '__module_component',\n  // alias returned by Reader\n  ID_KEY: '__id',\n  REF_KEY: '__ref',\n  REFS_KEY: '__refs',\n  ROOT_ID: 'client:root',\n  ROOT_TYPE: '__Root',\n  TYPENAME_KEY: '__typename',\n  INVALIDATED_AT_KEY: '__invalidated_at',\n  IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '__isWithinUnmatchedTypeRefinement',\n  formatStorageKey: formatStorageKey,\n  getArgumentValue: getArgumentValue,\n  getArgumentValues: getArgumentValues,\n  getHandleStorageKey: getHandleStorageKey,\n  getStorageKey: getStorageKey,\n  getStableStorageKey: getStableStorageKey,\n  getModuleComponentKey: getModuleComponentKey,\n  getModuleOperationKey: getModuleOperationKey\n};\nmodule.exports = RelayStoreUtils;"]},"metadata":{},"sourceType":"script"}