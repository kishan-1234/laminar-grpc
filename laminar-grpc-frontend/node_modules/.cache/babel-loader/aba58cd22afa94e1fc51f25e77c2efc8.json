{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar isPromise = require('../util/isPromise');\n/**\n * A Subscription object is returned from .subscribe(), which can be\n * unsubscribed or checked to see if the resulting subscription has closed.\n */\n\n\nvar hostReportError = swallowError;\n/**\n * Limited implementation of ESObservable, providing the limited set of behavior\n * Relay networking requires.\n *\n * Observables retain the benefit of callbacks which can be called\n * synchronously, avoiding any UI jitter, while providing a compositional API,\n * which simplifies logic and prevents mishandling of errors compared to\n * the direct use of callback functions.\n *\n * ESObservable: https://github.com/tc39/proposal-observable\n */\n\nvar RelayObservable = /*#__PURE__*/function () {\n  RelayObservable.create = function create(source) {\n    return new RelayObservable(source);\n  } // Use RelayObservable.create()\n  ;\n\n  function RelayObservable(source) {\n    if (process.env.NODE_ENV !== \"production\") {\n      // Early runtime errors for ill-formed sources.\n      if (!source || typeof source !== 'function') {\n        throw new Error('Source must be a Function: ' + String(source));\n      }\n    }\n\n    this._source = source;\n  }\n  /**\n   * When an emitted error event is not handled by an Observer, it is reported\n   * to the host environment (what the ESObservable spec refers to as\n   * \"HostReportErrors()\").\n   *\n   * The default implementation in development rethrows thrown errors, and\n   * logs emitted error events to the console, while in production does nothing\n   * (swallowing unhandled errors).\n   *\n   * Called during application initialization, this method allows\n   * application-specific handling of unhandled errors. Allowing, for example,\n   * integration with error logging or developer tools.\n   *\n   * A second parameter `isUncaughtThrownError` is true when the unhandled error\n   * was thrown within an Observer handler, and false when the unhandled error\n   * was an unhandled emitted event.\n   *\n   *  - Uncaught thrown errors typically represent avoidable errors thrown from\n   *    application code, which should be handled with a try/catch block, and\n   *    usually have useful stack traces.\n   *\n   *  - Unhandled emitted event errors typically represent unavoidable events in\n   *    application flow such as network failure, and may not have useful\n   *    stack traces.\n   */\n\n\n  RelayObservable.onUnhandledError = function onUnhandledError(callback) {\n    hostReportError = callback;\n  }\n  /**\n   * Accepts various kinds of data sources, and always returns a RelayObservable\n   * useful for accepting the result of a user-provided FetchFunction.\n   */\n  ;\n\n  RelayObservable.from = function from(obj) {\n    return isObservable(obj) ? fromObservable(obj) : isPromise(obj) ? fromPromise(obj) : fromValue(obj);\n  }\n  /**\n   * Similar to promise.catch(), observable.catch() handles error events, and\n   * provides an alternative observable to use in it's place.\n   *\n   * If the catch handler throws a new error, it will appear as an error event\n   * on the resulting Observable.\n   */\n  ;\n\n  var _proto = RelayObservable.prototype;\n\n  _proto[\"catch\"] = function _catch(fn) {\n    var _this = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription;\n\n      _this.subscribe({\n        start: function start(sub) {\n          subscription = sub;\n        },\n        next: sink.next,\n        complete: sink.complete,\n        error: function error(_error2) {\n          try {\n            fn(_error2).subscribe({\n              start: function start(sub) {\n                subscription = sub;\n              },\n              next: sink.next,\n              complete: sink.complete,\n              error: sink.error\n            });\n          } catch (error2) {\n            sink.error(error2, true\n            /* isUncaughtThrownError */\n            );\n          }\n        }\n      });\n\n      return function () {\n        return subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which first yields values from this Observable,\n   * then yields values from the next Observable. This is useful for chaining\n   * together Observables of finite length.\n   */\n  ;\n\n  _proto.concat = function concat(next) {\n    var _this2 = this;\n\n    return RelayObservable.create(function (sink) {\n      var current;\n\n      _this2.subscribe({\n        start: function start(subscription) {\n          current = subscription;\n        },\n        next: sink.next,\n        error: sink.error,\n        complete: function complete() {\n          current = next.subscribe(sink);\n        }\n      });\n\n      return function () {\n        current && current.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the provided Observer is called to perform a side-effects\n   * for all events emitted by the source.\n   *\n   * Any errors that are thrown in the side-effect Observer are unhandled, and\n   * do not affect the source Observable or its Observer.\n   *\n   * This is useful for when debugging your Observables or performing other\n   * side-effects such as logging or performance monitoring.\n   */\n  ;\n\n  _proto[\"do\"] = function _do(observer) {\n    var _this3 = this;\n\n    return RelayObservable.create(function (sink) {\n      var both = function both(action) {\n        return function () {\n          try {\n            observer[action] && observer[action].apply(observer, arguments);\n          } catch (error) {\n            hostReportError(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n\n          sink[action] && sink[action].apply(sink, arguments);\n        };\n      };\n\n      return _this3.subscribe({\n        start: both('start'),\n        next: both('next'),\n        error: both('error'),\n        complete: both('complete'),\n        unsubscribe: both('unsubscribe')\n      });\n    });\n  }\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the finally callback is performed after completion,\n   * whether normal or due to error or unsubscription.\n   *\n   * This is useful for cleanup such as resource finalization.\n   */\n  ;\n\n  _proto[\"finally\"] = function _finally(fn) {\n    var _this4 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this4.subscribe(sink);\n\n      return function () {\n        subscription.unsubscribe();\n        fn();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which is identical to this one, unless this\n   * Observable completes before yielding any values, in which case the new\n   * Observable will yield the values from the alternate Observable.\n   *\n   * If this Observable does yield values, the alternate is never subscribed to.\n   *\n   * This is useful for scenarios where values may come from multiple sources\n   * which should be tried in order, i.e. from a cache before a network.\n   */\n  ;\n\n  _proto.ifEmpty = function ifEmpty(alternate) {\n    var _this5 = this;\n\n    return RelayObservable.create(function (sink) {\n      var hasValue = false;\n\n      var current = _this5.subscribe({\n        next: function next(value) {\n          hasValue = true;\n          sink.next(value);\n        },\n        error: sink.error,\n        complete: function complete() {\n          if (hasValue) {\n            sink.complete();\n          } else {\n            current = alternate.subscribe(sink);\n          }\n        }\n      });\n\n      return function () {\n        current.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Observable's primary API: returns an unsubscribable Subscription to the\n   * source of this Observable.\n   *\n   * Note: A sink may be passed directly to .subscribe() as its observer,\n   * allowing for easily composing Observables.\n   */\n  ;\n\n  _proto.subscribe = function subscribe(observer) {\n    if (process.env.NODE_ENV !== \"production\") {\n      // Early runtime errors for ill-formed observers.\n      if (!observer || typeof observer !== 'object') {\n        throw new Error('Observer must be an Object with callbacks: ' + String(observer));\n      }\n    }\n\n    return _subscribe(this._source, observer);\n  }\n  /**\n   * Returns a new Observerable where each value has been transformed by\n   * the mapping function.\n   */\n  ;\n\n  _proto.map = function map(fn) {\n    var _this6 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this6.subscribe({\n        complete: sink.complete,\n        error: sink.error,\n        next: function next(value) {\n          try {\n            var mapValue = fn(value);\n            sink.next(mapValue);\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        }\n      });\n\n      return function () {\n        subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable where each value is replaced with a new Observable\n   * by the mapping function, the results of which returned as a single\n   * merged Observable.\n   */\n  ;\n\n  _proto.mergeMap = function mergeMap(fn) {\n    var _this7 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscriptions = [];\n\n      function start(subscription) {\n        this._sub = subscription;\n        subscriptions.push(subscription);\n      }\n\n      function complete() {\n        subscriptions.splice(subscriptions.indexOf(this._sub), 1);\n\n        if (subscriptions.length === 0) {\n          sink.complete();\n        }\n      }\n\n      _this7.subscribe({\n        start: start,\n        next: function next(value) {\n          try {\n            if (!sink.closed) {\n              RelayObservable.from(fn(value)).subscribe({\n                start: start,\n                next: sink.next,\n                error: sink.error,\n                complete: complete\n              });\n            }\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        },\n        error: sink.error,\n        complete: complete\n      });\n\n      return function () {\n        subscriptions.forEach(function (sub) {\n          return sub.unsubscribe();\n        });\n        subscriptions.length = 0;\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which first mirrors this Observable, then when it\n   * completes, waits for `pollInterval` milliseconds before re-subscribing to\n   * this Observable again, looping in this manner until unsubscribed.\n   *\n   * The returned Observable never completes.\n   */\n  ;\n\n  _proto.poll = function poll(pollInterval) {\n    var _this8 = this;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof pollInterval !== 'number' || pollInterval <= 0) {\n        throw new Error('RelayObservable: Expected pollInterval to be positive, got: ' + pollInterval);\n      }\n    }\n\n    return RelayObservable.create(function (sink) {\n      var subscription;\n      var timeout;\n\n      var poll = function poll() {\n        subscription = _this8.subscribe({\n          next: sink.next,\n          error: sink.error,\n          complete: function complete() {\n            timeout = setTimeout(poll, pollInterval);\n          }\n        });\n      };\n\n      poll();\n      return function () {\n        clearTimeout(timeout);\n        subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a Promise which resolves when this Observable yields a first value\n   * or when it completes with no value.\n   *\n   * NOTE: The source Observable is *NOT* canceled when the returned Promise\n   * resolves. The Observable is always run to completion.\n   */\n  ;\n\n  _proto.toPromise = function toPromise() {\n    var _this9 = this;\n\n    return new Promise(function (resolve, reject) {\n      var resolved = false;\n\n      _this9.subscribe({\n        next: function next(val) {\n          if (!resolved) {\n            resolved = true;\n            resolve(val);\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  return RelayObservable;\n}(); // Use declarations to teach Flow how to check isObservable.\n\n\nfunction isObservable(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.subscribe === 'function';\n}\n\nfunction fromObservable(obj) {\n  return obj instanceof RelayObservable ? obj : RelayObservable.create(function (sink) {\n    return obj.subscribe(sink);\n  });\n}\n\nfunction fromPromise(promise) {\n  return RelayObservable.create(function (sink) {\n    // Since sink methods do not throw, the resulting Promise can be ignored.\n    promise.then(function (value) {\n      sink.next(value);\n      sink.complete();\n    }, sink.error);\n  });\n}\n\nfunction fromValue(value) {\n  return RelayObservable.create(function (sink) {\n    sink.next(value);\n    sink.complete();\n  });\n}\n\nfunction _subscribe(source, observer) {\n  var closed = false;\n  var cleanup; // Ideally we would simply describe a `get closed()` method on the Sink and\n  // Subscription objects below, however not all flow environments we expect\n  // Relay to be used within will support property getters, and many minifier\n  // tools still do not support ES5 syntax. Instead, we can use defineProperty.\n\n  var withClosed = function withClosed(obj) {\n    return Object.defineProperty(obj, 'closed', {\n      get: function get() {\n        return closed;\n      }\n    });\n  };\n\n  function doCleanup() {\n    if (cleanup) {\n      if (cleanup.unsubscribe) {\n        cleanup.unsubscribe();\n      } else {\n        try {\n          cleanup();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n\n      cleanup = undefined;\n    }\n  } // Create a Subscription.\n\n\n  var subscription = withClosed({\n    unsubscribe: function unsubscribe() {\n      if (!closed) {\n        closed = true; // Tell Observer that unsubscribe was called.\n\n        try {\n          observer.unsubscribe && observer.unsubscribe(subscription);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // Tell Observer that observation is about to begin.\n\n  try {\n    observer.start && observer.start(subscription);\n  } catch (error) {\n    hostReportError(error, true\n    /* isUncaughtThrownError */\n    );\n  } // If closed already, don't bother creating a Sink.\n\n\n  if (closed) {\n    return subscription;\n  } // Create a Sink respecting subscription state and cleanup.\n\n\n  var sink = withClosed({\n    next: function next(value) {\n      if (!closed && observer.next) {\n        try {\n          observer.next(value);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n    },\n    error: function error(_error3, isUncaughtThrownError) {\n      if (closed || !observer.error) {\n        closed = true;\n        hostReportError(_error3, isUncaughtThrownError || false);\n        doCleanup();\n      } else {\n        closed = true;\n\n        try {\n          observer.error(_error3);\n        } catch (error2) {\n          hostReportError(error2, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    },\n    complete: function complete() {\n      if (!closed) {\n        closed = true;\n\n        try {\n          observer.complete && observer.complete();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // If anything goes wrong during observing the source, handle the error.\n\n  try {\n    cleanup = source(sink);\n  } catch (error) {\n    sink.error(error, true\n    /* isUncaughtThrownError */\n    );\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // Early runtime errors for ill-formed returned cleanup.\n    if (cleanup !== undefined && typeof cleanup !== 'function' && (!cleanup || typeof cleanup.unsubscribe !== 'function')) {\n      throw new Error('Returned cleanup function which cannot be called: ' + String(cleanup));\n    }\n  } // If closed before the source function existed, cleanup now.\n\n\n  if (closed) {\n    doCleanup();\n  }\n\n  return subscription;\n}\n\nfunction swallowError(_error, _isUncaughtThrownError) {// do nothing.\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  // Default implementation of HostReportErrors() in development builds.\n  // Can be replaced by the host application environment.\n  RelayObservable.onUnhandledError(function (error, isUncaughtThrownError) {\n    if (typeof fail === 'function') {\n      // In test environments (Jest), fail() immediately fails the current test.\n      fail(String(error));\n    } else if (isUncaughtThrownError) {\n      // Rethrow uncaught thrown errors on the next frame to avoid breaking\n      // current logic.\n      setTimeout(function () {\n        throw error;\n      });\n    } else if (typeof console !== 'undefined') {\n      // Otherwise, log the unhandled error for visibility.\n      // eslint-disable-next-line no-console\n      console.error('RelayObservable: Unhandled Error', error);\n    }\n  });\n}\n\nmodule.exports = RelayObservable;","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/network/RelayObservable.js"],"names":["isPromise","require","hostReportError","swallowError","RelayObservable","create","source","process","env","NODE_ENV","Error","String","_source","onUnhandledError","callback","from","obj","isObservable","fromObservable","fromPromise","fromValue","_proto","prototype","_catch","fn","_this","sink","subscription","subscribe","start","sub","next","complete","error","_error2","error2","unsubscribe","concat","_this2","current","_do","observer","_this3","both","action","apply","arguments","_finally","_this4","ifEmpty","alternate","_this5","hasValue","value","_subscribe","map","_this6","mapValue","mergeMap","_this7","subscriptions","_sub","push","splice","indexOf","length","closed","forEach","poll","pollInterval","_this8","timeout","setTimeout","clearTimeout","toPromise","_this9","Promise","resolve","reject","resolved","val","promise","then","cleanup","withClosed","Object","defineProperty","get","doCleanup","undefined","_error3","isUncaughtThrownError","_error","_isUncaughtThrownError","fail","console","module","exports"],"mappings":"AAAA;;;;;;;;;AASA;AACA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,mBAAD,CAAvB;AACA;;;;;;AAMA,IAAIC,eAAe,GAAGC,YAAtB;AACA;;;;;;;;;;;;AAYA,IAAIC,eAAe,GAAG,aAAa,YAAY;AAC7CA,EAAAA,eAAe,CAACC,MAAhB,GAAyB,SAASA,MAAT,CAAgBC,MAAhB,EAAwB;AAC/C,WAAO,IAAIF,eAAJ,CAAoBE,MAApB,CAAP;AACD,GAFD,CAEE;AAFF;;AAKA,WAASF,eAAT,CAAyBE,MAAzB,EAAiC;AAC/B,QAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACA,UAAI,CAACH,MAAD,IAAW,OAAOA,MAAP,KAAkB,UAAjC,EAA6C;AAC3C,cAAM,IAAII,KAAJ,CAAU,gCAAgCC,MAAM,CAACL,MAAD,CAAhD,CAAN;AACD;AACF;;AAED,SAAKM,OAAL,GAAeN,MAAf;AACD;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BAF,EAAAA,eAAe,CAACS,gBAAhB,GAAmC,SAASA,gBAAT,CAA0BC,QAA1B,EAAoC;AACrEZ,IAAAA,eAAe,GAAGY,QAAlB;AACD;AACD;;;;AAHA;;AASAV,EAAAA,eAAe,CAACW,IAAhB,GAAuB,SAASA,IAAT,CAAcC,GAAd,EAAmB;AACxC,WAAOC,YAAY,CAACD,GAAD,CAAZ,GAAoBE,cAAc,CAACF,GAAD,CAAlC,GAA0ChB,SAAS,CAACgB,GAAD,CAAT,GAAiBG,WAAW,CAACH,GAAD,CAA5B,GAAoCI,SAAS,CAACJ,GAAD,CAA9F;AACD;AACD;;;;;;;AAHA;;AAYA,MAAIK,MAAM,GAAGjB,eAAe,CAACkB,SAA7B;;AAEAD,EAAAA,MAAM,CAAC,OAAD,CAAN,GAAkB,SAASE,MAAT,CAAgBC,EAAhB,EAAoB;AACpC,QAAIC,KAAK,GAAG,IAAZ;;AAEA,WAAOrB,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C,UAAIC,YAAJ;;AAEAF,MAAAA,KAAK,CAACG,SAAN,CAAgB;AACdC,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,GAAf,EAAoB;AACzBH,UAAAA,YAAY,GAAGG,GAAf;AACD,SAHa;AAIdC,QAAAA,IAAI,EAAEL,IAAI,CAACK,IAJG;AAKdC,QAAAA,QAAQ,EAAEN,IAAI,CAACM,QALD;AAMdC,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,OAAf,EAAwB;AAC7B,cAAI;AACFV,YAAAA,EAAE,CAACU,OAAD,CAAF,CAAYN,SAAZ,CAAsB;AACpBC,cAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,GAAf,EAAoB;AACzBH,gBAAAA,YAAY,GAAGG,GAAf;AACD,eAHmB;AAIpBC,cAAAA,IAAI,EAAEL,IAAI,CAACK,IAJS;AAKpBC,cAAAA,QAAQ,EAAEN,IAAI,CAACM,QALK;AAMpBC,cAAAA,KAAK,EAAEP,IAAI,CAACO;AANQ,aAAtB;AAQD,WATD,CASE,OAAOE,MAAP,EAAe;AACfT,YAAAA,IAAI,CAACO,KAAL,CAAWE,MAAX,EAAmB;AACnB;AADA;AAGD;AACF;AArBa,OAAhB;;AAwBA,aAAO,YAAY;AACjB,eAAOR,YAAY,CAACS,WAAb,EAAP;AACD,OAFD;AAGD,KA9BM,CAAP;AA+BD;AACD;;;;;AAnCA;;AA0CAf,EAAAA,MAAM,CAACgB,MAAP,GAAgB,SAASA,MAAT,CAAgBN,IAAhB,EAAsB;AACpC,QAAIO,MAAM,GAAG,IAAb;;AAEA,WAAOlC,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C,UAAIa,OAAJ;;AAEAD,MAAAA,MAAM,CAACV,SAAP,CAAiB;AACfC,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAeF,YAAf,EAA6B;AAClCY,UAAAA,OAAO,GAAGZ,YAAV;AACD,SAHc;AAIfI,QAAAA,IAAI,EAAEL,IAAI,CAACK,IAJI;AAKfE,QAAAA,KAAK,EAAEP,IAAI,CAACO,KALG;AAMfD,QAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5BO,UAAAA,OAAO,GAAGR,IAAI,CAACH,SAAL,CAAeF,IAAf,CAAV;AACD;AARc,OAAjB;;AAWA,aAAO,YAAY;AACjBa,QAAAA,OAAO,IAAIA,OAAO,CAACH,WAAR,EAAX;AACD,OAFD;AAGD,KAjBM,CAAP;AAkBD;AACD;;;;;;;;;;;AAtBA;;AAmCAf,EAAAA,MAAM,CAAC,IAAD,CAAN,GAAe,SAASmB,GAAT,CAAaC,QAAb,EAAuB;AACpC,QAAIC,MAAM,GAAG,IAAb;;AAEA,WAAOtC,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C,UAAIiB,IAAI,GAAG,SAASA,IAAT,CAAcC,MAAd,EAAsB;AAC/B,eAAO,YAAY;AACjB,cAAI;AACFH,YAAAA,QAAQ,CAACG,MAAD,CAAR,IAAoBH,QAAQ,CAACG,MAAD,CAAR,CAAiBC,KAAjB,CAAuBJ,QAAvB,EAAiCK,SAAjC,CAApB;AACD,WAFD,CAEE,OAAOb,KAAP,EAAc;AACd/B,YAAAA,eAAe,CAAC+B,KAAD,EAAQ;AACvB;AADe,aAAf;AAGD;;AAEDP,UAAAA,IAAI,CAACkB,MAAD,CAAJ,IAAgBlB,IAAI,CAACkB,MAAD,CAAJ,CAAaC,KAAb,CAAmBnB,IAAnB,EAAyBoB,SAAzB,CAAhB;AACD,SAVD;AAWD,OAZD;;AAcA,aAAOJ,MAAM,CAACd,SAAP,CAAiB;AACtBC,QAAAA,KAAK,EAAEc,IAAI,CAAC,OAAD,CADW;AAEtBZ,QAAAA,IAAI,EAAEY,IAAI,CAAC,MAAD,CAFY;AAGtBV,QAAAA,KAAK,EAAEU,IAAI,CAAC,OAAD,CAHW;AAItBX,QAAAA,QAAQ,EAAEW,IAAI,CAAC,UAAD,CAJQ;AAKtBP,QAAAA,WAAW,EAAEO,IAAI,CAAC,aAAD;AALK,OAAjB,CAAP;AAOD,KAtBM,CAAP;AAuBD;AACD;;;;;;;AA3BA;;AAoCAtB,EAAAA,MAAM,CAAC,SAAD,CAAN,GAAoB,SAAS0B,QAAT,CAAkBvB,EAAlB,EAAsB;AACxC,QAAIwB,MAAM,GAAG,IAAb;;AAEA,WAAO5C,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C,UAAIC,YAAY,GAAGqB,MAAM,CAACpB,SAAP,CAAiBF,IAAjB,CAAnB;;AAEA,aAAO,YAAY;AACjBC,QAAAA,YAAY,CAACS,WAAb;AACAZ,QAAAA,EAAE;AACH,OAHD;AAID,KAPM,CAAP;AAQD;AACD;;;;;;;;;;AAZA;;AAwBAH,EAAAA,MAAM,CAAC4B,OAAP,GAAiB,SAASA,OAAT,CAAiBC,SAAjB,EAA4B;AAC3C,QAAIC,MAAM,GAAG,IAAb;;AAEA,WAAO/C,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C,UAAI0B,QAAQ,GAAG,KAAf;;AAEA,UAAIb,OAAO,GAAGY,MAAM,CAACvB,SAAP,CAAiB;AAC7BG,QAAAA,IAAI,EAAE,SAASA,IAAT,CAAcsB,KAAd,EAAqB;AACzBD,UAAAA,QAAQ,GAAG,IAAX;AACA1B,UAAAA,IAAI,CAACK,IAAL,CAAUsB,KAAV;AACD,SAJ4B;AAK7BpB,QAAAA,KAAK,EAAEP,IAAI,CAACO,KALiB;AAM7BD,QAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5B,cAAIoB,QAAJ,EAAc;AACZ1B,YAAAA,IAAI,CAACM,QAAL;AACD,WAFD,MAEO;AACLO,YAAAA,OAAO,GAAGW,SAAS,CAACtB,SAAV,CAAoBF,IAApB,CAAV;AACD;AACF;AAZ4B,OAAjB,CAAd;;AAeA,aAAO,YAAY;AACjBa,QAAAA,OAAO,CAACH,WAAR;AACD,OAFD;AAGD,KArBM,CAAP;AAsBD;AACD;;;;;;;AA1BA;;AAmCAf,EAAAA,MAAM,CAACO,SAAP,GAAmB,SAASA,SAAT,CAAmBa,QAAnB,EAA6B;AAC9C,QAAIlC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACA,UAAI,CAACgC,QAAD,IAAa,OAAOA,QAAP,KAAoB,QAArC,EAA+C;AAC7C,cAAM,IAAI/B,KAAJ,CAAU,gDAAgDC,MAAM,CAAC8B,QAAD,CAAhE,CAAN;AACD;AACF;;AAED,WAAOa,UAAU,CAAC,KAAK1C,OAAN,EAAe6B,QAAf,CAAjB;AACD;AACD;;;;AAVA;;AAgBApB,EAAAA,MAAM,CAACkC,GAAP,GAAa,SAASA,GAAT,CAAa/B,EAAb,EAAiB;AAC5B,QAAIgC,MAAM,GAAG,IAAb;;AAEA,WAAOpD,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C,UAAIC,YAAY,GAAG6B,MAAM,CAAC5B,SAAP,CAAiB;AAClCI,QAAAA,QAAQ,EAAEN,IAAI,CAACM,QADmB;AAElCC,QAAAA,KAAK,EAAEP,IAAI,CAACO,KAFsB;AAGlCF,QAAAA,IAAI,EAAE,SAASA,IAAT,CAAcsB,KAAd,EAAqB;AACzB,cAAI;AACF,gBAAII,QAAQ,GAAGjC,EAAE,CAAC6B,KAAD,CAAjB;AACA3B,YAAAA,IAAI,CAACK,IAAL,CAAU0B,QAAV;AACD,WAHD,CAGE,OAAOxB,KAAP,EAAc;AACdP,YAAAA,IAAI,CAACO,KAAL,CAAWA,KAAX,EAAkB;AAClB;AADA;AAGD;AACF;AAZiC,OAAjB,CAAnB;;AAeA,aAAO,YAAY;AACjBN,QAAAA,YAAY,CAACS,WAAb;AACD,OAFD;AAGD,KAnBM,CAAP;AAoBD;AACD;;;;;AAxBA;;AA+BAf,EAAAA,MAAM,CAACqC,QAAP,GAAkB,SAASA,QAAT,CAAkBlC,EAAlB,EAAsB;AACtC,QAAImC,MAAM,GAAG,IAAb;;AAEA,WAAOvD,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C,UAAIkC,aAAa,GAAG,EAApB;;AAEA,eAAS/B,KAAT,CAAeF,YAAf,EAA6B;AAC3B,aAAKkC,IAAL,GAAYlC,YAAZ;AACAiC,QAAAA,aAAa,CAACE,IAAd,CAAmBnC,YAAnB;AACD;;AAED,eAASK,QAAT,GAAoB;AAClB4B,QAAAA,aAAa,CAACG,MAAd,CAAqBH,aAAa,CAACI,OAAd,CAAsB,KAAKH,IAA3B,CAArB,EAAuD,CAAvD;;AAEA,YAAID,aAAa,CAACK,MAAd,KAAyB,CAA7B,EAAgC;AAC9BvC,UAAAA,IAAI,CAACM,QAAL;AACD;AACF;;AAED2B,MAAAA,MAAM,CAAC/B,SAAP,CAAiB;AACfC,QAAAA,KAAK,EAAEA,KADQ;AAEfE,QAAAA,IAAI,EAAE,SAASA,IAAT,CAAcsB,KAAd,EAAqB;AACzB,cAAI;AACF,gBAAI,CAAC3B,IAAI,CAACwC,MAAV,EAAkB;AAChB9D,cAAAA,eAAe,CAACW,IAAhB,CAAqBS,EAAE,CAAC6B,KAAD,CAAvB,EAAgCzB,SAAhC,CAA0C;AACxCC,gBAAAA,KAAK,EAAEA,KADiC;AAExCE,gBAAAA,IAAI,EAAEL,IAAI,CAACK,IAF6B;AAGxCE,gBAAAA,KAAK,EAAEP,IAAI,CAACO,KAH4B;AAIxCD,gBAAAA,QAAQ,EAAEA;AAJ8B,eAA1C;AAMD;AACF,WATD,CASE,OAAOC,KAAP,EAAc;AACdP,YAAAA,IAAI,CAACO,KAAL,CAAWA,KAAX,EAAkB;AAClB;AADA;AAGD;AACF,SAjBc;AAkBfA,QAAAA,KAAK,EAAEP,IAAI,CAACO,KAlBG;AAmBfD,QAAAA,QAAQ,EAAEA;AAnBK,OAAjB;;AAsBA,aAAO,YAAY;AACjB4B,QAAAA,aAAa,CAACO,OAAd,CAAsB,UAAUrC,GAAV,EAAe;AACnC,iBAAOA,GAAG,CAACM,WAAJ,EAAP;AACD,SAFD;AAGAwB,QAAAA,aAAa,CAACK,MAAd,GAAuB,CAAvB;AACD,OALD;AAMD,KA5CM,CAAP;AA6CD;AACD;;;;;;;AAjDA;;AA0DA5C,EAAAA,MAAM,CAAC+C,IAAP,GAAc,SAASA,IAAT,CAAcC,YAAd,EAA4B;AACxC,QAAIC,MAAM,GAAG,IAAb;;AAEA,QAAI/D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,UAAI,OAAO4D,YAAP,KAAwB,QAAxB,IAAoCA,YAAY,IAAI,CAAxD,EAA2D;AACzD,cAAM,IAAI3D,KAAJ,CAAU,iEAAiE2D,YAA3E,CAAN;AACD;AACF;;AAED,WAAOjE,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C,UAAIC,YAAJ;AACA,UAAI4C,OAAJ;;AAEA,UAAIH,IAAI,GAAG,SAASA,IAAT,GAAgB;AACzBzC,QAAAA,YAAY,GAAG2C,MAAM,CAAC1C,SAAP,CAAiB;AAC9BG,UAAAA,IAAI,EAAEL,IAAI,CAACK,IADmB;AAE9BE,UAAAA,KAAK,EAAEP,IAAI,CAACO,KAFkB;AAG9BD,UAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5BuC,YAAAA,OAAO,GAAGC,UAAU,CAACJ,IAAD,EAAOC,YAAP,CAApB;AACD;AAL6B,SAAjB,CAAf;AAOD,OARD;;AAUAD,MAAAA,IAAI;AACJ,aAAO,YAAY;AACjBK,QAAAA,YAAY,CAACF,OAAD,CAAZ;AACA5C,QAAAA,YAAY,CAACS,WAAb;AACD,OAHD;AAID,KAnBM,CAAP;AAoBD;AACD;;;;;;;AA9BA;;AAuCAf,EAAAA,MAAM,CAACqD,SAAP,GAAmB,SAASA,SAAT,GAAqB;AACtC,QAAIC,MAAM,GAAG,IAAb;;AAEA,WAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,UAAIC,QAAQ,GAAG,KAAf;;AAEAJ,MAAAA,MAAM,CAAC/C,SAAP,CAAiB;AACfG,QAAAA,IAAI,EAAE,SAASA,IAAT,CAAciD,GAAd,EAAmB;AACvB,cAAI,CAACD,QAAL,EAAe;AACbA,YAAAA,QAAQ,GAAG,IAAX;AACAF,YAAAA,OAAO,CAACG,GAAD,CAAP;AACD;AACF,SANc;AAOf/C,QAAAA,KAAK,EAAE6C,MAPQ;AAQf9C,QAAAA,QAAQ,EAAE6C;AARK,OAAjB;AAUD,KAbM,CAAP;AAcD,GAjBD;;AAmBA,SAAOzE,eAAP;AACD,CAlZkC,EAAnC,C,CAkZK;;;AAGL,SAASa,YAAT,CAAsBD,GAAtB,EAA2B;AACzB,SAAO,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAnC,IAA2C,OAAOA,GAAG,CAACY,SAAX,KAAyB,UAA3E;AACD;;AAED,SAASV,cAAT,CAAwBF,GAAxB,EAA6B;AAC3B,SAAOA,GAAG,YAAYZ,eAAf,GAAiCY,GAAjC,GAAuCZ,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AACnF,WAAOV,GAAG,CAACY,SAAJ,CAAcF,IAAd,CAAP;AACD,GAF6C,CAA9C;AAGD;;AAED,SAASP,WAAT,CAAqB8D,OAArB,EAA8B;AAC5B,SAAO7E,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5C;AACAuD,IAAAA,OAAO,CAACC,IAAR,CAAa,UAAU7B,KAAV,EAAiB;AAC5B3B,MAAAA,IAAI,CAACK,IAAL,CAAUsB,KAAV;AACA3B,MAAAA,IAAI,CAACM,QAAL;AACD,KAHD,EAGGN,IAAI,CAACO,KAHR;AAID,GANM,CAAP;AAOD;;AAED,SAASb,SAAT,CAAmBiC,KAAnB,EAA0B;AACxB,SAAOjD,eAAe,CAACC,MAAhB,CAAuB,UAAUqB,IAAV,EAAgB;AAC5CA,IAAAA,IAAI,CAACK,IAAL,CAAUsB,KAAV;AACA3B,IAAAA,IAAI,CAACM,QAAL;AACD,GAHM,CAAP;AAID;;AAED,SAASsB,UAAT,CAAoBhD,MAApB,EAA4BmC,QAA5B,EAAsC;AACpC,MAAIyB,MAAM,GAAG,KAAb;AACA,MAAIiB,OAAJ,CAFoC,CAEvB;AACb;AACA;AACA;;AAEA,MAAIC,UAAU,GAAG,SAASA,UAAT,CAAoBpE,GAApB,EAAyB;AACxC,WAAOqE,MAAM,CAACC,cAAP,CAAsBtE,GAAtB,EAA2B,QAA3B,EAAqC;AAC1CuE,MAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,eAAOrB,MAAP;AACD;AAHyC,KAArC,CAAP;AAKD,GAND;;AAQA,WAASsB,SAAT,GAAqB;AACnB,QAAIL,OAAJ,EAAa;AACX,UAAIA,OAAO,CAAC/C,WAAZ,EAAyB;AACvB+C,QAAAA,OAAO,CAAC/C,WAAR;AACD,OAFD,MAEO;AACL,YAAI;AACF+C,UAAAA,OAAO;AACR,SAFD,CAEE,OAAOlD,KAAP,EAAc;AACd/B,UAAAA,eAAe,CAAC+B,KAAD,EAAQ;AACvB;AADe,WAAf;AAGD;AACF;;AAEDkD,MAAAA,OAAO,GAAGM,SAAV;AACD;AACF,GA/BmC,CA+BlC;;;AAGF,MAAI9D,YAAY,GAAGyD,UAAU,CAAC;AAC5BhD,IAAAA,WAAW,EAAE,SAASA,WAAT,GAAuB;AAClC,UAAI,CAAC8B,MAAL,EAAa;AACXA,QAAAA,MAAM,GAAG,IAAT,CADW,CACI;;AAEf,YAAI;AACFzB,UAAAA,QAAQ,CAACL,WAAT,IAAwBK,QAAQ,CAACL,WAAT,CAAqBT,YAArB,CAAxB;AACD,SAFD,CAEE,OAAOM,KAAP,EAAc;AACd/B,UAAAA,eAAe,CAAC+B,KAAD,EAAQ;AACvB;AADe,WAAf;AAGD,SAND,SAMU;AACRuD,UAAAA,SAAS;AACV;AACF;AACF;AAf2B,GAAD,CAA7B,CAlCoC,CAkDhC;;AAEJ,MAAI;AACF/C,IAAAA,QAAQ,CAACZ,KAAT,IAAkBY,QAAQ,CAACZ,KAAT,CAAeF,YAAf,CAAlB;AACD,GAFD,CAEE,OAAOM,KAAP,EAAc;AACd/B,IAAAA,eAAe,CAAC+B,KAAD,EAAQ;AACvB;AADe,KAAf;AAGD,GA1DmC,CA0DlC;;;AAGF,MAAIiC,MAAJ,EAAY;AACV,WAAOvC,YAAP;AACD,GA/DmC,CA+DlC;;;AAGF,MAAID,IAAI,GAAG0D,UAAU,CAAC;AACpBrD,IAAAA,IAAI,EAAE,SAASA,IAAT,CAAcsB,KAAd,EAAqB;AACzB,UAAI,CAACa,MAAD,IAAWzB,QAAQ,CAACV,IAAxB,EAA8B;AAC5B,YAAI;AACFU,UAAAA,QAAQ,CAACV,IAAT,CAAcsB,KAAd;AACD,SAFD,CAEE,OAAOpB,KAAP,EAAc;AACd/B,UAAAA,eAAe,CAAC+B,KAAD,EAAQ;AACvB;AADe,WAAf;AAGD;AACF;AACF,KAXmB;AAYpBA,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeyD,OAAf,EAAwBC,qBAAxB,EAA+C;AACpD,UAAIzB,MAAM,IAAI,CAACzB,QAAQ,CAACR,KAAxB,EAA+B;AAC7BiC,QAAAA,MAAM,GAAG,IAAT;AACAhE,QAAAA,eAAe,CAACwF,OAAD,EAAUC,qBAAqB,IAAI,KAAnC,CAAf;AACAH,QAAAA,SAAS;AACV,OAJD,MAIO;AACLtB,QAAAA,MAAM,GAAG,IAAT;;AAEA,YAAI;AACFzB,UAAAA,QAAQ,CAACR,KAAT,CAAeyD,OAAf;AACD,SAFD,CAEE,OAAOvD,MAAP,EAAe;AACfjC,UAAAA,eAAe,CAACiC,MAAD,EAAS;AACxB;AADe,WAAf;AAGD,SAND,SAMU;AACRqD,UAAAA,SAAS;AACV;AACF;AACF,KA9BmB;AA+BpBxD,IAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5B,UAAI,CAACkC,MAAL,EAAa;AACXA,QAAAA,MAAM,GAAG,IAAT;;AAEA,YAAI;AACFzB,UAAAA,QAAQ,CAACT,QAAT,IAAqBS,QAAQ,CAACT,QAAT,EAArB;AACD,SAFD,CAEE,OAAOC,KAAP,EAAc;AACd/B,UAAAA,eAAe,CAAC+B,KAAD,EAAQ;AACvB;AADe,WAAf;AAGD,SAND,SAMU;AACRuD,UAAAA,SAAS;AACV;AACF;AACF;AA7CmB,GAAD,CAArB,CAlEoC,CAgHhC;;AAEJ,MAAI;AACFL,IAAAA,OAAO,GAAG7E,MAAM,CAACoB,IAAD,CAAhB;AACD,GAFD,CAEE,OAAOO,KAAP,EAAc;AACdP,IAAAA,IAAI,CAACO,KAAL,CAAWA,KAAX,EAAkB;AAClB;AADA;AAGD;;AAED,MAAI1B,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACA,QAAI0E,OAAO,KAAKM,SAAZ,IAAyB,OAAON,OAAP,KAAmB,UAA5C,KAA2D,CAACA,OAAD,IAAY,OAAOA,OAAO,CAAC/C,WAAf,KAA+B,UAAtG,CAAJ,EAAuH;AACrH,YAAM,IAAI1B,KAAJ,CAAU,uDAAuDC,MAAM,CAACwE,OAAD,CAAvE,CAAN;AACD;AACF,GA/HmC,CA+HlC;;;AAGF,MAAIjB,MAAJ,EAAY;AACVsB,IAAAA,SAAS;AACV;;AAED,SAAO7D,YAAP;AACD;;AAED,SAASxB,YAAT,CAAsByF,MAAtB,EAA8BC,sBAA9B,EAAsD,CAAC;AACtD;;AAED,IAAItF,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACA;AACAL,EAAAA,eAAe,CAACS,gBAAhB,CAAiC,UAAUoB,KAAV,EAAiB0D,qBAAjB,EAAwC;AACvE,QAAI,OAAOG,IAAP,KAAgB,UAApB,EAAgC;AAC9B;AACAA,MAAAA,IAAI,CAACnF,MAAM,CAACsB,KAAD,CAAP,CAAJ;AACD,KAHD,MAGO,IAAI0D,qBAAJ,EAA2B;AAChC;AACA;AACAnB,MAAAA,UAAU,CAAC,YAAY;AACrB,cAAMvC,KAAN;AACD,OAFS,CAAV;AAGD,KANM,MAMA,IAAI,OAAO8D,OAAP,KAAmB,WAAvB,EAAoC;AACzC;AACA;AACAA,MAAAA,OAAO,CAAC9D,KAAR,CAAc,kCAAd,EAAkDA,KAAlD;AACD;AACF,GAfD;AAgBD;;AAED+D,MAAM,CAACC,OAAP,GAAiB7F,eAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar isPromise = require('../util/isPromise');\n/**\n * A Subscription object is returned from .subscribe(), which can be\n * unsubscribed or checked to see if the resulting subscription has closed.\n */\n\n\nvar hostReportError = swallowError;\n/**\n * Limited implementation of ESObservable, providing the limited set of behavior\n * Relay networking requires.\n *\n * Observables retain the benefit of callbacks which can be called\n * synchronously, avoiding any UI jitter, while providing a compositional API,\n * which simplifies logic and prevents mishandling of errors compared to\n * the direct use of callback functions.\n *\n * ESObservable: https://github.com/tc39/proposal-observable\n */\n\nvar RelayObservable = /*#__PURE__*/function () {\n  RelayObservable.create = function create(source) {\n    return new RelayObservable(source);\n  } // Use RelayObservable.create()\n  ;\n\n  function RelayObservable(source) {\n    if (process.env.NODE_ENV !== \"production\") {\n      // Early runtime errors for ill-formed sources.\n      if (!source || typeof source !== 'function') {\n        throw new Error('Source must be a Function: ' + String(source));\n      }\n    }\n\n    this._source = source;\n  }\n  /**\n   * When an emitted error event is not handled by an Observer, it is reported\n   * to the host environment (what the ESObservable spec refers to as\n   * \"HostReportErrors()\").\n   *\n   * The default implementation in development rethrows thrown errors, and\n   * logs emitted error events to the console, while in production does nothing\n   * (swallowing unhandled errors).\n   *\n   * Called during application initialization, this method allows\n   * application-specific handling of unhandled errors. Allowing, for example,\n   * integration with error logging or developer tools.\n   *\n   * A second parameter `isUncaughtThrownError` is true when the unhandled error\n   * was thrown within an Observer handler, and false when the unhandled error\n   * was an unhandled emitted event.\n   *\n   *  - Uncaught thrown errors typically represent avoidable errors thrown from\n   *    application code, which should be handled with a try/catch block, and\n   *    usually have useful stack traces.\n   *\n   *  - Unhandled emitted event errors typically represent unavoidable events in\n   *    application flow such as network failure, and may not have useful\n   *    stack traces.\n   */\n\n\n  RelayObservable.onUnhandledError = function onUnhandledError(callback) {\n    hostReportError = callback;\n  }\n  /**\n   * Accepts various kinds of data sources, and always returns a RelayObservable\n   * useful for accepting the result of a user-provided FetchFunction.\n   */\n  ;\n\n  RelayObservable.from = function from(obj) {\n    return isObservable(obj) ? fromObservable(obj) : isPromise(obj) ? fromPromise(obj) : fromValue(obj);\n  }\n  /**\n   * Similar to promise.catch(), observable.catch() handles error events, and\n   * provides an alternative observable to use in it's place.\n   *\n   * If the catch handler throws a new error, it will appear as an error event\n   * on the resulting Observable.\n   */\n  ;\n\n  var _proto = RelayObservable.prototype;\n\n  _proto[\"catch\"] = function _catch(fn) {\n    var _this = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription;\n\n      _this.subscribe({\n        start: function start(sub) {\n          subscription = sub;\n        },\n        next: sink.next,\n        complete: sink.complete,\n        error: function error(_error2) {\n          try {\n            fn(_error2).subscribe({\n              start: function start(sub) {\n                subscription = sub;\n              },\n              next: sink.next,\n              complete: sink.complete,\n              error: sink.error\n            });\n          } catch (error2) {\n            sink.error(error2, true\n            /* isUncaughtThrownError */\n            );\n          }\n        }\n      });\n\n      return function () {\n        return subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which first yields values from this Observable,\n   * then yields values from the next Observable. This is useful for chaining\n   * together Observables of finite length.\n   */\n  ;\n\n  _proto.concat = function concat(next) {\n    var _this2 = this;\n\n    return RelayObservable.create(function (sink) {\n      var current;\n\n      _this2.subscribe({\n        start: function start(subscription) {\n          current = subscription;\n        },\n        next: sink.next,\n        error: sink.error,\n        complete: function complete() {\n          current = next.subscribe(sink);\n        }\n      });\n\n      return function () {\n        current && current.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the provided Observer is called to perform a side-effects\n   * for all events emitted by the source.\n   *\n   * Any errors that are thrown in the side-effect Observer are unhandled, and\n   * do not affect the source Observable or its Observer.\n   *\n   * This is useful for when debugging your Observables or performing other\n   * side-effects such as logging or performance monitoring.\n   */\n  ;\n\n  _proto[\"do\"] = function _do(observer) {\n    var _this3 = this;\n\n    return RelayObservable.create(function (sink) {\n      var both = function both(action) {\n        return function () {\n          try {\n            observer[action] && observer[action].apply(observer, arguments);\n          } catch (error) {\n            hostReportError(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n\n          sink[action] && sink[action].apply(sink, arguments);\n        };\n      };\n\n      return _this3.subscribe({\n        start: both('start'),\n        next: both('next'),\n        error: both('error'),\n        complete: both('complete'),\n        unsubscribe: both('unsubscribe')\n      });\n    });\n  }\n  /**\n   * Returns a new Observable which returns the same values as this one, but\n   * modified so that the finally callback is performed after completion,\n   * whether normal or due to error or unsubscription.\n   *\n   * This is useful for cleanup such as resource finalization.\n   */\n  ;\n\n  _proto[\"finally\"] = function _finally(fn) {\n    var _this4 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this4.subscribe(sink);\n\n      return function () {\n        subscription.unsubscribe();\n        fn();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which is identical to this one, unless this\n   * Observable completes before yielding any values, in which case the new\n   * Observable will yield the values from the alternate Observable.\n   *\n   * If this Observable does yield values, the alternate is never subscribed to.\n   *\n   * This is useful for scenarios where values may come from multiple sources\n   * which should be tried in order, i.e. from a cache before a network.\n   */\n  ;\n\n  _proto.ifEmpty = function ifEmpty(alternate) {\n    var _this5 = this;\n\n    return RelayObservable.create(function (sink) {\n      var hasValue = false;\n\n      var current = _this5.subscribe({\n        next: function next(value) {\n          hasValue = true;\n          sink.next(value);\n        },\n        error: sink.error,\n        complete: function complete() {\n          if (hasValue) {\n            sink.complete();\n          } else {\n            current = alternate.subscribe(sink);\n          }\n        }\n      });\n\n      return function () {\n        current.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Observable's primary API: returns an unsubscribable Subscription to the\n   * source of this Observable.\n   *\n   * Note: A sink may be passed directly to .subscribe() as its observer,\n   * allowing for easily composing Observables.\n   */\n  ;\n\n  _proto.subscribe = function subscribe(observer) {\n    if (process.env.NODE_ENV !== \"production\") {\n      // Early runtime errors for ill-formed observers.\n      if (!observer || typeof observer !== 'object') {\n        throw new Error('Observer must be an Object with callbacks: ' + String(observer));\n      }\n    }\n\n    return _subscribe(this._source, observer);\n  }\n  /**\n   * Returns a new Observerable where each value has been transformed by\n   * the mapping function.\n   */\n  ;\n\n  _proto.map = function map(fn) {\n    var _this6 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscription = _this6.subscribe({\n        complete: sink.complete,\n        error: sink.error,\n        next: function next(value) {\n          try {\n            var mapValue = fn(value);\n            sink.next(mapValue);\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        }\n      });\n\n      return function () {\n        subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a new Observable where each value is replaced with a new Observable\n   * by the mapping function, the results of which returned as a single\n   * merged Observable.\n   */\n  ;\n\n  _proto.mergeMap = function mergeMap(fn) {\n    var _this7 = this;\n\n    return RelayObservable.create(function (sink) {\n      var subscriptions = [];\n\n      function start(subscription) {\n        this._sub = subscription;\n        subscriptions.push(subscription);\n      }\n\n      function complete() {\n        subscriptions.splice(subscriptions.indexOf(this._sub), 1);\n\n        if (subscriptions.length === 0) {\n          sink.complete();\n        }\n      }\n\n      _this7.subscribe({\n        start: start,\n        next: function next(value) {\n          try {\n            if (!sink.closed) {\n              RelayObservable.from(fn(value)).subscribe({\n                start: start,\n                next: sink.next,\n                error: sink.error,\n                complete: complete\n              });\n            }\n          } catch (error) {\n            sink.error(error, true\n            /* isUncaughtThrownError */\n            );\n          }\n        },\n        error: sink.error,\n        complete: complete\n      });\n\n      return function () {\n        subscriptions.forEach(function (sub) {\n          return sub.unsubscribe();\n        });\n        subscriptions.length = 0;\n      };\n    });\n  }\n  /**\n   * Returns a new Observable which first mirrors this Observable, then when it\n   * completes, waits for `pollInterval` milliseconds before re-subscribing to\n   * this Observable again, looping in this manner until unsubscribed.\n   *\n   * The returned Observable never completes.\n   */\n  ;\n\n  _proto.poll = function poll(pollInterval) {\n    var _this8 = this;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof pollInterval !== 'number' || pollInterval <= 0) {\n        throw new Error('RelayObservable: Expected pollInterval to be positive, got: ' + pollInterval);\n      }\n    }\n\n    return RelayObservable.create(function (sink) {\n      var subscription;\n      var timeout;\n\n      var poll = function poll() {\n        subscription = _this8.subscribe({\n          next: sink.next,\n          error: sink.error,\n          complete: function complete() {\n            timeout = setTimeout(poll, pollInterval);\n          }\n        });\n      };\n\n      poll();\n      return function () {\n        clearTimeout(timeout);\n        subscription.unsubscribe();\n      };\n    });\n  }\n  /**\n   * Returns a Promise which resolves when this Observable yields a first value\n   * or when it completes with no value.\n   *\n   * NOTE: The source Observable is *NOT* canceled when the returned Promise\n   * resolves. The Observable is always run to completion.\n   */\n  ;\n\n  _proto.toPromise = function toPromise() {\n    var _this9 = this;\n\n    return new Promise(function (resolve, reject) {\n      var resolved = false;\n\n      _this9.subscribe({\n        next: function next(val) {\n          if (!resolved) {\n            resolved = true;\n            resolve(val);\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  };\n\n  return RelayObservable;\n}(); // Use declarations to teach Flow how to check isObservable.\n\n\nfunction isObservable(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.subscribe === 'function';\n}\n\nfunction fromObservable(obj) {\n  return obj instanceof RelayObservable ? obj : RelayObservable.create(function (sink) {\n    return obj.subscribe(sink);\n  });\n}\n\nfunction fromPromise(promise) {\n  return RelayObservable.create(function (sink) {\n    // Since sink methods do not throw, the resulting Promise can be ignored.\n    promise.then(function (value) {\n      sink.next(value);\n      sink.complete();\n    }, sink.error);\n  });\n}\n\nfunction fromValue(value) {\n  return RelayObservable.create(function (sink) {\n    sink.next(value);\n    sink.complete();\n  });\n}\n\nfunction _subscribe(source, observer) {\n  var closed = false;\n  var cleanup; // Ideally we would simply describe a `get closed()` method on the Sink and\n  // Subscription objects below, however not all flow environments we expect\n  // Relay to be used within will support property getters, and many minifier\n  // tools still do not support ES5 syntax. Instead, we can use defineProperty.\n\n  var withClosed = function withClosed(obj) {\n    return Object.defineProperty(obj, 'closed', {\n      get: function get() {\n        return closed;\n      }\n    });\n  };\n\n  function doCleanup() {\n    if (cleanup) {\n      if (cleanup.unsubscribe) {\n        cleanup.unsubscribe();\n      } else {\n        try {\n          cleanup();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n\n      cleanup = undefined;\n    }\n  } // Create a Subscription.\n\n\n  var subscription = withClosed({\n    unsubscribe: function unsubscribe() {\n      if (!closed) {\n        closed = true; // Tell Observer that unsubscribe was called.\n\n        try {\n          observer.unsubscribe && observer.unsubscribe(subscription);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // Tell Observer that observation is about to begin.\n\n  try {\n    observer.start && observer.start(subscription);\n  } catch (error) {\n    hostReportError(error, true\n    /* isUncaughtThrownError */\n    );\n  } // If closed already, don't bother creating a Sink.\n\n\n  if (closed) {\n    return subscription;\n  } // Create a Sink respecting subscription state and cleanup.\n\n\n  var sink = withClosed({\n    next: function next(value) {\n      if (!closed && observer.next) {\n        try {\n          observer.next(value);\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        }\n      }\n    },\n    error: function error(_error3, isUncaughtThrownError) {\n      if (closed || !observer.error) {\n        closed = true;\n        hostReportError(_error3, isUncaughtThrownError || false);\n        doCleanup();\n      } else {\n        closed = true;\n\n        try {\n          observer.error(_error3);\n        } catch (error2) {\n          hostReportError(error2, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    },\n    complete: function complete() {\n      if (!closed) {\n        closed = true;\n\n        try {\n          observer.complete && observer.complete();\n        } catch (error) {\n          hostReportError(error, true\n          /* isUncaughtThrownError */\n          );\n        } finally {\n          doCleanup();\n        }\n      }\n    }\n  }); // If anything goes wrong during observing the source, handle the error.\n\n  try {\n    cleanup = source(sink);\n  } catch (error) {\n    sink.error(error, true\n    /* isUncaughtThrownError */\n    );\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // Early runtime errors for ill-formed returned cleanup.\n    if (cleanup !== undefined && typeof cleanup !== 'function' && (!cleanup || typeof cleanup.unsubscribe !== 'function')) {\n      throw new Error('Returned cleanup function which cannot be called: ' + String(cleanup));\n    }\n  } // If closed before the source function existed, cleanup now.\n\n\n  if (closed) {\n    doCleanup();\n  }\n\n  return subscription;\n}\n\nfunction swallowError(_error, _isUncaughtThrownError) {// do nothing.\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  // Default implementation of HostReportErrors() in development builds.\n  // Can be replaced by the host application environment.\n  RelayObservable.onUnhandledError(function (error, isUncaughtThrownError) {\n    if (typeof fail === 'function') {\n      // In test environments (Jest), fail() immediately fails the current test.\n      fail(String(error));\n    } else if (isUncaughtThrownError) {\n      // Rethrow uncaught thrown errors on the next frame to avoid breaking\n      // current logic.\n      setTimeout(function () {\n        throw error;\n      });\n    } else if (typeof console !== 'undefined') {\n      // Otherwise, log the unhandled error for visibility.\n      // eslint-disable-next-line no-console\n      console.error('RelayObservable: Unhandled Error', error);\n    }\n  });\n}\n\nmodule.exports = RelayObservable;"]},"metadata":{},"sourceType":"script"}