{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar ConnectionInterface = require('./ConnectionInterface');\n\nvar getRelayHandleKey = require('../../util/getRelayHandleKey');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('../../store/ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar CONNECTION = 'connection'; // Per-instance incrementing index used to generate unique edge IDs\n\nvar NEXT_EDGE_INDEX = '__connection_next_edge_index';\n/**\n * @public\n *\n * A default runtime handler for connection fields that appends newly fetched\n * edges onto the end of a connection, regardless of the arguments used to fetch\n * those edges.\n */\n\nfunction update(store, payload) {\n  var record = store.get(payload.dataID);\n\n  if (!record) {\n    return;\n  }\n\n  var _ConnectionInterface$ = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$.EDGES,\n      END_CURSOR = _ConnectionInterface$.END_CURSOR,\n      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,\n      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,\n      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,\n      PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE,\n      START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n  var serverConnection = record.getLinkedRecord(payload.fieldKey);\n  var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!serverConnection) {\n    record.setValue(null, payload.handleKey);\n    return;\n  } // In rare cases the handleKey field may be unset even though the client\n  // connection record exists, in this case new edges should still be merged\n  // into the existing client connection record (and the field reset to point\n  // to that record).\n\n\n  var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);\n  var clientConnectionField = record.getLinkedRecord(payload.handleKey);\n  var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);\n  var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!clientConnection) {\n    // Initial fetch with data: copy fields from the server record\n    var connection = store.create(clientConnectionID, serverConnection.getType());\n    connection.setValue(0, NEXT_EDGE_INDEX);\n    connection.copyFieldsFrom(serverConnection);\n    var serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (serverEdges) {\n      serverEdges = serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, connection, edge);\n      });\n      connection.setLinkedRecords(serverEdges, EDGES);\n    }\n\n    record.setLinkedRecord(connection, payload.handleKey);\n    clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);\n    clientPageInfo.setValue(false, HAS_NEXT_PAGE);\n    clientPageInfo.setValue(false, HAS_PREV_PAGE);\n    clientPageInfo.setValue(null, END_CURSOR);\n    clientPageInfo.setValue(null, START_CURSOR);\n\n    if (serverPageInfo) {\n      clientPageInfo.copyFieldsFrom(serverPageInfo);\n    }\n\n    connection.setLinkedRecord(clientPageInfo, PAGE_INFO);\n  } else {\n    if (clientConnectionField == null) {\n      // If the handleKey field was unset but the client connection record\n      // existed, update the field to point to the record\n      record.setLinkedRecord(clientConnection, payload.handleKey);\n    }\n\n    var _connection = clientConnection; // Subsequent fetches:\n    // - updated fields on the connection\n    // - merge prev/next edges, de-duplicating by node id\n    // - synthesize page info fields\n\n    var _serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (_serverEdges) {\n      _serverEdges = _serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, _connection, edge);\n      });\n    }\n\n    var prevEdges = _connection.getLinkedRecords(EDGES);\n\n    var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);\n\n    _connection.copyFieldsFrom(serverConnection); // Reset EDGES and PAGE_INFO fields\n\n\n    if (prevEdges) {\n      _connection.setLinkedRecords(prevEdges, EDGES);\n    }\n\n    if (prevPageInfo) {\n      _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);\n    }\n\n    var nextEdges = [];\n    var args = payload.args;\n\n    if (prevEdges && _serverEdges) {\n      if (args.after != null) {\n        // Forward pagination from the end of the connection: append edges\n        if (clientPageInfo && args.after === clientPageInfo.getValue(END_CURSOR)) {\n          var nodeIDs = new Set();\n          mergeEdges(prevEdges, nextEdges, nodeIDs);\n          mergeEdges(_serverEdges, nextEdges, nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;\n          return;\n        }\n      } else if (args.before != null) {\n        // Backward pagination from the start of the connection: prepend edges\n        if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {\n          var _nodeIDs = new Set();\n\n          mergeEdges(_serverEdges, nextEdges, _nodeIDs);\n          mergeEdges(prevEdges, nextEdges, _nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;\n          return;\n        }\n      } else {\n        // The connection was refetched from the beginning/end: replace edges\n        nextEdges = _serverEdges;\n      }\n    } else if (_serverEdges) {\n      nextEdges = _serverEdges;\n    } else {\n      nextEdges = prevEdges;\n    } // Update edges only if they were updated, the null check is\n    // for Flow (prevEdges could be null).\n\n\n    if (nextEdges != null && nextEdges !== prevEdges) {\n      _connection.setLinkedRecords(nextEdges, EDGES);\n    } // Page info should be updated even if no new edge were returned.\n\n\n    if (clientPageInfo && serverPageInfo) {\n      if (args.after == null && args.before == null) {\n        // The connection was refetched from the beginning/end: replace\n        // page_info\n        clientPageInfo.copyFieldsFrom(serverPageInfo);\n      } else if (args.before != null || args.after == null && args.last) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);\n        var startCursor = serverPageInfo.getValue(START_CURSOR);\n\n        if (typeof startCursor === 'string') {\n          clientPageInfo.setValue(startCursor, START_CURSOR);\n        }\n      } else if (args.after != null || args.before == null && args.first) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);\n        var endCursor = serverPageInfo.getValue(END_CURSOR);\n\n        if (typeof endCursor === 'string') {\n          clientPageInfo.setValue(endCursor, END_CURSOR);\n        }\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Given a record and the name of the schema field for which a connection was\n * fetched, returns the linked connection record.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * The `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   // Access fields on the connection:\n *   const edges = friends.getLinkedRecords('edges');\n * }\n * ```\n *\n * TODO: t15733312\n * Currently we haven't run into this case yet, but we need to add a `getConnections`\n * that returns an array of the connections under the same `key` regardless of the variables.\n */\n\n\nfunction getConnection(record, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  return record.getLinkedRecord(handleKey, filters);\n}\n/**\n * @public\n *\n * Inserts an edge after the given cursor, or at the end of the list if no\n * cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be appended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeAfter(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeAfter(record, newEdge, cursor) {\n  var _ConnectionInterface$2 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$2.CURSOR,\n      EDGES = _ConnectionInterface$2.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = edges.concat(newEdge);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      nextEdges.push(edge);\n\n      if (edge == null) {\n        continue;\n      }\n\n      var edgeCursor = edge.getValue(CURSOR);\n\n      if (cursor === edgeCursor) {\n        nextEdges.push(newEdge);\n        foundCursor = true;\n      }\n    }\n\n    if (!foundCursor) {\n      nextEdges.push(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Creates an edge for a connection record, given a node and edge type.\n */\n\n\nfunction createEdge(store, record, node, edgeType) {\n  var _ConnectionInterface$3 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$3.NODE; // An index-based client ID could easily conflict (unless it was\n  // auto-incrementing, but there is nowhere to the store the id)\n  // Instead, construct a client ID based on the connection ID and node ID,\n  // which will only conflict if the same node is added to the same connection\n  // twice. This is acceptable since the `insertEdge*` functions ignore\n  // duplicates.\n\n\n  var edgeID = generateClientID(record.getDataID(), node.getDataID());\n  var edge = store.get(edgeID);\n\n  if (!edge) {\n    edge = store.create(edgeID, edgeType);\n  }\n\n  edge.setLinkedRecord(node, NODE);\n  return edge;\n}\n/**\n * @public\n *\n * Inserts an edge before the given cursor, or at the beginning of the list if\n * no cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be prepended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeBefore(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeBefore(record, newEdge, cursor) {\n  var _ConnectionInterface$4 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$4.CURSOR,\n      EDGES = _ConnectionInterface$4.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = [newEdge].concat(edges);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n\n      if (edge != null) {\n        var edgeCursor = edge.getValue(CURSOR);\n\n        if (cursor === edgeCursor) {\n          nextEdges.push(newEdge);\n          foundCursor = true;\n        }\n      }\n\n      nextEdges.push(edge);\n    }\n\n    if (!foundCursor) {\n      nextEdges.unshift(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Remove any edges whose `node.id` matches the given id.\n */\n\n\nfunction deleteNode(record, nodeID) {\n  var _ConnectionInterface$5 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$5.EDGES,\n      NODE = _ConnectionInterface$5.NODE;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    return;\n  }\n\n  var nextEdges;\n\n  for (var ii = 0; ii < edges.length; ii++) {\n    var edge = edges[ii];\n    var node = edge && edge.getLinkedRecord(NODE);\n\n    if (node != null && node.getDataID() === nodeID) {\n      if (nextEdges === undefined) {\n        nextEdges = edges.slice(0, ii);\n      }\n    } else if (nextEdges !== undefined) {\n      nextEdges.push(edge);\n    }\n  }\n\n  if (nextEdges !== undefined) {\n    record.setLinkedRecords(nextEdges, EDGES);\n  }\n}\n/**\n * @internal\n *\n * Creates a copy of an edge with a unique ID based on per-connection-instance\n * incrementing edge index. This is necessary to avoid collisions between edges,\n * which can occur because (edge) client IDs are assigned deterministically\n * based on the path from the nearest node with an id.\n *\n * Example: if the first N edges of the same connection are refetched, the edges\n * from the second fetch will be assigned the same IDs as the first fetch, even\n * though the nodes they point to may be different (or the same and in different\n * order).\n */\n\n\nfunction buildConnectionEdge(store, connection, edge) {\n  if (edge == null) {\n    return edge;\n  }\n\n  var _ConnectionInterface$6 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$6.EDGES;\n\n  var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);\n  !(typeof edgeIndex === 'number') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : invariant(false) : void 0;\n  var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);\n  var connectionEdge = store.create(edgeID, edge.getType());\n  connectionEdge.copyFieldsFrom(edge);\n  connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);\n  return connectionEdge;\n}\n/**\n * @internal\n *\n * Adds the source edges to the target edges, skipping edges with\n * duplicate node ids.\n */\n\n\nfunction mergeEdges(sourceEdges, targetEdges, nodeIDs) {\n  var _ConnectionInterface$7 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$7.NODE;\n\n  for (var ii = 0; ii < sourceEdges.length; ii++) {\n    var edge = sourceEdges[ii];\n\n    if (!edge) {\n      continue;\n    }\n\n    var node = edge.getLinkedRecord(NODE);\n    var nodeID = node && node.getDataID();\n\n    if (nodeID) {\n      if (nodeIDs.has(nodeID)) {\n        continue;\n      }\n\n      nodeIDs.add(nodeID);\n    }\n\n    targetEdges.push(edge);\n  }\n}\n\nmodule.exports = {\n  buildConnectionEdge: buildConnectionEdge,\n  createEdge: createEdge,\n  deleteNode: deleteNode,\n  getConnection: getConnection,\n  insertEdgeAfter: insertEdgeAfter,\n  insertEdgeBefore: insertEdgeBefore,\n  update: update\n};","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js"],"names":["ConnectionInterface","require","getRelayHandleKey","invariant","warning","_require","generateClientID","CONNECTION","NEXT_EDGE_INDEX","update","store","payload","record","get","dataID","_ConnectionInterface$","EDGES","END_CURSOR","HAS_NEXT_PAGE","HAS_PREV_PAGE","PAGE_INFO","PAGE_INFO_TYPE","START_CURSOR","serverConnection","getLinkedRecord","fieldKey","serverPageInfo","setValue","handleKey","clientConnectionID","getDataID","clientConnectionField","clientConnection","clientPageInfo","connection","create","getType","copyFieldsFrom","serverEdges","getLinkedRecords","map","edge","buildConnectionEdge","setLinkedRecords","setLinkedRecord","_connection","_serverEdges","prevEdges","prevPageInfo","nextEdges","args","after","getValue","nodeIDs","Set","mergeEdges","process","env","NODE_ENV","before","_nodeIDs","last","startCursor","first","endCursor","getConnection","key","filters","insertEdgeAfter","newEdge","cursor","_ConnectionInterface$2","CURSOR","edges","concat","foundCursor","ii","length","push","edgeCursor","createEdge","node","edgeType","_ConnectionInterface$3","NODE","edgeID","insertEdgeBefore","_ConnectionInterface$4","unshift","deleteNode","nodeID","_ConnectionInterface$5","undefined","slice","_ConnectionInterface$6","edgeIndex","connectionEdge","sourceEdges","targetEdges","_ConnectionInterface$7","has","add","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar ConnectionInterface = require('./ConnectionInterface');\n\nvar getRelayHandleKey = require('../../util/getRelayHandleKey');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('../../store/ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar CONNECTION = 'connection'; // Per-instance incrementing index used to generate unique edge IDs\n\nvar NEXT_EDGE_INDEX = '__connection_next_edge_index';\n/**\n * @public\n *\n * A default runtime handler for connection fields that appends newly fetched\n * edges onto the end of a connection, regardless of the arguments used to fetch\n * those edges.\n */\n\nfunction update(store, payload) {\n  var record = store.get(payload.dataID);\n\n  if (!record) {\n    return;\n  }\n\n  var _ConnectionInterface$ = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$.EDGES,\n      END_CURSOR = _ConnectionInterface$.END_CURSOR,\n      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,\n      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,\n      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,\n      PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE,\n      START_CURSOR = _ConnectionInterface$.START_CURSOR;\n\n  var serverConnection = record.getLinkedRecord(payload.fieldKey);\n  var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!serverConnection) {\n    record.setValue(null, payload.handleKey);\n    return;\n  } // In rare cases the handleKey field may be unset even though the client\n  // connection record exists, in this case new edges should still be merged\n  // into the existing client connection record (and the field reset to point\n  // to that record).\n\n\n  var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);\n  var clientConnectionField = record.getLinkedRecord(payload.handleKey);\n  var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);\n  var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);\n\n  if (!clientConnection) {\n    // Initial fetch with data: copy fields from the server record\n    var connection = store.create(clientConnectionID, serverConnection.getType());\n    connection.setValue(0, NEXT_EDGE_INDEX);\n    connection.copyFieldsFrom(serverConnection);\n    var serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (serverEdges) {\n      serverEdges = serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, connection, edge);\n      });\n      connection.setLinkedRecords(serverEdges, EDGES);\n    }\n\n    record.setLinkedRecord(connection, payload.handleKey);\n    clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);\n    clientPageInfo.setValue(false, HAS_NEXT_PAGE);\n    clientPageInfo.setValue(false, HAS_PREV_PAGE);\n    clientPageInfo.setValue(null, END_CURSOR);\n    clientPageInfo.setValue(null, START_CURSOR);\n\n    if (serverPageInfo) {\n      clientPageInfo.copyFieldsFrom(serverPageInfo);\n    }\n\n    connection.setLinkedRecord(clientPageInfo, PAGE_INFO);\n  } else {\n    if (clientConnectionField == null) {\n      // If the handleKey field was unset but the client connection record\n      // existed, update the field to point to the record\n      record.setLinkedRecord(clientConnection, payload.handleKey);\n    }\n\n    var _connection = clientConnection; // Subsequent fetches:\n    // - updated fields on the connection\n    // - merge prev/next edges, de-duplicating by node id\n    // - synthesize page info fields\n\n    var _serverEdges = serverConnection.getLinkedRecords(EDGES);\n\n    if (_serverEdges) {\n      _serverEdges = _serverEdges.map(function (edge) {\n        return buildConnectionEdge(store, _connection, edge);\n      });\n    }\n\n    var prevEdges = _connection.getLinkedRecords(EDGES);\n\n    var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);\n\n    _connection.copyFieldsFrom(serverConnection); // Reset EDGES and PAGE_INFO fields\n\n\n    if (prevEdges) {\n      _connection.setLinkedRecords(prevEdges, EDGES);\n    }\n\n    if (prevPageInfo) {\n      _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);\n    }\n\n    var nextEdges = [];\n    var args = payload.args;\n\n    if (prevEdges && _serverEdges) {\n      if (args.after != null) {\n        // Forward pagination from the end of the connection: append edges\n        if (clientPageInfo && args.after === clientPageInfo.getValue(END_CURSOR)) {\n          var nodeIDs = new Set();\n          mergeEdges(prevEdges, nextEdges, nodeIDs);\n          mergeEdges(_serverEdges, nextEdges, nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : void 0;\n          return;\n        }\n      } else if (args.before != null) {\n        // Backward pagination from the start of the connection: prepend edges\n        if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {\n          var _nodeIDs = new Set();\n\n          mergeEdges(_serverEdges, nextEdges, _nodeIDs);\n          mergeEdges(prevEdges, nextEdges, _nodeIDs);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : void 0;\n          return;\n        }\n      } else {\n        // The connection was refetched from the beginning/end: replace edges\n        nextEdges = _serverEdges;\n      }\n    } else if (_serverEdges) {\n      nextEdges = _serverEdges;\n    } else {\n      nextEdges = prevEdges;\n    } // Update edges only if they were updated, the null check is\n    // for Flow (prevEdges could be null).\n\n\n    if (nextEdges != null && nextEdges !== prevEdges) {\n      _connection.setLinkedRecords(nextEdges, EDGES);\n    } // Page info should be updated even if no new edge were returned.\n\n\n    if (clientPageInfo && serverPageInfo) {\n      if (args.after == null && args.before == null) {\n        // The connection was refetched from the beginning/end: replace\n        // page_info\n        clientPageInfo.copyFieldsFrom(serverPageInfo);\n      } else if (args.before != null || args.after == null && args.last) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);\n        var startCursor = serverPageInfo.getValue(START_CURSOR);\n\n        if (typeof startCursor === 'string') {\n          clientPageInfo.setValue(startCursor, START_CURSOR);\n        }\n      } else if (args.after != null || args.before == null && args.first) {\n        clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);\n        var endCursor = serverPageInfo.getValue(END_CURSOR);\n\n        if (typeof endCursor === 'string') {\n          clientPageInfo.setValue(endCursor, END_CURSOR);\n        }\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Given a record and the name of the schema field for which a connection was\n * fetched, returns the linked connection record.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * The `friends` connection record can be accessed with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   // Access fields on the connection:\n *   const edges = friends.getLinkedRecords('edges');\n * }\n * ```\n *\n * TODO: t15733312\n * Currently we haven't run into this case yet, but we need to add a `getConnections`\n * that returns an array of the connections under the same `key` regardless of the variables.\n */\n\n\nfunction getConnection(record, key, filters) {\n  var handleKey = getRelayHandleKey(CONNECTION, key, null);\n  return record.getLinkedRecord(handleKey, filters);\n}\n/**\n * @public\n *\n * Inserts an edge after the given cursor, or at the end of the list if no\n * cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be appended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeAfter(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeAfter(record, newEdge, cursor) {\n  var _ConnectionInterface$2 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$2.CURSOR,\n      EDGES = _ConnectionInterface$2.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = edges.concat(newEdge);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n      nextEdges.push(edge);\n\n      if (edge == null) {\n        continue;\n      }\n\n      var edgeCursor = edge.getValue(CURSOR);\n\n      if (cursor === edgeCursor) {\n        nextEdges.push(newEdge);\n        foundCursor = true;\n      }\n    }\n\n    if (!foundCursor) {\n      nextEdges.push(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Creates an edge for a connection record, given a node and edge type.\n */\n\n\nfunction createEdge(store, record, node, edgeType) {\n  var _ConnectionInterface$3 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$3.NODE; // An index-based client ID could easily conflict (unless it was\n  // auto-incrementing, but there is nowhere to the store the id)\n  // Instead, construct a client ID based on the connection ID and node ID,\n  // which will only conflict if the same node is added to the same connection\n  // twice. This is acceptable since the `insertEdge*` functions ignore\n  // duplicates.\n\n\n  var edgeID = generateClientID(record.getDataID(), node.getDataID());\n  var edge = store.get(edgeID);\n\n  if (!edge) {\n    edge = store.create(edgeID, edgeType);\n  }\n\n  edge.setLinkedRecord(node, NODE);\n  return edge;\n}\n/**\n * @public\n *\n * Inserts an edge before the given cursor, or at the beginning of the list if\n * no cursor is provided.\n *\n * Example:\n *\n * Given that data has already been fetched on some user `<id>` on the `friends`\n * field:\n *\n * ```\n * fragment FriendsFragment on User {\n *   friends(first: 10) @connection(key: \"FriendsFragment_friends\") {\n *    edges {\n *      node {\n *        id\n *        }\n *      }\n *   }\n * }\n * ```\n *\n * An edge can be prepended with:\n *\n * ```\n * store => {\n *   const user = store.get('<id>');\n *   const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n *   const edge = store.create('<edge-id>', 'FriendsEdge');\n *   ConnectionHandler.insertEdgeBefore(friends, edge);\n * }\n * ```\n */\n\n\nfunction insertEdgeBefore(record, newEdge, cursor) {\n  var _ConnectionInterface$4 = ConnectionInterface.get(),\n      CURSOR = _ConnectionInterface$4.CURSOR,\n      EDGES = _ConnectionInterface$4.EDGES;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    record.setLinkedRecords([newEdge], EDGES);\n    return;\n  }\n\n  var nextEdges;\n\n  if (cursor == null) {\n    nextEdges = [newEdge].concat(edges);\n  } else {\n    nextEdges = [];\n    var foundCursor = false;\n\n    for (var ii = 0; ii < edges.length; ii++) {\n      var edge = edges[ii];\n\n      if (edge != null) {\n        var edgeCursor = edge.getValue(CURSOR);\n\n        if (cursor === edgeCursor) {\n          nextEdges.push(newEdge);\n          foundCursor = true;\n        }\n      }\n\n      nextEdges.push(edge);\n    }\n\n    if (!foundCursor) {\n      nextEdges.unshift(newEdge);\n    }\n  }\n\n  record.setLinkedRecords(nextEdges, EDGES);\n}\n/**\n * @public\n *\n * Remove any edges whose `node.id` matches the given id.\n */\n\n\nfunction deleteNode(record, nodeID) {\n  var _ConnectionInterface$5 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$5.EDGES,\n      NODE = _ConnectionInterface$5.NODE;\n\n  var edges = record.getLinkedRecords(EDGES);\n\n  if (!edges) {\n    return;\n  }\n\n  var nextEdges;\n\n  for (var ii = 0; ii < edges.length; ii++) {\n    var edge = edges[ii];\n    var node = edge && edge.getLinkedRecord(NODE);\n\n    if (node != null && node.getDataID() === nodeID) {\n      if (nextEdges === undefined) {\n        nextEdges = edges.slice(0, ii);\n      }\n    } else if (nextEdges !== undefined) {\n      nextEdges.push(edge);\n    }\n  }\n\n  if (nextEdges !== undefined) {\n    record.setLinkedRecords(nextEdges, EDGES);\n  }\n}\n/**\n * @internal\n *\n * Creates a copy of an edge with a unique ID based on per-connection-instance\n * incrementing edge index. This is necessary to avoid collisions between edges,\n * which can occur because (edge) client IDs are assigned deterministically\n * based on the path from the nearest node with an id.\n *\n * Example: if the first N edges of the same connection are refetched, the edges\n * from the second fetch will be assigned the same IDs as the first fetch, even\n * though the nodes they point to may be different (or the same and in different\n * order).\n */\n\n\nfunction buildConnectionEdge(store, connection, edge) {\n  if (edge == null) {\n    return edge;\n  }\n\n  var _ConnectionInterface$6 = ConnectionInterface.get(),\n      EDGES = _ConnectionInterface$6.EDGES;\n\n  var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);\n  !(typeof edgeIndex === 'number') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : invariant(false) : void 0;\n  var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);\n  var connectionEdge = store.create(edgeID, edge.getType());\n  connectionEdge.copyFieldsFrom(edge);\n  connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);\n  return connectionEdge;\n}\n/**\n * @internal\n *\n * Adds the source edges to the target edges, skipping edges with\n * duplicate node ids.\n */\n\n\nfunction mergeEdges(sourceEdges, targetEdges, nodeIDs) {\n  var _ConnectionInterface$7 = ConnectionInterface.get(),\n      NODE = _ConnectionInterface$7.NODE;\n\n  for (var ii = 0; ii < sourceEdges.length; ii++) {\n    var edge = sourceEdges[ii];\n\n    if (!edge) {\n      continue;\n    }\n\n    var node = edge.getLinkedRecord(NODE);\n    var nodeID = node && node.getDataID();\n\n    if (nodeID) {\n      if (nodeIDs.has(nodeID)) {\n        continue;\n      }\n\n      nodeIDs.add(nodeID);\n    }\n\n    targetEdges.push(edge);\n  }\n}\n\nmodule.exports = {\n  buildConnectionEdge: buildConnectionEdge,\n  createEdge: createEdge,\n  deleteNode: deleteNode,\n  getConnection: getConnection,\n  insertEdgeAfter: insertEdgeAfter,\n  insertEdgeBefore: insertEdgeBefore,\n  update: update\n};"]},"metadata":{},"sourceType":"script"}