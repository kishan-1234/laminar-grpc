{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _require = require('../util/RelayConcreteNode'),\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar _require2 = require('./RelayStoreUtils'),\n    FRAGMENTS_KEY = _require2.FRAGMENTS_KEY,\n    FRAGMENT_OWNER_KEY = _require2.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require2.FRAGMENT_PROP_NAME_KEY,\n    ID_KEY = _require2.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require2.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require2.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require2.ROOT_ID,\n    getArgumentValues = _require2.getArgumentValues,\n    getStorageKey = _require2.getStorageKey,\n    getModuleComponentKey = _require2.getModuleComponentKey;\n\nvar _require3 = require('./TypeID'),\n    generateTypeID = _require3.generateTypeID;\n\nfunction read(recordSource, selector) {\n  var reader = new RelayReader(recordSource, selector);\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector) {\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = {};\n    this._selector = selector;\n    this._variables = selector.variables;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null && RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n      var _recordType = RelayModernRecord.getType(record);\n\n      var typeID = generateTypeID(_recordType);\n\n      var typeRecord = this._recordSource.get(typeID);\n\n      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      seenRecords: this._seenRecords,\n      selector: this._selector\n    };\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords[dataID] = record;\n\n    if (record == null) {\n      if (record === undefined) {\n        this._isMissingData = true;\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    this._traverseSelections(node.selections, record, data);\n\n    return data;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data) {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = this._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            this._traverseSelections(selection.selections, record, data);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only read data if the type exactly matches\n              var typeName = RelayModernRecord.getType(record);\n\n              if (typeName != null && typeName === selection.type) {\n                this._traverseSelections(selection.selections, record, data);\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              // Similar to the logic in read(): data is only expected to be present\n              // if the record is known to conform to the interface. If we don't know\n              // whether the type conforms or not, that constitutes missing data.\n              // store flags to reset after reading\n              var parentIsMissingData = this._isMissingData;\n              var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n\n              var _typeName = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;\n\n              this._traverseSelections(selection.selections, record, data);\n\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n              if (implementsInterface === false) {\n                // Type known to not implement the interface, no data expected\n                this._isMissingData = parentIsMissingData;\n              } else if (implementsInterface == null) {\n                // Don't know if the type implements the interface or not\n                this._isMissingData = true;\n              }\n            } else {\n              // legacy behavior for abstract refinements: always read even\n              // if the type doesn't conform and don't reset isMissingData\n              this._traverseSelections(selection.selections, record, data);\n            }\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          var isMissingData = this._isMissingData;\n\n          this._traverseSelections(selection.selections, record, data);\n\n          this._isMissingData = isMissingData;\n          break;\n\n        case STREAM:\n          this._traverseSelections(selection.selections, record, data);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias;\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._isMissingData = true;\n    }\n\n    data[applicationName] = value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    data[applicationName] = this._traverse(field, linkedID, prevData);\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var _this = this;\n\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this._isMissingData = true;\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: null\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n\n    if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n      data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n    }\n  };\n\n  _proto._createInlineDataFragmentPointer = function _createInlineDataFragmentPointer(inlineDataFragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n\n    this._traverseSelections(inlineDataFragmentSpread.selections, record, inlineData); // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[inlineDataFragmentSpread.name] = inlineData;\n  };\n\n  return RelayReader;\n}();\n\nmodule.exports = {\n  read: read\n};","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/RelayReader.js"],"names":["RelayFeatureFlags","require","RelayModernRecord","invariant","_require","CLIENT_EXTENSION","CONDITION","DEFER","FRAGMENT_SPREAD","INLINE_DATA_FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","MODULE_IMPORT","SCALAR_FIELD","STREAM","_require2","FRAGMENTS_KEY","FRAGMENT_OWNER_KEY","FRAGMENT_PROP_NAME_KEY","ID_KEY","IS_WITHIN_UNMATCHED_TYPE_REFINEMENT","MODULE_COMPONENT_KEY","ROOT_ID","getArgumentValues","getStorageKey","getModuleComponentKey","_require3","generateTypeID","read","recordSource","selector","reader","RelayReader","_isMissingData","_isWithinUnmatchedTypeRefinement","_owner","owner","_recordSource","_seenRecords","_selector","_variables","variables","_proto","prototype","_this$_selector","node","dataID","isWithinUnmatchedTypeRefinement","abstractKey","record","get","isDataExpectedToBePresent","recordType","getType","type","ENABLE_PRECISE_TYPE_REFINEMENT","_recordType","typeID","typeRecord","implementsInterface","getValue","data","_traverse","isMissingData","seenRecords","prevData","undefined","_traverseSelections","selections","_getVariableValue","name","hasOwnProperty","process","env","NODE_ENV","i","length","selection","kind","_readScalar","plural","_readPluralLink","_readLink","conditionValue","condition","passingValue","typeName","parentIsMissingData","parentIsWithinUnmatchedTypeRefinement","_typeName","_createFragmentPointer","_readModuleImport","_createInlineDataFragmentPointer","field","_field$alias","applicationName","alias","storageKey","value","_field$alias2","linkedID","getLinkedRecordID","getDataID","_this","_field$alias3","linkedIDs","getLinkedRecordIDs","Array","isArray","linkedArray","forEach","nextIndex","prevItem","moduleImport","componentKey","documentName","component","fragmentName","args","fragmentPropName","fragmentSpread","fragmentPointers","inlineDataFragmentSpread","inlineData","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _require = require('../util/RelayConcreteNode'),\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar _require2 = require('./RelayStoreUtils'),\n    FRAGMENTS_KEY = _require2.FRAGMENTS_KEY,\n    FRAGMENT_OWNER_KEY = _require2.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require2.FRAGMENT_PROP_NAME_KEY,\n    ID_KEY = _require2.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require2.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require2.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require2.ROOT_ID,\n    getArgumentValues = _require2.getArgumentValues,\n    getStorageKey = _require2.getStorageKey,\n    getModuleComponentKey = _require2.getModuleComponentKey;\n\nvar _require3 = require('./TypeID'),\n    generateTypeID = _require3.generateTypeID;\n\nfunction read(recordSource, selector) {\n  var reader = new RelayReader(recordSource, selector);\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector) {\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = {};\n    this._selector = selector;\n    this._variables = selector.variables;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null && RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n      var _recordType = RelayModernRecord.getType(record);\n\n      var typeID = generateTypeID(_recordType);\n\n      var typeRecord = this._recordSource.get(typeID);\n\n      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      seenRecords: this._seenRecords,\n      selector: this._selector\n    };\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords[dataID] = record;\n\n    if (record == null) {\n      if (record === undefined) {\n        this._isMissingData = true;\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    this._traverseSelections(node.selections, record, data);\n\n    return data;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data) {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = this._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            this._traverseSelections(selection.selections, record, data);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only read data if the type exactly matches\n              var typeName = RelayModernRecord.getType(record);\n\n              if (typeName != null && typeName === selection.type) {\n                this._traverseSelections(selection.selections, record, data);\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              // Similar to the logic in read(): data is only expected to be present\n              // if the record is known to conform to the interface. If we don't know\n              // whether the type conforms or not, that constitutes missing data.\n              // store flags to reset after reading\n              var parentIsMissingData = this._isMissingData;\n              var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n\n              var _typeName = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;\n\n              this._traverseSelections(selection.selections, record, data);\n\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n              if (implementsInterface === false) {\n                // Type known to not implement the interface, no data expected\n                this._isMissingData = parentIsMissingData;\n              } else if (implementsInterface == null) {\n                // Don't know if the type implements the interface or not\n                this._isMissingData = true;\n              }\n            } else {\n              // legacy behavior for abstract refinements: always read even\n              // if the type doesn't conform and don't reset isMissingData\n              this._traverseSelections(selection.selections, record, data);\n            }\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          var isMissingData = this._isMissingData;\n\n          this._traverseSelections(selection.selections, record, data);\n\n          this._isMissingData = isMissingData;\n          break;\n\n        case STREAM:\n          this._traverseSelections(selection.selections, record, data);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias;\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._isMissingData = true;\n    }\n\n    data[applicationName] = value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    data[applicationName] = this._traverse(field, linkedID, prevData);\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var _this = this;\n\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this._isMissingData = true;\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: null\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n\n    if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n      data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n    }\n  };\n\n  _proto._createInlineDataFragmentPointer = function _createInlineDataFragmentPointer(inlineDataFragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n\n    this._traverseSelections(inlineDataFragmentSpread.selections, record, inlineData); // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[inlineDataFragmentSpread.name] = inlineData;\n  };\n\n  return RelayReader;\n}();\n\nmodule.exports = {\n  read: read\n};"]},"metadata":{},"sourceType":"script"}