{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar React = require('react');\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar buildReactRelayContainer = require('./buildReactRelayContainer');\n\nvar getRootVariablesForFragments = require('./getRootVariablesForFragments');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ReactRelayContainerUtils'),\n    getContainerName = _require.getContainerName;\n\nvar _require2 = require('./RelayContext'),\n    assertRelayContext = _require2.assertRelayContext;\n\nvar _require3 = require('relay-runtime'),\n    Observable = _require3.Observable,\n    createFragmentSpecResolver = _require3.createFragmentSpecResolver,\n    createOperationDescriptor = _require3.createOperationDescriptor,\n    getDataIDsFromObject = _require3.getDataIDsFromObject,\n    getRequest = _require3.getRequest,\n    getSelector = _require3.getSelector,\n    getVariablesFromObject = _require3.getVariablesFromObject,\n    isScalarAndEqual = _require3.isScalarAndEqual;\n/**\n * Composes a React component class, returning a new class that intercepts\n * props, resolving them with the provided fragments and subscribing for\n * updates.\n */\n\n\nfunction createContainerWithFragments(Component, fragments, taggedNode) {\n  var _class, _temp;\n\n  var containerName = getContainerName(Component);\n  return _temp = _class = /*#__PURE__*/function (_React$Component) {\n    (0, _inheritsLoose2[\"default\"])(_class, _React$Component);\n\n    function _class(props) {\n      var _this;\n\n      _this = _React$Component.call(this, props) || this;\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleFragmentDataUpdate\", function () {\n        var resolverFromThisUpdate = _this.state.resolver;\n\n        _this.setState(function (updatedState) {\n          return (// If this event belongs to the current data source, update.\n            // Otherwise we should ignore it.\n            resolverFromThisUpdate === updatedState.resolver ? {\n              data: updatedState.resolver.resolve()\n            } : null\n          );\n        });\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_refetch\", function (refetchVariables, renderVariables, observerOrCallback, options) {\n        if (_this._isUnmounted) {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayRefetchContainer: Unexpected call of `refetch` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to refetch the data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `refetch`.', containerName) : void 0;\n          return {\n            dispose: function dispose() {}\n          };\n        }\n\n        var _assertRelayContext = assertRelayContext(_this.props.__relayContext),\n            environment = _assertRelayContext.environment;\n\n        var rootVariables = getRootVariablesForFragments(fragments, _this.props);\n        var fetchVariables = typeof refetchVariables === 'function' ? refetchVariables(_this._getFragmentVariables()) : refetchVariables;\n        fetchVariables = _objectSpread({}, rootVariables, {}, fetchVariables);\n        var fragmentVariables = renderVariables ? _objectSpread({}, fetchVariables, {}, renderVariables) : fetchVariables;\n        var cacheConfig = options ? {\n          force: !!options.force\n        } : undefined;\n\n        if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {\n          cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;\n        }\n\n        var observer = typeof observerOrCallback === 'function' ? {\n          // callback is not exectued on complete or unsubscribe\n          // for backward compatibility\n          next: observerOrCallback,\n          error: observerOrCallback\n        } : observerOrCallback || {};\n        var query = getRequest(taggedNode);\n        var operation = createOperationDescriptor(query, fetchVariables); // TODO: T26288752 find a better way\n\n        /* eslint-disable lint/react-state-props-mutation */\n\n        _this.state.localVariables = fetchVariables;\n        /* eslint-enable lint/react-state-props-mutation */\n        // Cancel any previously running refetch.\n\n        _this._refetchSubscription && _this._refetchSubscription.unsubscribe(); // Declare refetchSubscription before assigning it in .start(), since\n        // synchronous completion may call callbacks .subscribe() returns.\n\n        var refetchSubscription;\n\n        var storeSnapshot = _this._getQueryFetcher().lookupInStore(environment, operation, options === null || options === void 0 ? void 0 : options.fetchPolicy);\n\n        if (storeSnapshot != null) {\n          _this.state.resolver.setVariables(fragmentVariables, operation.request.node);\n\n          _this.setState(function (latestState) {\n            return {\n              data: latestState.resolver.resolve(),\n              contextForChildren: {\n                environment: _this.props.__relayContext.environment\n              }\n            };\n          }, function () {\n            observer.next && observer.next();\n            observer.complete && observer.complete();\n          });\n\n          return {\n            dispose: function dispose() {}\n          };\n        }\n\n        _this._getQueryFetcher().execute({\n          environment: environment,\n          operation: operation,\n          cacheConfig: cacheConfig,\n          // TODO (T26430099): Cleanup old references\n          preservePreviousReferences: true\n        }).mergeMap(function (response) {\n          _this.state.resolver.setVariables(fragmentVariables, operation.request.node);\n\n          return Observable.create(function (sink) {\n            return _this.setState(function (latestState) {\n              return {\n                data: latestState.resolver.resolve(),\n                contextForChildren: {\n                  environment: _this.props.__relayContext.environment\n                }\n              };\n            }, function () {\n              sink.next();\n              sink.complete();\n            });\n          });\n        })[\"finally\"](function () {\n          // Finalizing a refetch should only clear this._refetchSubscription\n          // if the finizing subscription is the most recent call.\n          if (_this._refetchSubscription === refetchSubscription) {\n            _this._refetchSubscription = null;\n          }\n        }).subscribe(_objectSpread({}, observer, {\n          start: function start(subscription) {\n            _this._refetchSubscription = refetchSubscription = subscription;\n            observer.start && observer.start(subscription);\n          }\n        }));\n\n        return {\n          dispose: function dispose() {\n            refetchSubscription && refetchSubscription.unsubscribe();\n          }\n        };\n      });\n      var relayContext = assertRelayContext(props.__relayContext);\n      _this._refetchSubscription = null; // Do not provide a subscription/callback here.\n      // It is possible for this render to be interrupted or aborted,\n      // In which case the subscription would cause a leak.\n      // We will add the subscription in componentDidMount().\n\n      var resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props);\n      _this.state = {\n        data: resolver.resolve(),\n        localVariables: null,\n        prevProps: props,\n        prevPropsContext: relayContext,\n        contextForChildren: relayContext,\n        relayProp: getRelayProp(relayContext.environment, _this._refetch),\n        resolver: resolver\n      };\n      _this._isUnmounted = false;\n      return _this;\n    }\n\n    var _proto = _class.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      this._subscribeToNewResolver();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n      if (this.state.resolver !== prevState.resolver) {\n        prevState.resolver.dispose();\n        this._queryFetcher && this._queryFetcher.dispose();\n        this._refetchSubscription && this._refetchSubscription.unsubscribe();\n\n        this._subscribeToNewResolver();\n      }\n    }\n    /**\n     * When new props are received, read data for the new props and add it to\n     * state. Props may be the same in which case previous data can be reused.\n     */\n    ;\n\n    _class.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      // Any props change could impact the query, so we mirror props in state.\n      // This is an unusual pattern, but necessary for this container usecase.\n      var prevProps = prevState.prevProps;\n      var relayContext = assertRelayContext(nextProps.__relayContext);\n      var prevIDs = getDataIDsFromObject(fragments, prevProps);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var prevRootVariables = getRootVariablesForFragments(fragments, prevProps);\n      var nextRootVariables = getRootVariablesForFragments(fragments, nextProps);\n      var resolver = prevState.resolver; // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n\n      if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {\n        // Do not provide a subscription/callback here.\n        // It is possible for this render to be interrupted or aborted,\n        // In which case the subscription would cause a leak.\n        // We will add the subscription in componentDidUpdate().\n        resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps);\n        return {\n          data: resolver.resolve(),\n          localVariables: null,\n          prevProps: nextProps,\n          prevPropsContext: relayContext,\n          contextForChildren: relayContext,\n          relayProp: getRelayProp(relayContext.environment, prevState.relayProp.refetch),\n          resolver: resolver\n        };\n      } else if (!prevState.localVariables) {\n        resolver.setProps(nextProps);\n      }\n\n      var data = resolver.resolve();\n\n      if (data !== prevState.data) {\n        return {\n          data: data,\n          prevProps: nextProps\n        };\n      }\n\n      return null;\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this._isUnmounted = true;\n      this.state.resolver.dispose();\n      this._queryFetcher && this._queryFetcher.dispose();\n      this._refetchSubscription && this._refetchSubscription.unsubscribe();\n    };\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {\n        return true;\n      } // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n\n\n      var keys = Object.keys(nextProps);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var _key = keys[ii];\n\n        if (_key === '__relayContext') {\n          if (this.state.prevPropsContext.environment !== nextState.prevPropsContext.environment) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(_key) && !isScalarAndEqual(nextProps[_key], this.props[_key])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    _proto._subscribeToNewResolver = function _subscribeToNewResolver() {\n      var _this$state = this.state,\n          data = _this$state.data,\n          resolver = _this$state.resolver; // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n\n      resolver.setCallback(this._handleFragmentDataUpdate); // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n\n      var maybeNewData = resolver.resolve();\n\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    }\n    /**\n     * Render new data for the existing props/context.\n     */\n    ;\n\n    _proto._getFragmentVariables = function _getFragmentVariables() {\n      return getVariablesFromObject(fragments, this.props);\n    };\n\n    _proto._getQueryFetcher = function _getQueryFetcher() {\n      if (!this._queryFetcher) {\n        this._queryFetcher = new ReactRelayQueryFetcher();\n      }\n\n      return this._queryFetcher;\n    };\n\n    _proto.render = function render() {\n      var _this$props = this.props,\n          componentRef = _this$props.componentRef,\n          __relayContext = _this$props.__relayContext,\n          props = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props, [\"componentRef\", \"__relayContext\"]);\n      var _this$state2 = this.state,\n          relayProp = _this$state2.relayProp,\n          contextForChildren = _this$state2.contextForChildren;\n      return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n        value: contextForChildren\n      }, /*#__PURE__*/React.createElement(Component, (0, _extends2[\"default\"])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: relayProp\n      })));\n    };\n\n    return _class;\n  }(React.Component), (0, _defineProperty2[\"default\"])(_class, \"displayName\", containerName), _temp;\n}\n\nfunction getRelayProp(environment, refetch) {\n  return {\n    environment: environment,\n    refetch: refetch\n  };\n}\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\n\n\nfunction createContainer(Component, fragmentSpec, taggedNode) {\n  return buildReactRelayContainer(Component, fragmentSpec, function (ComponentClass, fragments) {\n    return createContainerWithFragments(ComponentClass, fragments, taggedNode);\n  });\n}\n\nmodule.exports = {\n  createContainer: createContainer\n};","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/react-relay/lib/ReactRelayRefetchContainer.js"],"names":["_interopRequireDefault","require","_extends2","_objectWithoutPropertiesLoose2","_assertThisInitialized2","_inheritsLoose2","_defineProperty2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","React","ReactRelayContext","ReactRelayQueryFetcher","areEqual","buildReactRelayContainer","getRootVariablesForFragments","warning","_require","getContainerName","_require2","assertRelayContext","_require3","Observable","createFragmentSpecResolver","createOperationDescriptor","getDataIDsFromObject","getRequest","getSelector","getVariablesFromObject","isScalarAndEqual","createContainerWithFragments","Component","fragments","taggedNode","_class","_temp","containerName","_React$Component","props","_this","call","resolverFromThisUpdate","state","resolver","setState","updatedState","data","resolve","refetchVariables","renderVariables","observerOrCallback","options","_isUnmounted","process","env","NODE_ENV","dispose","_assertRelayContext","__relayContext","environment","rootVariables","fetchVariables","_getFragmentVariables","fragmentVariables","cacheConfig","force","undefined","metadata","observer","next","error","query","operation","localVariables","_refetchSubscription","unsubscribe","refetchSubscription","storeSnapshot","_getQueryFetcher","lookupInStore","fetchPolicy","setVariables","request","node","latestState","contextForChildren","complete","execute","preservePreviousReferences","mergeMap","response","create","sink","subscribe","start","subscription","relayContext","prevProps","prevPropsContext","relayProp","getRelayProp","_refetch","_proto","prototype","componentDidMount","_subscribeToNewResolver","componentDidUpdate","prevState","_queryFetcher","getDerivedStateFromProps","nextProps","prevIDs","nextIDs","prevRootVariables","nextRootVariables","refetch","setProps","componentWillUnmount","shouldComponentUpdate","nextState","ii","_key","hasOwnProperty","_this$state","setCallback","_handleFragmentDataUpdate","maybeNewData","render","_this$props","componentRef","_this$state2","createElement","Provider","value","ref","relay","createContainer","fragmentSpec","ComponentClass","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar React = require('react');\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar buildReactRelayContainer = require('./buildReactRelayContainer');\n\nvar getRootVariablesForFragments = require('./getRootVariablesForFragments');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ReactRelayContainerUtils'),\n    getContainerName = _require.getContainerName;\n\nvar _require2 = require('./RelayContext'),\n    assertRelayContext = _require2.assertRelayContext;\n\nvar _require3 = require('relay-runtime'),\n    Observable = _require3.Observable,\n    createFragmentSpecResolver = _require3.createFragmentSpecResolver,\n    createOperationDescriptor = _require3.createOperationDescriptor,\n    getDataIDsFromObject = _require3.getDataIDsFromObject,\n    getRequest = _require3.getRequest,\n    getSelector = _require3.getSelector,\n    getVariablesFromObject = _require3.getVariablesFromObject,\n    isScalarAndEqual = _require3.isScalarAndEqual;\n\n/**\n * Composes a React component class, returning a new class that intercepts\n * props, resolving them with the provided fragments and subscribing for\n * updates.\n */\nfunction createContainerWithFragments(Component, fragments, taggedNode) {\n  var _class, _temp;\n\n  var containerName = getContainerName(Component);\n  return _temp = _class = /*#__PURE__*/function (_React$Component) {\n    (0, _inheritsLoose2[\"default\"])(_class, _React$Component);\n\n    function _class(props) {\n      var _this;\n\n      _this = _React$Component.call(this, props) || this;\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleFragmentDataUpdate\", function () {\n        var resolverFromThisUpdate = _this.state.resolver;\n\n        _this.setState(function (updatedState) {\n          return (// If this event belongs to the current data source, update.\n            // Otherwise we should ignore it.\n            resolverFromThisUpdate === updatedState.resolver ? {\n              data: updatedState.resolver.resolve()\n            } : null\n          );\n        });\n      });\n      (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_refetch\", function (refetchVariables, renderVariables, observerOrCallback, options) {\n        if (_this._isUnmounted) {\n          process.env.NODE_ENV !== \"production\" ? warning(false, 'ReactRelayRefetchContainer: Unexpected call of `refetch` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to refetch the data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `refetch`.', containerName) : void 0;\n          return {\n            dispose: function dispose() {}\n          };\n        }\n\n        var _assertRelayContext = assertRelayContext(_this.props.__relayContext),\n            environment = _assertRelayContext.environment;\n\n        var rootVariables = getRootVariablesForFragments(fragments, _this.props);\n        var fetchVariables = typeof refetchVariables === 'function' ? refetchVariables(_this._getFragmentVariables()) : refetchVariables;\n        fetchVariables = _objectSpread({}, rootVariables, {}, fetchVariables);\n        var fragmentVariables = renderVariables ? _objectSpread({}, fetchVariables, {}, renderVariables) : fetchVariables;\n        var cacheConfig = options ? {\n          force: !!options.force\n        } : undefined;\n\n        if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {\n          cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;\n        }\n\n        var observer = typeof observerOrCallback === 'function' ? {\n          // callback is not exectued on complete or unsubscribe\n          // for backward compatibility\n          next: observerOrCallback,\n          error: observerOrCallback\n        } : observerOrCallback || {};\n        var query = getRequest(taggedNode);\n        var operation = createOperationDescriptor(query, fetchVariables); // TODO: T26288752 find a better way\n\n        /* eslint-disable lint/react-state-props-mutation */\n\n        _this.state.localVariables = fetchVariables;\n        /* eslint-enable lint/react-state-props-mutation */\n        // Cancel any previously running refetch.\n\n        _this._refetchSubscription && _this._refetchSubscription.unsubscribe(); // Declare refetchSubscription before assigning it in .start(), since\n        // synchronous completion may call callbacks .subscribe() returns.\n\n        var refetchSubscription;\n\n        var storeSnapshot = _this._getQueryFetcher().lookupInStore(environment, operation, options === null || options === void 0 ? void 0 : options.fetchPolicy);\n\n        if (storeSnapshot != null) {\n          _this.state.resolver.setVariables(fragmentVariables, operation.request.node);\n\n          _this.setState(function (latestState) {\n            return {\n              data: latestState.resolver.resolve(),\n              contextForChildren: {\n                environment: _this.props.__relayContext.environment\n              }\n            };\n          }, function () {\n            observer.next && observer.next();\n            observer.complete && observer.complete();\n          });\n\n          return {\n            dispose: function dispose() {}\n          };\n        }\n\n        _this._getQueryFetcher().execute({\n          environment: environment,\n          operation: operation,\n          cacheConfig: cacheConfig,\n          // TODO (T26430099): Cleanup old references\n          preservePreviousReferences: true\n        }).mergeMap(function (response) {\n          _this.state.resolver.setVariables(fragmentVariables, operation.request.node);\n\n          return Observable.create(function (sink) {\n            return _this.setState(function (latestState) {\n              return {\n                data: latestState.resolver.resolve(),\n                contextForChildren: {\n                  environment: _this.props.__relayContext.environment\n                }\n              };\n            }, function () {\n              sink.next();\n              sink.complete();\n            });\n          });\n        })[\"finally\"](function () {\n          // Finalizing a refetch should only clear this._refetchSubscription\n          // if the finizing subscription is the most recent call.\n          if (_this._refetchSubscription === refetchSubscription) {\n            _this._refetchSubscription = null;\n          }\n        }).subscribe(_objectSpread({}, observer, {\n          start: function start(subscription) {\n            _this._refetchSubscription = refetchSubscription = subscription;\n            observer.start && observer.start(subscription);\n          }\n        }));\n\n        return {\n          dispose: function dispose() {\n            refetchSubscription && refetchSubscription.unsubscribe();\n          }\n        };\n      });\n      var relayContext = assertRelayContext(props.__relayContext);\n      _this._refetchSubscription = null; // Do not provide a subscription/callback here.\n      // It is possible for this render to be interrupted or aborted,\n      // In which case the subscription would cause a leak.\n      // We will add the subscription in componentDidMount().\n\n      var resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props);\n      _this.state = {\n        data: resolver.resolve(),\n        localVariables: null,\n        prevProps: props,\n        prevPropsContext: relayContext,\n        contextForChildren: relayContext,\n        relayProp: getRelayProp(relayContext.environment, _this._refetch),\n        resolver: resolver\n      };\n      _this._isUnmounted = false;\n      return _this;\n    }\n\n    var _proto = _class.prototype;\n\n    _proto.componentDidMount = function componentDidMount() {\n      this._subscribeToNewResolver();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n      // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n      if (this.state.resolver !== prevState.resolver) {\n        prevState.resolver.dispose();\n        this._queryFetcher && this._queryFetcher.dispose();\n        this._refetchSubscription && this._refetchSubscription.unsubscribe();\n\n        this._subscribeToNewResolver();\n      }\n    }\n    /**\n     * When new props are received, read data for the new props and add it to\n     * state. Props may be the same in which case previous data can be reused.\n     */\n    ;\n\n    _class.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      // Any props change could impact the query, so we mirror props in state.\n      // This is an unusual pattern, but necessary for this container usecase.\n      var prevProps = prevState.prevProps;\n      var relayContext = assertRelayContext(nextProps.__relayContext);\n      var prevIDs = getDataIDsFromObject(fragments, prevProps);\n      var nextIDs = getDataIDsFromObject(fragments, nextProps);\n      var prevRootVariables = getRootVariablesForFragments(fragments, prevProps);\n      var nextRootVariables = getRootVariablesForFragments(fragments, nextProps);\n      var resolver = prevState.resolver; // If the environment has changed or props point to new records then\n      // previously fetched data and any pending fetches no longer apply:\n      // - Existing references are on the old environment.\n      // - Existing references are based on old variables.\n      // - Pending fetches are for the previous records.\n\n      if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {\n        // Do not provide a subscription/callback here.\n        // It is possible for this render to be interrupted or aborted,\n        // In which case the subscription would cause a leak.\n        // We will add the subscription in componentDidUpdate().\n        resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps);\n        return {\n          data: resolver.resolve(),\n          localVariables: null,\n          prevProps: nextProps,\n          prevPropsContext: relayContext,\n          contextForChildren: relayContext,\n          relayProp: getRelayProp(relayContext.environment, prevState.relayProp.refetch),\n          resolver: resolver\n        };\n      } else if (!prevState.localVariables) {\n        resolver.setProps(nextProps);\n      }\n\n      var data = resolver.resolve();\n\n      if (data !== prevState.data) {\n        return {\n          data: data,\n          prevProps: nextProps\n        };\n      }\n\n      return null;\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this._isUnmounted = true;\n      this.state.resolver.dispose();\n      this._queryFetcher && this._queryFetcher.dispose();\n      this._refetchSubscription && this._refetchSubscription.unsubscribe();\n    };\n\n    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n      // Short-circuit if any Relay-related data has changed\n      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {\n        return true;\n      } // Otherwise, for convenience short-circuit if all non-Relay props\n      // are scalar and equal\n\n\n      var keys = Object.keys(nextProps);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var _key = keys[ii];\n\n        if (_key === '__relayContext') {\n          if (this.state.prevPropsContext.environment !== nextState.prevPropsContext.environment) {\n            return true;\n          }\n        } else {\n          if (!fragments.hasOwnProperty(_key) && !isScalarAndEqual(nextProps[_key], this.props[_key])) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    _proto._subscribeToNewResolver = function _subscribeToNewResolver() {\n      var _this$state = this.state,\n          data = _this$state.data,\n          resolver = _this$state.resolver; // Event listeners are only safe to add during the commit phase,\n      // So they won't leak if render is interrupted or errors.\n\n      resolver.setCallback(this._handleFragmentDataUpdate); // External values could change between render and commit.\n      // Check for this case, even though it requires an extra store read.\n\n      var maybeNewData = resolver.resolve();\n\n      if (data !== maybeNewData) {\n        this.setState({\n          data: maybeNewData\n        });\n      }\n    }\n    /**\n     * Render new data for the existing props/context.\n     */\n    ;\n\n    _proto._getFragmentVariables = function _getFragmentVariables() {\n      return getVariablesFromObject(fragments, this.props);\n    };\n\n    _proto._getQueryFetcher = function _getQueryFetcher() {\n      if (!this._queryFetcher) {\n        this._queryFetcher = new ReactRelayQueryFetcher();\n      }\n\n      return this._queryFetcher;\n    };\n\n    _proto.render = function render() {\n      var _this$props = this.props,\n          componentRef = _this$props.componentRef,\n          __relayContext = _this$props.__relayContext,\n          props = (0, _objectWithoutPropertiesLoose2[\"default\"])(_this$props, [\"componentRef\", \"__relayContext\"]);\n      var _this$state2 = this.state,\n          relayProp = _this$state2.relayProp,\n          contextForChildren = _this$state2.contextForChildren;\n      return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n        value: contextForChildren\n      }, /*#__PURE__*/React.createElement(Component, (0, _extends2[\"default\"])({}, props, this.state.data, {\n        ref: componentRef,\n        relay: relayProp\n      })));\n    };\n\n    return _class;\n  }(React.Component), (0, _defineProperty2[\"default\"])(_class, \"displayName\", containerName), _temp;\n}\n\nfunction getRelayProp(environment, refetch) {\n  return {\n    environment: environment,\n    refetch: refetch\n  };\n}\n/**\n * Wrap the basic `createContainer()` function with logic to adapt to the\n * `context.relay.environment` in which it is rendered. Specifically, the\n * extraction of the environment-specific version of fragments in the\n * `fragmentSpec` is memoized once per environment, rather than once per\n * instance of the container constructed/rendered.\n */\n\n\nfunction createContainer(Component, fragmentSpec, taggedNode) {\n  return buildReactRelayContainer(Component, fragmentSpec, function (ComponentClass, fragments) {\n    return createContainerWithFragments(ComponentClass, fragments, taggedNode);\n  });\n}\n\nmodule.exports = {\n  createContainer: createContainer\n};"]},"metadata":{},"sourceType":"script"}