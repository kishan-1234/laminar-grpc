{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar stableCopy = require('../util/stableCopy');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require2.createNormalizationSelector;\n\nvar _require3 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require3.ROOT_TYPE,\n    TYPENAME_KEY = _require3.TYPENAME_KEY,\n    getStorageKey = _require3.getStorageKey;\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(_ref) {\n    var _this = this;\n\n    var operation = _ref.operation,\n        operationExecutions = _ref.operationExecutions,\n        operationLoader = _ref.operationLoader,\n        optimisticConfig = _ref.optimisticConfig,\n        publishQueue = _ref.publishQueue,\n        scheduler = _ref.scheduler,\n        sink = _ref.sink,\n        source = _ref.source,\n        store = _ref.store,\n        updater = _ref.updater,\n        operationTracker = _ref.operationTracker,\n        treatMissingFieldsAsNull = _ref.treatMissingFieldsAsNull,\n        getDataID = _ref.getDataID,\n        isClientPayload = _ref.isClientPayload;\n    this._getDataID = getDataID;\n    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._publishQueue = publishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._store = store;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        return _this._start(id, subscription);\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater, false);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._publishQueue.revertUpdate(update);\n      });\n\n      this._publishQueue.run();\n    }\n\n    this._incrementalResults.clear();\n\n    this._completeOperationTracker();\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      _this4._handleNext(response);\n\n      _this4._maybeCompleteSubscriptionOperationTracking();\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    var results = [];\n    responses.forEach(function (response) {\n      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {\n        // Skip extensions-only payloads\n        return;\n      } else if (response.data == null) {\n        // Error if any other payload in the batch is missing data, regardless of whether\n        // it had `errors` or not.\n        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;\n        var messages = errors ? errors.map(function (_ref2) {\n          var message = _ref2.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        }; // In V8, Error objects keep the closure scope chain alive until the\n        // err.stack property is accessed.\n\n        error.stack;\n        throw error;\n      } else {\n        var responseWithData = response;\n        results.push(responseWithData);\n      }\n    });\n    return results;\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    var responses = Array.isArray(response) ? response : [response];\n\n    var responsesWithData = this._handleErrorResponse(responses);\n\n    if (responsesWithData.length === 0) {\n      // no results with data, nothing to process\n      // this can occur with extensions-only payloads\n      var isFinal = responses.some(function (x) {\n        var _x$extensions;\n\n        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;\n      });\n\n      if (isFinal) {\n        this._state = 'loading_final';\n\n        this._updateActiveState();\n\n        this._incrementalPayloadsPending = false;\n      }\n\n      this._sink.next(response);\n\n      return;\n    } // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1]; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at-most one non-incremental payload\n    //  * followed zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // w the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n\n    if (nonIncrementalResponses.length > 0) {\n      var payloadFollowups = this._processResponses(nonIncrementalResponses); // Please note, that we're passing `this._operation` to the publish\n      // queue here, which will later passed to the store (via notify)\n      // to indicate that this is an operation that cause the store to update\n\n\n      var updatedOwners = this._publishQueue.run(this._operation);\n\n      this._updateOperationTracker(updatedOwners);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses); // For the incremental case, we're only handling follow-up responses\n      // for already initiated operation (and we're not passing it to\n      // the run(...) call)\n\n\n      var _updatedOwners = this._publishQueue.run();\n\n      this._updateOperationTracker(_updatedOwners);\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        getDataID: this._getDataID,\n        path: [],\n        treatMissingFieldsAsNull: treatMissingFieldsAsNull\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          moduleImportPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._publishQueue.applyUpdate(update);\n    });\n\n    this._publishQueue.run();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.moduleImportPayloads && payload.moduleImportPayloads.length) {\n      var moduleImportPayloads = payload.moduleImportPayloads;\n      var operationLoader = this._operationLoader;\n      !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n\n      var _iterator = _createForOfIteratorHelper(moduleImportPayloads),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var moduleImportPayload = _step.value;\n          var operation = operationLoader.get(moduleImportPayload.operationReference);\n\n          if (operation == null) {\n            this._processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload);\n          } else {\n            var moduleImportOptimisitcUpdates = this._processOptimisticModuleImport(operation, moduleImportPayload);\n\n            optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisitcUpdates));\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  };\n\n  _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImportPayload, operation) {\n    var selector = createNormalizationSelector(operation, moduleImportPayload.dataID, moduleImportPayload.variables);\n    return normalizeResponse({\n      data: moduleImportPayload.data\n    }, selector, moduleImportPayload.typeName, {\n      getDataID: this._getDataID,\n      path: moduleImportPayload.path,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(operation, moduleImportPayload) {\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload) {\n    var _this7 = this;\n\n    operationLoader.load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisitcUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisitcUpdates.forEach(function (update) {\n        return _this7._publishQueue.applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'RelayModernQueryExecutor: Unexpected ModuleImport optimisitc ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisitcUpdates));\n\n        _this7._publishQueue.run();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        return _this8._publishQueue.revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        getDataID: _this8._getDataID,\n        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,\n        path: []\n      });\n\n      _this8._publishQueue.commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          moduleImportPayloads = payload.moduleImportPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (moduleImportPayloads && moduleImportPayloads.length !== 0) {\n        var operationLoader = _this9._operationLoader;\n        !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n        moduleImportPayloads.forEach(function (moduleImportPayload) {\n          _this9._processModuleImportPayload(moduleImportPayload, operationLoader);\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            var updatedOwners = _this9._publishQueue.run();\n\n            _this9._updateOperationTracker(updatedOwners);\n\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    var isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n\n    if (!isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processModuleImportPayload = function _processModuleImportPayload(moduleImportPayload, operationLoader) {\n    var _this10 = this;\n\n    var syncOperation = operationLoader.get(moduleImportPayload.operationReference);\n\n    if (syncOperation != null) {\n      // If the operation module is available synchronously, normalize the\n      // data synchronously.\n      this._handleModuleImportPayload(moduleImportPayload, syncOperation);\n\n      this._maybeCompleteSubscriptionOperationTracking();\n    } else {\n      // Otherwise load the operation module and schedule a task to normalize\n      // the data when the module is available.\n      var _id3 = this._nextSubscriptionId++;\n\n      this._pendingModulePayloadsCount++;\n\n      var decrementPendingCount = function decrementPendingCount() {\n        _this10._pendingModulePayloadsCount--;\n\n        _this10._maybeCompleteSubscriptionOperationTracking();\n      }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n      // errors thrown by the load function, which is user-defined. Guard\n      // against that with Observable.from(new Promise(<work>)).\n\n\n      RelayObservable.from(new Promise(function (resolve, reject) {\n        operationLoader.load(moduleImportPayload.operationReference).then(resolve, reject);\n      })).map(function (operation) {\n        if (operation != null) {\n          _this10._schedule(function () {\n            _this10._handleModuleImportPayload(moduleImportPayload, operation);\n          });\n        }\n      }).subscribe({\n        complete: function complete() {\n          _this10._complete(_id3);\n\n          decrementPendingCount();\n        },\n        error: function error(_error4) {\n          _this10._error(_error4);\n\n          decrementPendingCount();\n        },\n        start: function start(subscription) {\n          return _this10._start(_id3, subscription);\n        }\n      });\n    }\n  };\n\n  _proto._handleModuleImportPayload = function _handleModuleImportPayload(moduleImportPayload, operation) {\n    var relayPayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    this._publishQueue.commitPayload(this._operation, relayPayload);\n\n    var updatedOwners = this._publishQueue.run();\n\n    this._updateOperationTracker(updatedOwners);\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _relayPayload$fieldPa; // Update the label => path => placeholder map\n\n\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      var payloadFollowups = this._processIncrementalResponses(pendingResponses);\n\n      var updatedOwners = this._publishQueue.run();\n\n      this._updateOperationTracker(updatedOwners);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this11 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this11._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this11._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var parentID = placeholder.selector.dataID;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull\n    });\n\n    this._publishQueue.commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._publishQueue.commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = // https://github.com/prettier/prettier/issues/6403\n    // prettier-ignore\n    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (this._operationTracker != null && updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    if (this._operationTracker != null) {\n      this._operationTracker.complete(this._operation.request);\n    }\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return _objectSpread({}, relayPayload, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/RelayModernQueryExecutor.js"],"names":["_interopRequireDefault","require","_defineProperty2","_toConsumableArray2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","F","s","n","done","value","e","_e","f","TypeError","it","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","RelayError","RelayModernRecord","RelayObservable","RelayRecordSource","RelayResponseNormalizer","invariant","stableCopy","warning","_require","generateClientID","_require2","createNormalizationSelector","_require3","ROOT_TYPE","TYPENAME_KEY","getStorageKey","execute","config","Executor","_ref","_this","operation","operationExecutions","operationLoader","optimisticConfig","publishQueue","scheduler","sink","store","updater","operationTracker","treatMissingFieldsAsNull","getDataID","isClientPayload","_getDataID","_treatMissingFieldsAsNull","_incrementalPayloadsPending","_incrementalResults","Map","_nextSubscriptionId","_operation","_operationExecutions","_operationLoader","_operationTracker","_operationUpdateEpochs","_optimisticUpdates","_pendingModulePayloadsCount","_publishQueue","_scheduler","_sink","_source","_state","_store","_subscriptions","_updater","_isClientPayload","id","subscribe","complete","_complete","error","_error2","_error","response","_next","start","subscription","_start","_processOptimisticResponse","data","_proto","cancel","_this2","request","identifier","size","sub","unsubscribe","clear","optimisticUpdates","update","revertUpdate","run","_completeOperationTracker","_updateActiveState","activeState","process","env","NODE_ENV","set","_schedule","task","_this3","_id2","create","cancellationToken","schedule","_error3","_id","_this4","_handleNext","_maybeCompleteSubscriptionOperationTracking","_handleErrorResponse","responses","_this5","results","extensions","hasOwnProperty","errors","messages","map","_ref2","message","join","node","params","variables","stack","responseWithData","_handleOptimisticResponses","_response$extensions","some","responsePart","_responsePart$extensi","isOptimistic","responsesWithData","isFinal","x","_x$extensions","is_final","_partitionGraphQLResp","partitionGraphQLResponses","nonIncrementalResponses","incrementalResponses","payloadFollowups","_processResponses","updatedOwners","_updateOperationTracker","_processPayloadFollowups","_payloadFollowups","_processIncrementalResponses","_updatedOwners","_this6","payload","normalizeResponse","root","path","validateOptimisticResponsePayload","_processOptimisticFollowups","fieldPayloads","incrementalPlaceholders","moduleImportPayloads","applyUpdate","_iterator","_step","moduleImportPayload","get","operationReference","_processAsyncOptimisticModuleImport","moduleImportOptimisitcUpdates","_processOptimisticModuleImport","_normalizeModuleImport","selector","dataID","typeName","modulePayload","_this7","load","then","_this$_optimisticUpda","_this8","payloadPart","relayPayload","commitPayload","payloads","_this9","_processModuleImportPayload","incrementalPlaceholder","_processIncrementalPlaceholder","relayPayloads","placeholder","kind","_processDeferResponse","label","isSubscriptionOperation","operationKind","_this10","syncOperation","_handleModuleImportPayload","_id3","decrementPendingCount","Promise","resolve","reject","_error4","_relayPayload$fieldPa","pathKey","String","resultForLabel","resultForPath","pendingResponses","parentID","parentRecord","parentPayloads","fieldPayload","fieldID","fieldKey","nextParentRecord","nextParentPayloads","previousParentEntry","record","handlePayloads","dedupePayload","stableStringify","values","_this11","incrementalResponse","indexOf","_pathKey","_resultForPath","_placeholder","_processStreamResponse","parentEntry","_response$extensions2","handleFieldsRelayPayload","field","selections","plural","_this$_normalizeStrea","_normalizeStreamItem","itemID","itemIndex","prevIDs","storageKey","currentParentRecord","currentItems","getLinkedRecords","currentItem","index","nextItems","setLinkedRecords","normalizationPath","_field$alias","_field$concreteType","_this$_getDataID","responseKey","alias","getLinkedRecordIDs","finalPathEntry","parseInt","concreteType","clone","nextIDs","setLinkedRecordIDs","concat","Set","options","_response$extensions3","normalize","_JSON$stringify","JSON","stringify","module","exports"],"mappings":"AAAA;;;;;;;;;;AAUA;AACA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEA,IAAIC,gBAAgB,GAAGF,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAA7C;;AAEA,IAAIE,mBAAmB,GAAGH,sBAAsB,CAACC,OAAO,CAAC,0CAAD,CAAR,CAAhD;;AAEA,SAASG,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;AAAoD,QAAIC,cAAJ,EAAoBI,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,aAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,KAAjG,CAAV;AAA8GP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAErV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAE,SAAC,GAAGtB,gBAAgB,CAAC,SAAD,CAApB,EAAiCgB,MAAjC,EAAyCM,GAAzC,EAA8CF,MAAM,CAACE,GAAD,CAApD;AAA6D,OAApH;AAAwH,KAArI,MAA2I,IAAIhB,MAAM,CAACiB,yBAAX,EAAsC;AAAEjB,MAAAA,MAAM,CAACkB,gBAAP,CAAwBR,MAAxB,EAAgCV,MAAM,CAACiB,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACmB,cAAP,CAAsBT,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB;;AAEviB,SAASU,0BAAT,CAAoCC,CAApC,EAAuC;AAAE,MAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCD,CAAC,CAACC,MAAM,CAACC,QAAR,CAAD,IAAsB,IAA3D,EAAiE;AAAE,QAAIC,KAAK,CAACC,OAAN,CAAcJ,CAAd,MAAqBA,CAAC,GAAGK,2BAA2B,CAACL,CAAD,CAApD,CAAJ,EAA8D;AAAE,UAAIV,CAAC,GAAG,CAAR;;AAAW,UAAIgB,CAAC,GAAG,SAASA,CAAT,GAAa,CAAE,CAAvB;;AAAyB,aAAO;AAAEC,QAAAA,CAAC,EAAED,CAAL;AAAQE,QAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,cAAIlB,CAAC,IAAIU,CAAC,CAACR,MAAX,EAAmB,OAAO;AAAEiB,YAAAA,IAAI,EAAE;AAAR,WAAP;AAAuB,iBAAO;AAAEA,YAAAA,IAAI,EAAE,KAAR;AAAeC,YAAAA,KAAK,EAAEV,CAAC,CAACV,CAAC,EAAF;AAAvB,WAAP;AAAwC,SAA5G;AAA8GqB,QAAAA,CAAC,EAAE,SAASA,CAAT,CAAWC,EAAX,EAAe;AAAE,gBAAMA,EAAN;AAAW,SAA7I;AAA+IC,QAAAA,CAAC,EAAEP;AAAlJ,OAAP;AAA+J;;AAAC,UAAM,IAAIQ,SAAJ,CAAc,uIAAd,CAAN;AAA+J;;AAAC,MAAIC,EAAJ;AAAA,MAAQC,gBAAgB,GAAG,IAA3B;AAAA,MAAiCC,MAAM,GAAG,KAA1C;AAAA,MAAiDC,GAAjD;AAAsD,SAAO;AAAEX,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAEQ,MAAAA,EAAE,GAAGf,CAAC,CAACC,MAAM,CAACC,QAAR,CAAD,EAAL;AAA4B,KAAhD;AAAkDM,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,UAAIW,IAAI,GAAGJ,EAAE,CAACK,IAAH,EAAX;AAAsBJ,MAAAA,gBAAgB,GAAGG,IAAI,CAACV,IAAxB;AAA8B,aAAOU,IAAP;AAAc,KAAtI;AAAwIR,IAAAA,CAAC,EAAE,SAASA,CAAT,CAAWU,GAAX,EAAgB;AAAEJ,MAAAA,MAAM,GAAG,IAAT;AAAeC,MAAAA,GAAG,GAAGG,GAAN;AAAY,KAAxL;AAA0LR,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,UAAI;AAAE,YAAI,CAACG,gBAAD,IAAqBD,EAAE,CAAC,QAAD,CAAF,IAAgB,IAAzC,EAA+CA,EAAE,CAAC,QAAD,CAAF;AAAiB,OAAtE,SAA+E;AAAE,YAAIE,MAAJ,EAAY,MAAMC,GAAN;AAAY;AAAE;AAAvT,GAAP;AAAmU;;AAEz4B,SAASb,2BAAT,CAAqCL,CAArC,EAAwCsB,MAAxC,EAAgD;AAAE,MAAI,CAACtB,CAAL,EAAQ;AAAQ,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOuB,iBAAiB,CAACvB,CAAD,EAAIsB,MAAJ,CAAxB;AAAqC,MAAId,CAAC,GAAG7B,MAAM,CAAC6C,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+B1B,CAA/B,EAAkC2B,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;AAAwD,MAAInB,CAAC,KAAK,QAAN,IAAkBR,CAAC,CAAC4B,WAAxB,EAAqCpB,CAAC,GAAGR,CAAC,CAAC4B,WAAF,CAAcC,IAAlB;AAAwB,MAAIrB,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOL,KAAK,CAAC2B,IAAN,CAAWtB,CAAX,CAAP;AAAsB,MAAIA,CAAC,KAAK,WAAN,IAAqB,2CAA2CuB,IAA3C,CAAgDvB,CAAhD,CAAzB,EAA6E,OAAOe,iBAAiB,CAACvB,CAAD,EAAIsB,MAAJ,CAAxB;AAAsC;;AAEha,SAASC,iBAAT,CAA2BS,GAA3B,EAAgCC,GAAhC,EAAqC;AAAE,MAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGD,GAAG,CAACxC,MAA7B,EAAqCyC,GAAG,GAAGD,GAAG,CAACxC,MAAV;;AAAkB,OAAK,IAAIF,CAAC,GAAG,CAAR,EAAW4C,IAAI,GAAG,IAAI/B,KAAJ,CAAU8B,GAAV,CAAvB,EAAuC3C,CAAC,GAAG2C,GAA3C,EAAgD3C,CAAC,EAAjD,EAAqD;AAAE4C,IAAAA,IAAI,CAAC5C,CAAD,CAAJ,GAAU0C,GAAG,CAAC1C,CAAD,CAAb;AAAmB;;AAAC,SAAO4C,IAAP;AAAc;;AAEvL,IAAIC,UAAU,GAAG/D,OAAO,CAAC,oBAAD,CAAxB;;AAEA,IAAIgE,iBAAiB,GAAGhE,OAAO,CAAC,qBAAD,CAA/B;;AAEA,IAAIiE,eAAe,GAAGjE,OAAO,CAAC,4BAAD,CAA7B;;AAEA,IAAIkE,iBAAiB,GAAGlE,OAAO,CAAC,qBAAD,CAA/B;;AAEA,IAAImE,uBAAuB,GAAGnE,OAAO,CAAC,2BAAD,CAArC;;AAEA,IAAIoE,SAAS,GAAGpE,OAAO,CAAC,oBAAD,CAAvB;;AAEA,IAAIqE,UAAU,GAAGrE,OAAO,CAAC,oBAAD,CAAxB;;AAEA,IAAIsE,OAAO,GAAGtE,OAAO,CAAC,kBAAD,CAArB;;AAEA,IAAIuE,QAAQ,GAAGvE,OAAO,CAAC,YAAD,CAAtB;AAAA,IACIwE,gBAAgB,GAAGD,QAAQ,CAACC,gBADhC;;AAGA,IAAIC,SAAS,GAAGzE,OAAO,CAAC,uBAAD,CAAvB;AAAA,IACI0E,2BAA2B,GAAGD,SAAS,CAACC,2BAD5C;;AAGA,IAAIC,SAAS,GAAG3E,OAAO,CAAC,mBAAD,CAAvB;AAAA,IACI4E,SAAS,GAAGD,SAAS,CAACC,SAD1B;AAAA,IAEIC,YAAY,GAAGF,SAAS,CAACE,YAF7B;AAAA,IAGIC,aAAa,GAAGH,SAAS,CAACG,aAH9B;;AAKA,SAASC,OAAT,CAAiBC,MAAjB,EAAyB;AACvB,SAAO,IAAIC,QAAJ,CAAaD,MAAb,CAAP;AACD;AACD;;;;;;;AAOA,IAAIC,QAAQ,GAAG,aAAa,YAAY;AACtC,WAASA,QAAT,CAAkBC,IAAlB,EAAwB;AACtB,QAAIC,KAAK,GAAG,IAAZ;;AAEA,QAAIC,SAAS,GAAGF,IAAI,CAACE,SAArB;AAAA,QACIC,mBAAmB,GAAGH,IAAI,CAACG,mBAD/B;AAAA,QAEIC,eAAe,GAAGJ,IAAI,CAACI,eAF3B;AAAA,QAGIC,gBAAgB,GAAGL,IAAI,CAACK,gBAH5B;AAAA,QAIIC,YAAY,GAAGN,IAAI,CAACM,YAJxB;AAAA,QAKIC,SAAS,GAAGP,IAAI,CAACO,SALrB;AAAA,QAMIC,IAAI,GAAGR,IAAI,CAACQ,IANhB;AAAA,QAOIrE,MAAM,GAAG6D,IAAI,CAAC7D,MAPlB;AAAA,QAQIsE,KAAK,GAAGT,IAAI,CAACS,KARjB;AAAA,QASIC,OAAO,GAAGV,IAAI,CAACU,OATnB;AAAA,QAUIC,gBAAgB,GAAGX,IAAI,CAACW,gBAV5B;AAAA,QAWIC,wBAAwB,GAAGZ,IAAI,CAACY,wBAXpC;AAAA,QAYIC,SAAS,GAAGb,IAAI,CAACa,SAZrB;AAAA,QAaIC,eAAe,GAAGd,IAAI,CAACc,eAb3B;AAcA,SAAKC,UAAL,GAAkBF,SAAlB;AACA,SAAKG,yBAAL,GAAiCJ,wBAAjC;AACA,SAAKK,2BAAL,GAAmC,KAAnC;AACA,SAAKC,mBAAL,GAA2B,IAAIC,GAAJ,EAA3B;AACA,SAAKC,mBAAL,GAA2B,CAA3B;AACA,SAAKC,UAAL,GAAkBnB,SAAlB;AACA,SAAKoB,oBAAL,GAA4BnB,mBAA5B;AACA,SAAKoB,gBAAL,GAAwBnB,eAAxB;AACA,SAAKoB,iBAAL,GAAyBb,gBAAzB;AACA,SAAKc,sBAAL,GAA8B,IAAIN,GAAJ,EAA9B;AACA,SAAKO,kBAAL,GAA0B,IAA1B;AACA,SAAKC,2BAAL,GAAmC,CAAnC;AACA,SAAKC,aAAL,GAAqBtB,YAArB;AACA,SAAKuB,UAAL,GAAkBtB,SAAlB;AACA,SAAKuB,KAAL,GAAatB,IAAb;AACA,SAAKuB,OAAL,GAAe,IAAIZ,GAAJ,EAAf;AACA,SAAKa,MAAL,GAAc,SAAd;AACA,SAAKC,MAAL,GAAcxB,KAAd;AACA,SAAKyB,cAAL,GAAsB,IAAIf,GAAJ,EAAtB;AACA,SAAKgB,QAAL,GAAgBzB,OAAhB;AACA,SAAK0B,gBAAL,GAAwBtB,eAAe,KAAK,IAA5C;AACA,QAAIuB,EAAE,GAAG,KAAKjB,mBAAL,EAAT;AACAjF,IAAAA,MAAM,CAACmG,SAAP,CAAiB;AACfC,MAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5B,eAAOtC,KAAK,CAACuC,SAAN,CAAgBH,EAAhB,CAAP;AACD,OAHc;AAIfI,MAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,OAAf,EAAwB;AAC7B,eAAOzC,KAAK,CAAC0C,MAAN,CAAaD,OAAb,CAAP;AACD,OANc;AAOf5E,MAAAA,IAAI,EAAE,SAASA,IAAT,CAAc8E,QAAd,EAAwB;AAC5B,YAAI;AACF3C,UAAAA,KAAK,CAAC4C,KAAN,CAAYR,EAAZ,EAAgBO,QAAhB;AACD,SAFD,CAEE,OAAOH,KAAP,EAAc;AACdjC,UAAAA,IAAI,CAACiC,KAAL,CAAWA,KAAX;AACD;AACF,OAbc;AAcfK,MAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,YAAf,EAA6B;AAClC,eAAO9C,KAAK,CAAC+C,MAAN,CAAaX,EAAb,EAAiBU,YAAjB,CAAP;AACD;AAhBc,KAAjB;;AAmBA,QAAI1C,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,WAAK4C,0BAAL,CAAgC5C,gBAAgB,CAACuC,QAAjB,IAA6B,IAA7B,GAAoC;AAClEM,QAAAA,IAAI,EAAE7C,gBAAgB,CAACuC;AAD2C,OAApC,GAE5B,IAFJ,EAEUvC,gBAAgB,CAACK,OAF3B,EAEoC,KAFpC;AAGD;AACF,GAhEqC,CAgEpC;;;AAGF,MAAIyC,MAAM,GAAGpD,QAAQ,CAAC7B,SAAtB;;AAEAiF,EAAAA,MAAM,CAACC,MAAP,GAAgB,SAASA,MAAT,GAAkB;AAChC,QAAIC,MAAM,GAAG,IAAb;;AAEA,QAAI,KAAKrB,MAAL,KAAgB,WAApB,EAAiC;AAC/B;AACD;;AAED,SAAKA,MAAL,GAAc,WAAd;;AAEA,SAAKV,oBAAL,CAA0B,QAA1B,EAAoC,KAAKD,UAAL,CAAgBiC,OAAhB,CAAwBC,UAA5D;;AAEA,QAAI,KAAKrB,cAAL,CAAoBsB,IAApB,KAA6B,CAAjC,EAAoC;AAClC,WAAKtB,cAAL,CAAoB9F,OAApB,CAA4B,UAAUqH,GAAV,EAAe;AACzC,eAAOA,GAAG,CAACC,WAAJ,EAAP;AACD,OAFD;;AAIA,WAAKxB,cAAL,CAAoByB,KAApB;AACD;;AAED,QAAIC,iBAAiB,GAAG,KAAKlC,kBAA7B;;AAEA,QAAIkC,iBAAiB,KAAK,IAA1B,EAAgC;AAC9B,WAAKlC,kBAAL,GAA0B,IAA1B;AACAkC,MAAAA,iBAAiB,CAACxH,OAAlB,CAA0B,UAAUyH,MAAV,EAAkB;AAC1C,eAAOR,MAAM,CAACzB,aAAP,CAAqBkC,YAArB,CAAkCD,MAAlC,CAAP;AACD,OAFD;;AAIA,WAAKjC,aAAL,CAAmBmC,GAAnB;AACD;;AAED,SAAK7C,mBAAL,CAAyByC,KAAzB;;AAEA,SAAKK,yBAAL;AACD,GAjCD;;AAmCAb,EAAAA,MAAM,CAACc,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;AACxD,QAAIC,WAAJ;;AAEA,YAAQ,KAAKlC,MAAb;AACE,WAAK,SAAL;AACE;AACEkC,UAAAA,WAAW,GAAG,QAAd;AACA;AACD;;AAEH,WAAK,qBAAL;AACE;AACEA,UAAAA,WAAW,GAAG,QAAd;AACA;AACD;;AAEH,WAAK,WAAL;AACE;AACEA,UAAAA,WAAW,GAAG,UAAd;AACA;AACD;;AAEH,WAAK,eAAL;AACE;AACEA,UAAAA,WAAW,GAAG,KAAKvC,2BAAL,GAAmC,CAAnC,GAAuC,QAAvC,GAAkD,UAAhE;AACA;AACD;;AAEH;AACE,aAAKK,MAAL;AACA,SAAC,KAAD,GAASmC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,mDAAR,CAAjD,GAAgHA,SAAS,CAAC,KAAD,CAAlI,GAA4I,KAAK,CAAjJ;AA3BJ;;AA8BA,SAAKoC,oBAAL,CAA0BgD,GAA1B,CAA8B,KAAKjD,UAAL,CAAgBiC,OAAhB,CAAwBC,UAAtD,EAAkEW,WAAlE;AACD,GAlCD;;AAoCAf,EAAAA,MAAM,CAACoB,SAAP,GAAmB,SAASA,SAAT,CAAmBC,IAAnB,EAAyB;AAC1C,QAAIC,MAAM,GAAG,IAAb;;AAEA,QAAIlE,SAAS,GAAG,KAAKsB,UAArB;;AAEA,QAAItB,SAAS,IAAI,IAAjB,EAAuB;AACrB,UAAImE,IAAI,GAAG,KAAKtD,mBAAL,EAAX;;AAEArC,MAAAA,eAAe,CAAC4F,MAAhB,CAAuB,UAAUnE,IAAV,EAAgB;AACrC,YAAIoE,iBAAiB,GAAGrE,SAAS,CAACsE,QAAV,CAAmB,YAAY;AACrD,cAAI;AACFL,YAAAA,IAAI;AACJhE,YAAAA,IAAI,CAAC+B,QAAL;AACD,WAHD,CAGE,OAAOE,KAAP,EAAc;AACdjC,YAAAA,IAAI,CAACiC,KAAL,CAAWA,KAAX;AACD;AACF,SAPuB,CAAxB;AAQA,eAAO,YAAY;AACjB,iBAAOlC,SAAS,CAAC6C,MAAV,CAAiBwB,iBAAjB,CAAP;AACD,SAFD;AAGD,OAZD,EAYGtC,SAZH,CAYa;AACXC,QAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5B,iBAAOkC,MAAM,CAACjC,SAAP,CAAiBkC,IAAjB,CAAP;AACD,SAHU;AAIXjC,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAeqC,OAAf,EAAwB;AAC7B,iBAAOL,MAAM,CAAC9B,MAAP,CAAcmC,OAAd,CAAP;AACD,SANU;AAOXhC,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,YAAf,EAA6B;AAClC,iBAAO0B,MAAM,CAACzB,MAAP,CAAc0B,IAAd,EAAoB3B,YAApB,CAAP;AACD;AATU,OAZb;AAuBD,KA1BD,MA0BO;AACLyB,MAAAA,IAAI;AACL;AACF,GAlCD;;AAoCArB,EAAAA,MAAM,CAACX,SAAP,GAAmB,SAASA,SAAT,CAAmBH,EAAnB,EAAuB;AACxC,SAAKH,cAAL,CAAoB,QAApB,EAA8BG,EAA9B;;AAEA,QAAI,KAAKH,cAAL,CAAoBsB,IAApB,KAA6B,CAAjC,EAAoC;AAClC,WAAKJ,MAAL;;AAEA,WAAKtB,KAAL,CAAWS,QAAX;AACD;AACF,GARD;;AAUAY,EAAAA,MAAM,CAACR,MAAP,GAAgB,SAASA,MAAT,CAAgBF,KAAhB,EAAuB;AACrC,SAAKW,MAAL;;AAEA,SAAKtB,KAAL,CAAWW,KAAX,CAAiBA,KAAjB;AACD,GAJD;;AAMAU,EAAAA,MAAM,CAACH,MAAP,GAAgB,SAASA,MAAT,CAAgBX,EAAhB,EAAoBU,YAApB,EAAkC;AAChD,SAAKb,cAAL,CAAoBoC,GAApB,CAAwBjC,EAAxB,EAA4BU,YAA5B;;AAEA,SAAKkB,kBAAL;AACD,GAJD,CAIE;AAJF;;AAOAd,EAAAA,MAAM,CAACN,KAAP,GAAe,SAASA,KAAT,CAAekC,GAAf,EAAoBnC,QAApB,EAA8B;AAC3C,QAAIoC,MAAM,GAAG,IAAb;;AAEA,SAAKT,SAAL,CAAe,YAAY;AACzBS,MAAAA,MAAM,CAACC,WAAP,CAAmBrC,QAAnB;;AAEAoC,MAAAA,MAAM,CAACE,2CAAP;AACD,KAJD;AAKD,GARD;;AAUA/B,EAAAA,MAAM,CAACgC,oBAAP,GAA8B,SAASA,oBAAT,CAA8BC,SAA9B,EAAyC;AACrE,QAAIC,MAAM,GAAG,IAAb;;AAEA,QAAIC,OAAO,GAAG,EAAd;AACAF,IAAAA,SAAS,CAAChJ,OAAV,CAAkB,UAAUwG,QAAV,EAAoB;AACpC,UAAIA,QAAQ,CAACM,IAAT,KAAkB,IAAlB,IAA0BN,QAAQ,CAAC2C,UAAT,IAAuB,IAAjD,IAAyD,CAAC3C,QAAQ,CAAC4C,cAAT,CAAwB,QAAxB,CAA9D,EAAiG;AAC/F;AACA;AACD,OAHD,MAGO,IAAI5C,QAAQ,CAACM,IAAT,IAAiB,IAArB,EAA2B;AAChC;AACA;AACA,YAAIuC,MAAM,GAAG7C,QAAQ,CAAC4C,cAAT,CAAwB,QAAxB,KAAqC5C,QAAQ,CAAC6C,MAAT,IAAmB,IAAxD,GAA+D7C,QAAQ,CAAC6C,MAAxE,GAAiF,IAA9F;AACA,YAAIC,QAAQ,GAAGD,MAAM,GAAGA,MAAM,CAACE,GAAP,CAAW,UAAUC,KAAV,EAAiB;AAClD,cAAIC,OAAO,GAAGD,KAAK,CAACC,OAApB;AACA,iBAAOA,OAAP;AACD,SAHuB,EAGrBC,IAHqB,CAGhB,IAHgB,CAAH,GAGL,aAHhB;AAIA,YAAIrD,KAAK,GAAG5D,UAAU,CAAC8F,MAAX,CAAkB,cAAlB,EAAkC,qCAAqCU,MAAM,CAAChE,UAAP,CAAkBiC,OAAlB,CAA0ByC,IAA1B,CAA+BC,MAA/B,CAAsCzH,IAA3E,GAAkF,oBAAlF,GAAyGmH,QAAzG,GAAoH,2DAAtJ,CAAZ;AACAjD,QAAAA,KAAK,CAACtG,MAAN,GAAe;AACbsJ,UAAAA,MAAM,EAAEA,MADK;AAEbvF,UAAAA,SAAS,EAAEmF,MAAM,CAAChE,UAAP,CAAkBiC,OAAlB,CAA0ByC,IAFxB;AAGbE,UAAAA,SAAS,EAAEZ,MAAM,CAAChE,UAAP,CAAkBiC,OAAlB,CAA0B2C;AAHxB,SAAf,CATgC,CAa7B;AACH;;AAEAxD,QAAAA,KAAK,CAACyD,KAAN;AACA,cAAMzD,KAAN;AACD,OAlBM,MAkBA;AACL,YAAI0D,gBAAgB,GAAGvD,QAAvB;AACA0C,QAAAA,OAAO,CAAC1J,IAAR,CAAauK,gBAAb;AACD;AACF,KA1BD;AA2BA,WAAOb,OAAP;AACD;AACD;;;;AAjCA;;AAuCAnC,EAAAA,MAAM,CAACiD,0BAAP,GAAoC,SAASA,0BAAT,CAAoChB,SAApC,EAA+C;AACjF,QAAIiB,oBAAJ;;AAEA,QAAIjB,SAAS,CAAClJ,MAAV,GAAmB,CAAvB,EAA0B;AACxB,UAAIkJ,SAAS,CAACkB,IAAV,CAAe,UAAUC,YAAV,EAAwB;AACzC,YAAIC,qBAAJ;;AAEA,eAAO,CAAC,CAACA,qBAAqB,GAAGD,YAAY,CAAChB,UAAtC,MAAsD,IAAtD,IAA8DiB,qBAAqB,KAAK,KAAK,CAA7F,GAAiG,KAAK,CAAtG,GAA0GA,qBAAqB,CAACC,YAAjI,MAAmJ,IAA1J;AACD,OAJG,CAAJ,EAII;AACF,SAAC,KAAD,GAAStC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,yCAAR,CAAjD,GAAsGA,SAAS,CAAC,KAAD,CAAxH,GAAkI,KAAK,CAAvI;AACD;;AAED,aAAO,KAAP;AACD;;AAED,QAAI0D,QAAQ,GAAGwC,SAAS,CAAC,CAAD,CAAxB;AACA,QAAIqB,YAAY,GAAG,CAAC,CAACJ,oBAAoB,GAAGzD,QAAQ,CAAC2C,UAAjC,MAAiD,IAAjD,IAAyDc,oBAAoB,KAAK,KAAK,CAAvF,GAA2F,KAAK,CAAhG,GAAoGA,oBAAoB,CAACI,YAA1H,MAA4I,IAA/J;;AAEA,QAAIA,YAAY,IAAI,KAAKzE,MAAL,KAAgB,SAApC,EAA+C;AAC7C,OAAC,KAAD,GAASmC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,6EAAR,CAAjD,GAA0IA,SAAS,CAAC,KAAD,CAA5J,GAAsK,KAAK,CAA3K;AACD;;AAED,QAAIuH,YAAJ,EAAkB;AAChB,WAAKxD,0BAAL,CAAgCL,QAAhC,EAA0C,IAA1C,EAAgD,KAAK5B,yBAArD;;AAEA,WAAKc,KAAL,CAAWhE,IAAX,CAAgB8E,QAAhB;;AAEA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD,GA/BD;;AAiCAO,EAAAA,MAAM,CAAC8B,WAAP,GAAqB,SAASA,WAAT,CAAqBrC,QAArB,EAA+B;AAClD,QAAI,KAAKZ,MAAL,KAAgB,WAApB,EAAiC;AAC/B;AACD;;AAED,QAAIoD,SAAS,GAAGvI,KAAK,CAACC,OAAN,CAAc8F,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAArD;;AAEA,QAAI8D,iBAAiB,GAAG,KAAKvB,oBAAL,CAA0BC,SAA1B,CAAxB;;AAEA,QAAIsB,iBAAiB,CAACxK,MAAlB,KAA6B,CAAjC,EAAoC;AAClC;AACA;AACA,UAAIyK,OAAO,GAAGvB,SAAS,CAACkB,IAAV,CAAe,UAAUM,CAAV,EAAa;AACxC,YAAIC,aAAJ;;AAEA,eAAO,CAAC,CAACA,aAAa,GAAGD,CAAC,CAACrB,UAAnB,MAAmC,IAAnC,IAA2CsB,aAAa,KAAK,KAAK,CAAlE,GAAsE,KAAK,CAA3E,GAA+EA,aAAa,CAACC,QAA9F,MAA4G,IAAnH;AACD,OAJa,CAAd;;AAMA,UAAIH,OAAJ,EAAa;AACX,aAAK3E,MAAL,GAAc,eAAd;;AAEA,aAAKiC,kBAAL;;AAEA,aAAKhD,2BAAL,GAAmC,KAAnC;AACD;;AAED,WAAKa,KAAL,CAAWhE,IAAX,CAAgB8E,QAAhB;;AAEA;AACD,KA7BiD,CA6BhD;;;AAGF,QAAI6D,YAAY,GAAG,KAAKL,0BAAL,CAAgCM,iBAAhC,CAAnB;;AAEA,QAAID,YAAJ,EAAkB;AAChB;AACD;;AAED,QAAIM,qBAAqB,GAAGC,yBAAyB,CAACN,iBAAD,CAArD;AAAA,QACIO,uBAAuB,GAAGF,qBAAqB,CAAC,CAAD,CADnD;AAAA,QAEIG,oBAAoB,GAAGH,qBAAqB,CAAC,CAAD,CAFhD,CAtCkD,CAwCG;AACrD;AACA;AACA;AACA;AACA;AACA;;;AAGA,QAAIE,uBAAuB,CAAC/K,MAAxB,GAAiC,CAArC,EAAwC;AACtC,UAAIiL,gBAAgB,GAAG,KAAKC,iBAAL,CAAuBH,uBAAvB,CAAvB,CADsC,CACkC;AACxE;AACA;;;AAGA,UAAII,aAAa,GAAG,KAAKzF,aAAL,CAAmBmC,GAAnB,CAAuB,KAAK1C,UAA5B,CAApB;;AAEA,WAAKiG,uBAAL,CAA6BD,aAA7B;;AAEA,WAAKE,wBAAL,CAA8BJ,gBAA9B;AACD;;AAED,QAAID,oBAAoB,CAAChL,MAArB,GAA8B,CAAlC,EAAqC;AACnC,UAAIsL,iBAAiB,GAAG,KAAKC,4BAAL,CAAkCP,oBAAlC,CAAxB,CADmC,CAC8C;AACjF;AACA;;;AAGA,UAAIQ,cAAc,GAAG,KAAK9F,aAAL,CAAmBmC,GAAnB,EAArB;;AAEA,WAAKuD,uBAAL,CAA6BI,cAA7B;;AAEA,WAAKH,wBAAL,CAA8BC,iBAA9B;AACD;;AAED,SAAK1F,KAAL,CAAWhE,IAAX,CAAgB8E,QAAhB;AACD,GA5ED;;AA8EAO,EAAAA,MAAM,CAACF,0BAAP,GAAoC,SAASA,0BAAT,CAAoCL,QAApC,EAA8ClC,OAA9C,EAAuDE,wBAAvD,EAAiF;AACnH,QAAI+G,MAAM,GAAG,IAAb;;AAEA,MAAE,KAAKjG,kBAAL,KAA4B,IAA9B,IAAsCyC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,mEAAmE,UAA3E,CAAjD,GAA0IA,SAAS,CAAC,KAAD,CAAzL,GAAmM,KAAK,CAAxM;;AAEA,QAAI0D,QAAQ,IAAI,IAAZ,IAAoBlC,OAAO,IAAI,IAAnC,EAAyC;AACvC;AACD;;AAED,QAAIkD,iBAAiB,GAAG,EAAxB;;AAEA,QAAIhB,QAAJ,EAAc;AACZ,UAAIgF,OAAO,GAAGC,iBAAiB,CAACjF,QAAD,EAAW,KAAKvB,UAAL,CAAgByG,IAA3B,EAAiCpI,SAAjC,EAA4C;AACzEmB,QAAAA,SAAS,EAAE,KAAKE,UADyD;AAEzEgH,QAAAA,IAAI,EAAE,EAFmE;AAGzEnH,QAAAA,wBAAwB,EAAEA;AAH+C,OAA5C,CAA/B;AAKAoH,MAAAA,iCAAiC,CAACJ,OAAD,CAAjC;AACAhE,MAAAA,iBAAiB,CAAChI,IAAlB,CAAuB;AACrBsE,QAAAA,SAAS,EAAE,KAAKmB,UADK;AAErBuG,QAAAA,OAAO,EAAEA,OAFY;AAGrBlH,QAAAA,OAAO,EAAEA;AAHY,OAAvB;;AAMA,WAAKuH,2BAAL,CAAiCL,OAAjC,EAA0ChE,iBAA1C;AACD,KAdD,MAcO,IAAIlD,OAAJ,EAAa;AAClBkD,MAAAA,iBAAiB,CAAChI,IAAlB,CAAuB;AACrBsE,QAAAA,SAAS,EAAE,KAAKmB,UADK;AAErBuG,QAAAA,OAAO,EAAE;AACPnC,UAAAA,MAAM,EAAE,IADD;AAEPyC,UAAAA,aAAa,EAAE,IAFR;AAGPC,UAAAA,uBAAuB,EAAE,IAHlB;AAIPC,UAAAA,oBAAoB,EAAE,IAJf;AAKPjM,UAAAA,MAAM,EAAE6C,iBAAiB,CAAC2F,MAAlB,EALD;AAMPgC,UAAAA,OAAO,EAAE;AANF,SAFY;AAUrBjG,QAAAA,OAAO,EAAEA;AAVY,OAAvB;AAYD;;AAED,SAAKgB,kBAAL,GAA0BkC,iBAA1B;AACAA,IAAAA,iBAAiB,CAACxH,OAAlB,CAA0B,UAAUyH,MAAV,EAAkB;AAC1C,aAAO8D,MAAM,CAAC/F,aAAP,CAAqByG,WAArB,CAAiCxE,MAAjC,CAAP;AACD,KAFD;;AAIA,SAAKjC,aAAL,CAAmBmC,GAAnB;AACD,GA9CD;;AAgDAZ,EAAAA,MAAM,CAAC8E,2BAAP,GAAqC,SAASA,2BAAT,CAAqCL,OAArC,EAA8ChE,iBAA9C,EAAiE;AACpG,QAAIgE,OAAO,CAACQ,oBAAR,IAAgCR,OAAO,CAACQ,oBAAR,CAA6BlM,MAAjE,EAAyE;AACvE,UAAIkM,oBAAoB,GAAGR,OAAO,CAACQ,oBAAnC;AACA,UAAIhI,eAAe,GAAG,KAAKmB,gBAA3B;AACA,OAACnB,eAAD,GAAmB+D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,+DAA+D,iCAAvE,CAAjD,GAA6JA,SAAS,CAAC,KAAD,CAAzL,GAAmM,KAAK,CAAxM;;AAEA,UAAIoJ,SAAS,GAAG7L,0BAA0B,CAAC2L,oBAAD,CAA1C;AAAA,UACIG,KADJ;;AAGA,UAAI;AACF,aAAKD,SAAS,CAACrL,CAAV,EAAL,EAAoB,CAAC,CAACsL,KAAK,GAAGD,SAAS,CAACpL,CAAV,EAAT,EAAwBC,IAA7C,GAAoD;AAClD,cAAIqL,mBAAmB,GAAGD,KAAK,CAACnL,KAAhC;AACA,cAAI8C,SAAS,GAAGE,eAAe,CAACqI,GAAhB,CAAoBD,mBAAmB,CAACE,kBAAxC,CAAhB;;AAEA,cAAIxI,SAAS,IAAI,IAAjB,EAAuB;AACrB,iBAAKyI,mCAAL,CAAyCvI,eAAzC,EAA0DoI,mBAA1D;AACD,WAFD,MAEO;AACL,gBAAII,6BAA6B,GAAG,KAAKC,8BAAL,CAAoC3I,SAApC,EAA+CsI,mBAA/C,CAApC;;AAEA5E,YAAAA,iBAAiB,CAAChI,IAAlB,CAAuBC,KAAvB,CAA6B+H,iBAA7B,EAAgD,CAAC,GAAG5I,mBAAmB,CAAC,SAAD,CAAvB,EAAoC4N,6BAApC,CAAhD;AACD;AACF;AACF,OAbD,CAaE,OAAOhL,GAAP,EAAY;AACZ0K,QAAAA,SAAS,CAACjL,CAAV,CAAYO,GAAZ;AACD,OAfD,SAeU;AACR0K,QAAAA,SAAS,CAAC/K,CAAV;AACD;AACF;AACF,GA5BD;;AA8BA4F,EAAAA,MAAM,CAAC2F,sBAAP,GAAgC,SAASA,sBAAT,CAAgCN,mBAAhC,EAAqDtI,SAArD,EAAgE;AAC9F,QAAI6I,QAAQ,GAAGvJ,2BAA2B,CAACU,SAAD,EAAYsI,mBAAmB,CAACQ,MAAhC,EAAwCR,mBAAmB,CAACvC,SAA5D,CAA1C;AACA,WAAO4B,iBAAiB,CAAC;AACvB3E,MAAAA,IAAI,EAAEsF,mBAAmB,CAACtF;AADH,KAAD,EAErB6F,QAFqB,EAEXP,mBAAmB,CAACS,QAFT,EAEmB;AACzCpI,MAAAA,SAAS,EAAE,KAAKE,UADyB;AAEzCgH,MAAAA,IAAI,EAAES,mBAAmB,CAACT,IAFe;AAGzCnH,MAAAA,wBAAwB,EAAE,KAAKI;AAHU,KAFnB,CAAxB;AAOD,GATD;;AAWAmC,EAAAA,MAAM,CAAC0F,8BAAP,GAAwC,SAASA,8BAAT,CAAwC3I,SAAxC,EAAmDsI,mBAAnD,EAAwE;AAC9G,QAAI5E,iBAAiB,GAAG,EAAxB;;AAEA,QAAIsF,aAAa,GAAG,KAAKJ,sBAAL,CAA4BN,mBAA5B,EAAiDtI,SAAjD,CAApB;;AAEA8H,IAAAA,iCAAiC,CAACkB,aAAD,CAAjC;AACAtF,IAAAA,iBAAiB,CAAChI,IAAlB,CAAuB;AACrBsE,MAAAA,SAAS,EAAE,KAAKmB,UADK;AAErBuG,MAAAA,OAAO,EAAEsB,aAFY;AAGrBxI,MAAAA,OAAO,EAAE;AAHY,KAAvB;;AAMA,SAAKuH,2BAAL,CAAiCiB,aAAjC,EAAgDtF,iBAAhD;;AAEA,WAAOA,iBAAP;AACD,GAfD;;AAiBAT,EAAAA,MAAM,CAACwF,mCAAP,GAA6C,SAASA,mCAAT,CAA6CvI,eAA7C,EAA8DoI,mBAA9D,EAAmF;AAC9H,QAAIW,MAAM,GAAG,IAAb;;AAEA/I,IAAAA,eAAe,CAACgJ,IAAhB,CAAqBZ,mBAAmB,CAACE,kBAAzC,EAA6DW,IAA7D,CAAkE,UAAUnJ,SAAV,EAAqB;AACrF,UAAIA,SAAS,IAAI,IAAb,IAAqBiJ,MAAM,CAACnH,MAAP,KAAkB,SAA3C,EAAsD;AACpD;AACD;;AAED,UAAI4G,6BAA6B,GAAGO,MAAM,CAACN,8BAAP,CAAsC3I,SAAtC,EAAiDsI,mBAAjD,CAApC;;AAEAI,MAAAA,6BAA6B,CAACxM,OAA9B,CAAsC,UAAUyH,MAAV,EAAkB;AACtD,eAAOsF,MAAM,CAACvH,aAAP,CAAqByG,WAArB,CAAiCxE,MAAjC,CAAP;AACD,OAFD;;AAIA,UAAIsF,MAAM,CAACzH,kBAAP,IAA6B,IAAjC,EAAuC;AACrCyC,QAAAA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCjF,OAAO,CAAC,KAAD,EAAQ,kEAAkE,yBAAlE,GAA8F+J,MAAM,CAAC9H,UAAP,CAAkBiC,OAAlB,CAA0ByC,IAA1B,CAA+BC,MAA/B,CAAsCzH,IAA5I,CAA/C,GAAmM,KAAK,CAAxM;AACD,OAFD,MAEO;AACL,YAAI+K,qBAAJ;;AAEA,SAACA,qBAAqB,GAAGH,MAAM,CAACzH,kBAAhC,EAAoD9F,IAApD,CAAyDC,KAAzD,CAA+DyN,qBAA/D,EAAsF,CAAC,GAAGtO,mBAAmB,CAAC,SAAD,CAAvB,EAAoC4N,6BAApC,CAAtF;;AAEAO,QAAAA,MAAM,CAACvH,aAAP,CAAqBmC,GAArB;AACD;AACF,KApBD;AAqBD,GAxBD;;AA0BAZ,EAAAA,MAAM,CAACiE,iBAAP,GAA2B,SAASA,iBAAT,CAA2BhC,SAA3B,EAAsC;AAC/D,QAAImE,MAAM,GAAG,IAAb;;AAEA,QAAI,KAAK7H,kBAAL,KAA4B,IAAhC,EAAsC;AACpC,WAAKA,kBAAL,CAAwBtF,OAAxB,CAAgC,UAAUyH,MAAV,EAAkB;AAChD,eAAO0F,MAAM,CAAC3H,aAAP,CAAqBkC,YAArB,CAAkCD,MAAlC,CAAP;AACD,OAFD;;AAIA,WAAKnC,kBAAL,GAA0B,IAA1B;AACD;;AAED,SAAKT,2BAAL,GAAmC,KAAnC;;AAEA,SAAKC,mBAAL,CAAyByC,KAAzB;;AAEA,SAAK5B,OAAL,CAAa4B,KAAb;;AAEA,WAAOyB,SAAS,CAACO,GAAV,CAAc,UAAU6D,WAAV,EAAuB;AAC1C,UAAIC,YAAY,GAAG5B,iBAAiB,CAAC2B,WAAD,EAAcD,MAAM,CAAClI,UAAP,CAAkByG,IAAhC,EAAsCpI,SAAtC,EAAiD;AACnFmB,QAAAA,SAAS,EAAE0I,MAAM,CAACxI,UADiE;AAEnFH,QAAAA,wBAAwB,EAAE2I,MAAM,CAACvI,yBAFkD;AAGnF+G,QAAAA,IAAI,EAAE;AAH6E,OAAjD,CAApC;;AAMAwB,MAAAA,MAAM,CAAC3H,aAAP,CAAqB8H,aAArB,CAAmCH,MAAM,CAAClI,UAA1C,EAAsDoI,YAAtD,EAAoEF,MAAM,CAACpH,QAA3E;;AAEA,aAAOsH,YAAP;AACD,KAVM,CAAP;AAWD;AACD;;;;AA7BA;;AAmCAtG,EAAAA,MAAM,CAACoE,wBAAP,GAAkC,SAASA,wBAAT,CAAkCoC,QAAlC,EAA4C;AAC5E,QAAIC,MAAM,GAAG,IAAb;;AAEA,QAAI,KAAK5H,MAAL,KAAgB,WAApB,EAAiC;AAC/B;AACD;;AAED2H,IAAAA,QAAQ,CAACvN,OAAT,CAAiB,UAAUwL,OAAV,EAAmB;AAClC,UAAIO,uBAAuB,GAAGP,OAAO,CAACO,uBAAtC;AAAA,UACIC,oBAAoB,GAAGR,OAAO,CAACQ,oBADnC;AAAA,UAEIzB,OAAO,GAAGiB,OAAO,CAACjB,OAFtB;AAGAiD,MAAAA,MAAM,CAAC5H,MAAP,GAAgB2E,OAAO,GAAG,eAAH,GAAqB,qBAA5C;;AAEAiD,MAAAA,MAAM,CAAC3F,kBAAP;;AAEA,UAAI0C,OAAJ,EAAa;AACXiD,QAAAA,MAAM,CAAC3I,2BAAP,GAAqC,KAArC;AACD;;AAED,UAAImH,oBAAoB,IAAIA,oBAAoB,CAAClM,MAArB,KAAgC,CAA5D,EAA+D;AAC7D,YAAIkE,eAAe,GAAGwJ,MAAM,CAACrI,gBAA7B;AACA,SAACnB,eAAD,GAAmB+D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,+DAA+D,iCAAvE,CAAjD,GAA6JA,SAAS,CAAC,KAAD,CAAzL,GAAmM,KAAK,CAAxM;AACAkJ,QAAAA,oBAAoB,CAAChM,OAArB,CAA6B,UAAUoM,mBAAV,EAA+B;AAC1DoB,UAAAA,MAAM,CAACC,2BAAP,CAAmCrB,mBAAnC,EAAwDpI,eAAxD;AACD,SAFD;AAGD;;AAED,UAAI+H,uBAAuB,IAAIA,uBAAuB,CAACjM,MAAxB,KAAmC,CAAlE,EAAqE;AACnE0N,QAAAA,MAAM,CAAC3I,2BAAP,GAAqC2I,MAAM,CAAC5H,MAAP,KAAkB,eAAvD;AACAmG,QAAAA,uBAAuB,CAAC/L,OAAxB,CAAgC,UAAU0N,sBAAV,EAAkC;AAChEF,UAAAA,MAAM,CAACG,8BAAP,CAAsCnC,OAAtC,EAA+CkC,sBAA/C;AACD,SAFD;;AAIA,YAAIF,MAAM,CAACxH,gBAAP,IAA2BwH,MAAM,CAAC5H,MAAP,KAAkB,eAAjD,EAAkE;AAChE;AACA;AACA;AACA;AACA;AACA;AACAmC,UAAAA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCjF,OAAO,CAACwK,MAAM,CAACxH,gBAAR,EAA0B,oEAAoE,yDAApE,GAAgI,qEAA1J,EAAiOwH,MAAM,CAACvI,UAAP,CAAkBiC,OAAlB,CAA0ByC,IAA1B,CAA+BC,MAA/B,CAAsCzH,IAAvQ,CAA/C,GAA8T,KAAK,CAAnU,CAPgE,CAOsQ;;AAEtU,cAAIyL,aAAa,GAAG,EAApB;AACA7B,UAAAA,uBAAuB,CAAC/L,OAAxB,CAAgC,UAAU6N,WAAV,EAAuB;AACrD,gBAAIA,WAAW,CAACC,IAAZ,KAAqB,OAAzB,EAAkC;AAChCF,cAAAA,aAAa,CAACpO,IAAd,CAAmBgO,MAAM,CAACO,qBAAP,CAA6BF,WAAW,CAACG,KAAzC,EAAgDH,WAAW,CAAClC,IAA5D,EAAkEkC,WAAlE,EAA+E;AAChG/G,gBAAAA,IAAI,EAAE+G,WAAW,CAAC/G;AAD8E,eAA/E,CAAnB;AAGD;AACF,WAND;;AAQA,cAAI8G,aAAa,CAAC9N,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,gBAAImL,aAAa,GAAGuC,MAAM,CAAChI,aAAP,CAAqBmC,GAArB,EAApB;;AAEA6F,YAAAA,MAAM,CAACtC,uBAAP,CAA+BD,aAA/B;;AAEAuC,YAAAA,MAAM,CAACrC,wBAAP,CAAgCyC,aAAhC;AACD;AACF;AACF;AACF,KArDD;AAsDD,GA7DD;;AA+DA7G,EAAAA,MAAM,CAAC+B,2CAAP,GAAqD,SAASA,2CAAT,GAAuD;AAC1G,QAAImF,uBAAuB,GAAG,KAAKhJ,UAAL,CAAgBiC,OAAhB,CAAwByC,IAAxB,CAA6BC,MAA7B,CAAoCsE,aAApC,KAAsD,cAApF;;AAEA,QAAI,CAACD,uBAAL,EAA8B;AAC5B;AACD;;AAED,QAAI,KAAK1I,2BAAL,KAAqC,CAArC,IAA0C,KAAKV,2BAAL,KAAqC,KAAnF,EAA0F;AACxF,WAAK+C,yBAAL;AACD;AACF;AACD;;;;;;;AAXA;;AAoBAb,EAAAA,MAAM,CAAC0G,2BAAP,GAAqC,SAASA,2BAAT,CAAqCrB,mBAArC,EAA0DpI,eAA1D,EAA2E;AAC9G,QAAImK,OAAO,GAAG,IAAd;;AAEA,QAAIC,aAAa,GAAGpK,eAAe,CAACqI,GAAhB,CAAoBD,mBAAmB,CAACE,kBAAxC,CAApB;;AAEA,QAAI8B,aAAa,IAAI,IAArB,EAA2B;AACzB;AACA;AACA,WAAKC,0BAAL,CAAgCjC,mBAAhC,EAAqDgC,aAArD;;AAEA,WAAKtF,2CAAL;AACD,KAND,MAMO;AACL;AACA;AACA,UAAIwF,IAAI,GAAG,KAAKtJ,mBAAL,EAAX;;AAEA,WAAKO,2BAAL;;AAEA,UAAIgJ,qBAAqB,GAAG,SAASA,qBAAT,GAAiC;AAC3DJ,QAAAA,OAAO,CAAC5I,2BAAR;;AAEA4I,QAAAA,OAAO,CAACrF,2CAAR;AACD,OAJD,CAPK,CAWF;AACH;AACA;;;AAGAnG,MAAAA,eAAe,CAACP,IAAhB,CAAqB,IAAIoM,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC1D1K,QAAAA,eAAe,CAACgJ,IAAhB,CAAqBZ,mBAAmB,CAACE,kBAAzC,EAA6DW,IAA7D,CAAkEwB,OAAlE,EAA2EC,MAA3E;AACD,OAFoB,CAArB,EAEInF,GAFJ,CAEQ,UAAUzF,SAAV,EAAqB;AAC3B,YAAIA,SAAS,IAAI,IAAjB,EAAuB;AACrBqK,UAAAA,OAAO,CAAChG,SAAR,CAAkB,YAAY;AAC5BgG,YAAAA,OAAO,CAACE,0BAAR,CAAmCjC,mBAAnC,EAAwDtI,SAAxD;AACD,WAFD;AAGD;AACF,OARD,EAQGoC,SARH,CAQa;AACXC,QAAAA,QAAQ,EAAE,SAASA,QAAT,GAAoB;AAC5BgI,UAAAA,OAAO,CAAC/H,SAAR,CAAkBkI,IAAlB;;AAEAC,UAAAA,qBAAqB;AACtB,SALU;AAMXlI,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAesI,OAAf,EAAwB;AAC7BR,UAAAA,OAAO,CAAC5H,MAAR,CAAeoI,OAAf;;AAEAJ,UAAAA,qBAAqB;AACtB,SAVU;AAWX7H,QAAAA,KAAK,EAAE,SAASA,KAAT,CAAeC,YAAf,EAA6B;AAClC,iBAAOwH,OAAO,CAACvH,MAAR,CAAe0H,IAAf,EAAqB3H,YAArB,CAAP;AACD;AAbU,OARb;AAuBD;AACF,GAnDD;;AAqDAI,EAAAA,MAAM,CAACsH,0BAAP,GAAoC,SAASA,0BAAT,CAAoCjC,mBAApC,EAAyDtI,SAAzD,EAAoE;AACtG,QAAIuJ,YAAY,GAAG,KAAKX,sBAAL,CAA4BN,mBAA5B,EAAiDtI,SAAjD,CAAnB;;AAEA,SAAK0B,aAAL,CAAmB8H,aAAnB,CAAiC,KAAKrI,UAAtC,EAAkDoI,YAAlD;;AAEA,QAAIpC,aAAa,GAAG,KAAKzF,aAAL,CAAmBmC,GAAnB,EAApB;;AAEA,SAAKuD,uBAAL,CAA6BD,aAA7B;;AAEA,SAAKE,wBAAL,CAA8B,CAACkC,YAAD,CAA9B;AACD;AACD;;;;;;;;;;;AAXA;;AAwBAtG,EAAAA,MAAM,CAAC4G,8BAAP,GAAwC,SAASA,8BAAT,CAAwCN,YAAxC,EAAsDQ,WAAtD,EAAmE;AACzG,QAAIe,qBAAJ,CADyG,CAGzG;;;AACA,QAAIZ,KAAK,GAAGH,WAAW,CAACG,KAAxB;AAAA,QACIrC,IAAI,GAAGkC,WAAW,CAAClC,IADvB;AAEA,QAAIkD,OAAO,GAAGlD,IAAI,CAACpC,GAAL,CAASuF,MAAT,EAAiBpF,IAAjB,CAAsB,GAAtB,CAAd;;AAEA,QAAIqF,cAAc,GAAG,KAAKjK,mBAAL,CAAyBuH,GAAzB,CAA6B2B,KAA7B,CAArB;;AAEA,QAAIe,cAAc,IAAI,IAAtB,EAA4B;AAC1BA,MAAAA,cAAc,GAAG,IAAIhK,GAAJ,EAAjB;;AAEA,WAAKD,mBAAL,CAAyBoD,GAAzB,CAA6B8F,KAA7B,EAAoCe,cAApC;AACD;;AAED,QAAIC,aAAa,GAAGD,cAAc,CAAC1C,GAAf,CAAmBwC,OAAnB,CAApB;AACA,QAAII,gBAAgB,GAAGD,aAAa,IAAI,IAAjB,IAAyBA,aAAa,CAAClB,IAAd,KAAuB,UAAhD,GAA6DkB,aAAa,CAAChG,SAA3E,GAAuF,IAA9G;AACA+F,IAAAA,cAAc,CAAC7G,GAAf,CAAmB2G,OAAnB,EAA4B;AAC1Bf,MAAAA,IAAI,EAAE,aADoB;AAE1BD,MAAAA,WAAW,EAAEA;AAFa,KAA5B,EAlByG,CAqBrG;AACJ;AACA;;AAEA,QAAIqB,QAAJ;;AAEA,QAAIrB,WAAW,CAACC,IAAZ,KAAqB,QAAzB,EAAmC;AACjCoB,MAAAA,QAAQ,GAAGrB,WAAW,CAACqB,QAAvB;AACD,KAFD,MAEO,IAAIrB,WAAW,CAACC,IAAZ,KAAqB,OAAzB,EAAkC;AACvCoB,MAAAA,QAAQ,GAAGrB,WAAW,CAAClB,QAAZ,CAAqBC,MAAhC;AACD,KAFM,MAEA;AACLiB,MAAAA,WAAW;AACX,OAAC,KAAD,GAAS9F,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,gDAAR,EAA0D+K,WAAW,CAACC,IAAtE,CAAjD,GAA+HhL,SAAS,CAAC,KAAD,CAAjJ,GAA2J,KAAK,CAAhK;AACD;;AAED,QAAIqM,YAAY,GAAG9B,YAAY,CAACtN,MAAb,CAAoBsM,GAApB,CAAwB6C,QAAxB,CAAnB;AACA,QAAIE,cAAc,GAAG,CAAC,CAACR,qBAAqB,GAAGvB,YAAY,CAACvB,aAAtC,MAAyD,IAAzD,IAAiE8C,qBAAqB,KAAK,KAAK,CAAhG,GAAoGA,qBAApG,GAA4H,EAA7H,EAAiIxP,MAAjI,CAAwI,UAAUiQ,YAAV,EAAwB;AACnL,UAAIC,OAAO,GAAGpM,gBAAgB,CAACmM,YAAY,CAACzC,MAAd,EAAsByC,YAAY,CAACE,QAAnC,CAA9B;AACA,aAAQ;AACNF,QAAAA,YAAY,CAACzC,MAAb,KAAwBsC,QAAxB,IAAoC;AACpC;AACAI,QAAAA,OAAO,KAAKJ;AAHd;AAKD,KAPoB,CAArB,CArCyG,CA4CrG;AACJ;;AAEA,MAAEC,YAAY,IAAI,IAAlB,IAA0BpH,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,wDAAR,EAAkEoM,QAAlE,CAAjD,GAA+HpM,SAAS,CAAC,KAAD,CAAlK,GAA4K,KAAK,CAAjL;AACA,QAAI0M,gBAAJ;AACA,QAAIC,kBAAJ;;AAEA,QAAIC,mBAAmB,GAAG,KAAK/J,OAAL,CAAa0G,GAAb,CAAiB6C,QAAjB,CAA1B;;AAEA,QAAIQ,mBAAmB,IAAI,IAA3B,EAAiC;AAC/B;AACA;AACAF,MAAAA,gBAAgB,GAAG9M,iBAAiB,CAAC+E,MAAlB,CAAyBiI,mBAAmB,CAACC,MAA7C,EAAqDR,YAArD,CAAnB;AACA,UAAIS,cAAc,GAAG,IAAI7K,GAAJ,EAArB;;AAEA,UAAI8K,aAAa,GAAG,SAASA,aAAT,CAAuBrE,OAAvB,EAAgC;AAClD,YAAIvL,GAAG,GAAG6P,eAAe,CAACtE,OAAD,CAAzB;AACAoE,QAAAA,cAAc,CAAC1H,GAAf,CAAmBjI,GAAnB,EAAwBuL,OAAxB;AACD,OAHD;;AAKAkE,MAAAA,mBAAmB,CAAC5D,aAApB,CAAkC9L,OAAlC,CAA0C6P,aAA1C;AACAT,MAAAA,cAAc,CAACpP,OAAf,CAAuB6P,aAAvB;AACAJ,MAAAA,kBAAkB,GAAGhP,KAAK,CAAC2B,IAAN,CAAWwN,cAAc,CAACG,MAAf,EAAX,CAArB;AACD,KAdD,MAcO;AACLP,MAAAA,gBAAgB,GAAGL,YAAnB;AACAM,MAAAA,kBAAkB,GAAGL,cAArB;AACD;;AAED,SAAKzJ,OAAL,CAAauC,GAAb,CAAiBgH,QAAjB,EAA2B;AACzBS,MAAAA,MAAM,EAAEH,gBADiB;AAEzB1D,MAAAA,aAAa,EAAE2D;AAFU,KAA3B,EAxEyG,CA2ErG;AACJ;;;AAGA,QAAIR,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,UAAIlE,gBAAgB,GAAG,KAAKM,4BAAL,CAAkC4D,gBAAlC,CAAvB;;AAEA,UAAIhE,aAAa,GAAG,KAAKzF,aAAL,CAAmBmC,GAAnB,EAApB;;AAEA,WAAKuD,uBAAL,CAA6BD,aAA7B;;AAEA,WAAKE,wBAAL,CAA8BJ,gBAA9B;AACD;AACF;AACD;;;;;AAzFA;;AAgGAhE,EAAAA,MAAM,CAACsE,4BAAP,GAAsC,SAASA,4BAAT,CAAsCP,oBAAtC,EAA4D;AAChG,QAAIkF,OAAO,GAAG,IAAd;;AAEA,QAAIpC,aAAa,GAAG,EAApB;AACA9C,IAAAA,oBAAoB,CAAC9K,OAArB,CAA6B,UAAUiQ,mBAAV,EAA+B;AAC1D,UAAIjC,KAAK,GAAGiC,mBAAmB,CAACjC,KAAhC;AAAA,UACIrC,IAAI,GAAGsE,mBAAmB,CAACtE,IAD/B;AAAA,UAEInF,QAAQ,GAAGyJ,mBAAmB,CAACzJ,QAFnC;;AAIA,UAAIuI,cAAc,GAAGiB,OAAO,CAAClL,mBAAR,CAA4BuH,GAA5B,CAAgC2B,KAAhC,CAArB;;AAEA,UAAIe,cAAc,IAAI,IAAtB,EAA4B;AAC1BA,QAAAA,cAAc,GAAG,IAAIhK,GAAJ,EAAjB;;AAEAiL,QAAAA,OAAO,CAAClL,mBAAR,CAA4BoD,GAA5B,CAAgC8F,KAAhC,EAAuCe,cAAvC;AACD;;AAED,UAAIf,KAAK,CAACkC,OAAN,CAAc,SAAd,MAA6B,CAAC,CAAlC,EAAqC;AACnC,YAAIrB,OAAO,GAAGlD,IAAI,CAACpC,GAAL,CAASuF,MAAT,EAAiBpF,IAAjB,CAAsB,GAAtB,CAAd;AACA,YAAIsF,aAAa,GAAGD,cAAc,CAAC1C,GAAf,CAAmBwC,OAAnB,CAApB;;AAEA,YAAIG,aAAa,IAAI,IAArB,EAA2B;AACzBA,UAAAA,aAAa,GAAG;AACdlB,YAAAA,IAAI,EAAE,UADQ;AAEd9E,YAAAA,SAAS,EAAE,CAACiH,mBAAD;AAFG,WAAhB;AAIAlB,UAAAA,cAAc,CAAC7G,GAAf,CAAmB2G,OAAnB,EAA4BG,aAA5B;AACA;AACD,SAPD,MAOO,IAAIA,aAAa,CAAClB,IAAd,KAAuB,UAA3B,EAAuC;AAC5CkB,UAAAA,aAAa,CAAChG,SAAd,CAAwBxJ,IAAxB,CAA6ByQ,mBAA7B;AACA;AACD;;AAED,YAAIpC,WAAW,GAAGmB,aAAa,CAACnB,WAAhC;AACA,UAAEA,WAAW,CAACC,IAAZ,KAAqB,OAAvB,IAAkC/F,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,wEAAwE,mCAAhF,EAAqH+L,OAArH,EAA8Hb,KAA9H,EAAqIH,WAAW,CAACC,IAAjJ,CAAjD,GAA0MhL,SAAS,CAAC,KAAD,CAArP,GAA+P,KAAK,CAApQ;AACA8K,QAAAA,aAAa,CAACpO,IAAd,CAAmBwQ,OAAO,CAACjC,qBAAR,CAA8BC,KAA9B,EAAqCrC,IAArC,EAA2CkC,WAA3C,EAAwDrH,QAAxD,CAAnB;AACD,OAnBD,MAmBO;AACL;AACA;AACA;AACA;AACA,YAAI2J,QAAQ,GAAGxE,IAAI,CAAC1J,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,EAAkBsH,GAAlB,CAAsBuF,MAAtB,EAA8BpF,IAA9B,CAAmC,GAAnC,CAAf;;AAEA,YAAI0G,cAAc,GAAGrB,cAAc,CAAC1C,GAAf,CAAmB8D,QAAnB,CAArB;;AAEA,YAAIC,cAAc,IAAI,IAAtB,EAA4B;AAC1BA,UAAAA,cAAc,GAAG;AACftC,YAAAA,IAAI,EAAE,UADS;AAEf9E,YAAAA,SAAS,EAAE,CAACiH,mBAAD;AAFI,WAAjB;AAIAlB,UAAAA,cAAc,CAAC7G,GAAf,CAAmBiI,QAAnB,EAA6BC,cAA7B;AACA;AACD,SAPD,MAOO,IAAIA,cAAc,CAACtC,IAAf,KAAwB,UAA5B,EAAwC;AAC7CsC,UAAAA,cAAc,CAACpH,SAAf,CAAyBxJ,IAAzB,CAA8ByQ,mBAA9B;;AAEA;AACD;;AAED,YAAII,YAAY,GAAGD,cAAc,CAACvC,WAAlC;AACA,UAAEwC,YAAY,CAACvC,IAAb,KAAsB,QAAxB,IAAoC/F,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,wEAAwE,oCAAhF,EAAsHqN,QAAtH,EAAgInC,KAAhI,EAAuIqC,YAAY,CAACvC,IAApJ,CAAjD,GAA6MhL,SAAS,CAAC,KAAD,CAA1P,GAAoQ,KAAK,CAAzQ;AACA8K,QAAAA,aAAa,CAACpO,IAAd,CAAmBwQ,OAAO,CAACM,sBAAR,CAA+BtC,KAA/B,EAAsCrC,IAAtC,EAA4C0E,YAA5C,EAA0D7J,QAA1D,CAAnB;AACD;AACF,KA1DD;AA2DA,WAAOoH,aAAP;AACD,GAhED;;AAkEA7G,EAAAA,MAAM,CAACgH,qBAAP,GAA+B,SAASA,qBAAT,CAA+BC,KAA/B,EAAsCrC,IAAtC,EAA4CkC,WAA5C,EAAyDrH,QAAzD,EAAmE;AAChG,QAAI0I,QAAQ,GAAGrB,WAAW,CAAClB,QAAZ,CAAqBC,MAApC;AACA,QAAIS,YAAY,GAAG5B,iBAAiB,CAACjF,QAAD,EAAWqH,WAAW,CAAClB,QAAvB,EAAiCkB,WAAW,CAAChB,QAA7C,EAAuD;AACzFpI,MAAAA,SAAS,EAAE,KAAKE,UADyE;AAEzFgH,MAAAA,IAAI,EAAEkC,WAAW,CAAClC,IAFuE;AAGzFnH,MAAAA,wBAAwB,EAAE,KAAKI;AAH0D,KAAvD,CAApC;;AAMA,SAAKY,aAAL,CAAmB8H,aAAnB,CAAiC,KAAKrI,UAAtC,EAAkDoI,YAAlD,EARgG,CAQ/B;AACjE;;;AAGA,QAAIkD,WAAW,GAAG,KAAK5K,OAAL,CAAa0G,GAAb,CAAiB6C,QAAjB,CAAlB;;AAEA,MAAEqB,WAAW,IAAI,IAAjB,IAAyBxI,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,wEAAwE,gBAAhF,EAAkGoM,QAAlG,CAAjD,GAA+JpM,SAAS,CAAC,KAAD,CAAjM,GAA2M,KAAK,CAAhN;AACA,QAAIgJ,aAAa,GAAGyE,WAAW,CAACzE,aAAhC;;AAEA,QAAIA,aAAa,CAAChM,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,UAAI0Q,qBAAJ;;AAEA,UAAIC,wBAAwB,GAAG;AAC7BpH,QAAAA,MAAM,EAAE,IADqB;AAE7ByC,QAAAA,aAAa,EAAEA,aAFc;AAG7BC,QAAAA,uBAAuB,EAAE,IAHI;AAI7BC,QAAAA,oBAAoB,EAAE,IAJO;AAK7BjM,QAAAA,MAAM,EAAE6C,iBAAiB,CAAC2F,MAAlB,EALqB;AAM7BgC,QAAAA,OAAO,EAAE,CAAC,CAACiG,qBAAqB,GAAGhK,QAAQ,CAAC2C,UAAlC,MAAkD,IAAlD,IAA0DqH,qBAAqB,KAAK,KAAK,CAAzF,GAA6F,KAAK,CAAlG,GAAsGA,qBAAqB,CAAC9F,QAA7H,MAA2I;AANvH,OAA/B;;AASA,WAAKlF,aAAL,CAAmB8H,aAAnB,CAAiC,KAAKrI,UAAtC,EAAkDwL,wBAAlD;AACD;;AAED,WAAOpD,YAAP;AACD;AACD;;;AAlCA;;AAuCAtG,EAAAA,MAAM,CAACuJ,sBAAP,GAAgC,SAASA,sBAAT,CAAgCtC,KAAhC,EAAuCrC,IAAvC,EAA6CkC,WAA7C,EAA0DrH,QAA1D,EAAoE;AAClG,QAAI0I,QAAQ,GAAGrB,WAAW,CAACqB,QAA3B;AAAA,QACIvF,IAAI,GAAGkE,WAAW,CAAClE,IADvB;AAAA,QAEIE,SAAS,GAAGgE,WAAW,CAAChE,SAF5B,CADkG,CAG3D;;AAEvC,QAAI6G,KAAK,GAAG/G,IAAI,CAACgH,UAAL,CAAgB,CAAhB,CAAZ;AACA,MAAED,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAAC5C,IAAN,KAAe,aAAhC,IAAiD4C,KAAK,CAACE,MAAN,KAAiB,IAApE,IAA4E7I,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,wEAAR,CAAjD,GAAqIA,SAAS,CAAC,KAAD,CAA1N,GAAoO,KAAK,CAAzO;;AAEA,QAAI+N,qBAAqB,GAAG,KAAKC,oBAAL,CAA0BtK,QAA1B,EAAoC0I,QAApC,EAA8CwB,KAA9C,EAAqD7G,SAArD,EAAgE8B,IAAhE,EAAsEkC,WAAW,CAAClC,IAAlF,CAA5B;AAAA,QACIG,aAAa,GAAG+E,qBAAqB,CAAC/E,aAD1C;AAAA,QAEIiF,MAAM,GAAGF,qBAAqB,CAACE,MAFnC;AAAA,QAGIC,SAAS,GAAGH,qBAAqB,CAACG,SAHtC;AAAA,QAIIC,OAAO,GAAGJ,qBAAqB,CAACI,OAJpC;AAAA,QAKI5D,YAAY,GAAGwD,qBAAqB,CAACxD,YALzC;AAAA,QAMI6D,UAAU,GAAGL,qBAAqB,CAACK,UANvC,CARkG,CAc/C;AACnD;AACA;;;AAGA,SAAK1L,aAAL,CAAmB8H,aAAnB,CAAiC,KAAKrI,UAAtC,EAAkDoI,YAAlD,EAAgE,UAAUhJ,KAAV,EAAiB;AAC/E,UAAI8M,mBAAmB,GAAG9M,KAAK,CAACgI,GAAN,CAAU6C,QAAV,CAA1B;;AAEA,UAAIiC,mBAAmB,IAAI,IAA3B,EAAiC;AAC/B;AACA;AACD;;AAED,UAAIC,YAAY,GAAGD,mBAAmB,CAACE,gBAApB,CAAqCH,UAArC,CAAnB;;AAEA,UAAIE,YAAY,IAAI,IAApB,EAA0B;AACxB;AACA;AACD;;AAED,UAAIA,YAAY,CAACtR,MAAb,KAAwBmR,OAAO,CAACnR,MAAhC,IAA0CsR,YAAY,CAAClH,IAAb,CAAkB,UAAUoH,WAAV,EAAuBC,KAAvB,EAA8B;AAC5F,eAAON,OAAO,CAACM,KAAD,CAAP,MAAoBD,WAAW,IAAIA,WAAW,CAAC7M,SAAZ,EAAnC,CAAP;AACD,OAF6C,CAA9C,EAEI;AACF;AACA;AACA;AACD,OArB8E,CAqB7E;AACF;;;AAGA,UAAI+M,SAAS,GAAG,CAAC,GAAG5S,mBAAmB,CAAC,SAAD,CAAvB,EAAoCwS,YAApC,CAAhB;AACAI,MAAAA,SAAS,CAACR,SAAD,CAAT,GAAuB3M,KAAK,CAACgI,GAAN,CAAU0E,MAAV,CAAvB;AACAI,MAAAA,mBAAmB,CAACM,gBAApB,CAAqCD,SAArC,EAAgDN,UAAhD;AACD,KA5BD,EAnBkG,CA+C9F;AACJ;;;AAGA,QAAIpF,aAAa,CAAChM,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,UAAI2Q,wBAAwB,GAAG;AAC7BpH,QAAAA,MAAM,EAAE,IADqB;AAE7ByC,QAAAA,aAAa,EAAEA,aAFc;AAG7BC,QAAAA,uBAAuB,EAAE,IAHI;AAI7BC,QAAAA,oBAAoB,EAAE,IAJO;AAK7BjM,QAAAA,MAAM,EAAE6C,iBAAiB,CAAC2F,MAAlB,EALqB;AAM7BgC,QAAAA,OAAO,EAAE;AANoB,OAA/B;;AASA,WAAK/E,aAAL,CAAmB8H,aAAnB,CAAiC,KAAKrI,UAAtC,EAAkDwL,wBAAlD;AACD;;AAED,WAAOpD,YAAP;AACD,GAjED;;AAmEAtG,EAAAA,MAAM,CAAC+J,oBAAP,GAA8B,SAASA,oBAAT,CAA8BtK,QAA9B,EAAwC0I,QAAxC,EAAkDwB,KAAlD,EAAyD7G,SAAzD,EAAoE8B,IAApE,EAA0E+F,iBAA1E,EAA6F;AACzH,QAAIC,YAAJ,EAAkBC,mBAAlB,EAAuCC,gBAAvC;;AAEA,QAAI/K,IAAI,GAAGN,QAAQ,CAACM,IAApB;AACA,MAAE,OAAOA,IAAP,KAAgB,QAAlB,IAA8BiB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,yEAAyE,wBAAjF,CAAjD,GAA8JA,SAAS,CAAC,KAAD,CAArM,GAA+M,KAAK,CAApN;AACA,QAAIgP,WAAW,GAAG,CAACH,YAAY,GAAGjB,KAAK,CAACqB,KAAtB,MAAiC,IAAjC,IAAyCJ,YAAY,KAAK,KAAK,CAA/D,GAAmEA,YAAnE,GAAkFjB,KAAK,CAACvO,IAA1G;AACA,QAAI+O,UAAU,GAAG1N,aAAa,CAACkN,KAAD,EAAQ7G,SAAR,CAA9B,CANyH,CAMvE;AAClD;;AAEA,QAAI0G,WAAW,GAAG,KAAK5K,OAAL,CAAa0G,GAAb,CAAiB6C,QAAjB,CAAlB;;AAEA,MAAEqB,WAAW,IAAI,IAAjB,IAAyBxI,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,yEAAyE,gBAAjF,EAAmGoM,QAAnG,CAAjD,GAAgKpM,SAAS,CAAC,KAAD,CAAlM,GAA4M,KAAK,CAAjN;AACA,QAAIqM,YAAY,GAAGoB,WAAW,CAACZ,MAA/B;AAAA,QACI7D,aAAa,GAAGyE,WAAW,CAACzE,aADhC,CAZyH,CAa1E;AAC/C;AACA;;AAEA,QAAImF,OAAO,GAAGvO,iBAAiB,CAACsP,kBAAlB,CAAqC7C,YAArC,EAAmD+B,UAAnD,CAAd;AACA,MAAED,OAAO,IAAI,IAAb,IAAqBlJ,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,wEAAwE,oBAAhF,EAAsGoM,QAAtG,EAAgHwB,KAAK,CAACvO,IAAtH,CAAjD,GAA+KW,SAAS,CAAC,KAAD,CAA7M,GAAuN,KAAK,CAA5N,CAlByH,CAkBsG;;AAE/N,QAAImP,cAAc,GAAGtG,IAAI,CAACA,IAAI,CAAC7L,MAAL,GAAc,CAAf,CAAzB;AACA,QAAIkR,SAAS,GAAGkB,QAAQ,CAACD,cAAD,EAAiB,EAAjB,CAAxB;AACA,MAAEjB,SAAS,KAAKiB,cAAd,IAAgCjB,SAAS,IAAI,CAA/C,IAAoDjJ,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,mEAAmE,kCAA3E,EAA+GmP,cAA/G,CAAjD,GAAkLnP,SAAS,CAAC,KAAD,CAA/O,GAAyP,KAAK,CAA9P;AACA,QAAI+J,QAAQ,GAAG,CAAC+E,mBAAmB,GAAGlB,KAAK,CAACyB,YAA7B,MAA+C,IAA/C,IAAuDP,mBAAmB,KAAK,KAAK,CAApF,GAAwFA,mBAAxF,GAA8G9K,IAAI,CAACvD,YAAD,CAAjI;AACA,MAAE,OAAOsJ,QAAP,KAAoB,QAAtB,IAAkC9E,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,mEAAmE,aAA3E,EAA0F4N,KAAK,CAACvO,IAAhG,CAAjD,GAAyJW,SAAS,CAAC,KAAD,CAApM,GAA8M,KAAK,CAAnN,CAxByH,CAwB6F;AACtN;;AAEA,QAAIiO,MAAM,GAAG;AACb;AACA,KAAC,CAACc,gBAAgB,GAAG,KAAKlN,UAAL,CAAgBmC,IAAhB,EAAsB+F,QAAtB,CAApB,MAAyD,IAAzD,IAAiEgF,gBAAgB,KAAK,KAAK,CAA3F,GAA+FA,gBAA/F,GAAkHZ,OAAO,IAAIA,OAAO,CAACD,SAAD,CAArI,KAAqJ;AACrJ9N,IAAAA,gBAAgB,CAACgM,QAAD,EAAWgC,UAAX,EAAuBF,SAAvB,CAHhB;AAIA,MAAE,OAAOD,MAAP,KAAkB,QAApB,IAAgChJ,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,sEAAsE,aAA9E,EAA6FoO,UAA7F,CAAjD,GAA4JpO,SAAS,CAAC,KAAD,CAArM,GAA+M,KAAK,CAApN,CA/ByH,CA+B8F;;AAEvN,QAAI6J,QAAQ,GAAGvJ,2BAA2B,CAACsN,KAAD,EAAQK,MAAR,EAAgBlH,SAAhB,CAA1C,CAjCyH,CAiCnD;AACtE;AACA;;AAEA,QAAI2F,gBAAgB,GAAG9M,iBAAiB,CAAC0P,KAAlB,CAAwBjD,YAAxB,CAAvB;AACA,QAAIkD,OAAO,GAAG,CAAC,GAAGzT,mBAAmB,CAAC,SAAD,CAAvB,EAAoCqS,OAApC,CAAd;AACAoB,IAAAA,OAAO,CAACrB,SAAD,CAAP,GAAqBD,MAArB;AACArO,IAAAA,iBAAiB,CAAC4P,kBAAlB,CAAqC9C,gBAArC,EAAuD0B,UAAvD,EAAmEmB,OAAnE;;AAEA,SAAK1M,OAAL,CAAauC,GAAb,CAAiBgH,QAAjB,EAA2B;AACzBS,MAAAA,MAAM,EAAEH,gBADiB;AAEzB1D,MAAAA,aAAa,EAAEA;AAFU,KAA3B;;AAKA,QAAIuB,YAAY,GAAG5B,iBAAiB,CAACjF,QAAD,EAAWmG,QAAX,EAAqBE,QAArB,EAA+B;AACjEpI,MAAAA,SAAS,EAAE,KAAKE,UADiD;AAEjEgH,MAAAA,IAAI,EAAE,GAAG4G,MAAH,CAAU,CAAC,GAAG3T,mBAAmB,CAAC,SAAD,CAAvB,EAAoC8S,iBAApC,CAAV,EAAkE,CAACI,WAAD,EAAchD,MAAM,CAACkC,SAAD,CAApB,CAAlE,CAF2D;AAGjExM,MAAAA,wBAAwB,EAAE,KAAKI;AAHkC,KAA/B,CAApC;AAKA,WAAO;AACLkH,MAAAA,aAAa,EAAEA,aADV;AAELiF,MAAAA,MAAM,EAAEA,MAFH;AAGLC,MAAAA,SAAS,EAAEA,SAHN;AAILC,MAAAA,OAAO,EAAEA,OAJJ;AAKL5D,MAAAA,YAAY,EAAEA,YALT;AAML6D,MAAAA,UAAU,EAAEA;AANP,KAAP;AAQD,GA5DD;;AA8DAnK,EAAAA,MAAM,CAACmE,uBAAP,GAAiC,SAASA,uBAAT,CAAiCD,aAAjC,EAAgD;AAC/E,QAAI,KAAK7F,iBAAL,IAA0B,IAA1B,IAAkC6F,aAAa,IAAI,IAAnD,IAA2DA,aAAa,CAACnL,MAAd,GAAuB,CAAtF,EAAyF;AACvF,WAAKsF,iBAAL,CAAuBqC,MAAvB,CAA8B,KAAKxC,UAAL,CAAgBiC,OAA9C,EAAuD,IAAIsL,GAAJ,CAAQvH,aAAR,CAAvD;AACD;AACF,GAJD;;AAMAlE,EAAAA,MAAM,CAACa,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;AACtE,QAAI,KAAKxC,iBAAL,IAA0B,IAA9B,EAAoC;AAClC,WAAKA,iBAAL,CAAuBe,QAAvB,CAAgC,KAAKlB,UAAL,CAAgBiC,OAAhD;AACD;AACF,GAJD;;AAMA,SAAOvD,QAAP;AACD,CArgC2B,EAA5B;;AAugCA,SAASiH,yBAAT,CAAmC5B,SAAnC,EAA8C;AAC5C,MAAI6B,uBAAuB,GAAG,EAA9B;AACA,MAAIC,oBAAoB,GAAG,EAA3B;AACA9B,EAAAA,SAAS,CAAChJ,OAAV,CAAkB,UAAUwG,QAAV,EAAoB;AACpC,QAAIA,QAAQ,CAACmF,IAAT,IAAiB,IAAjB,IAAyBnF,QAAQ,CAACwH,KAAT,IAAkB,IAA/C,EAAqD;AACnD,UAAIA,KAAK,GAAGxH,QAAQ,CAACwH,KAArB;AAAA,UACIrC,IAAI,GAAGnF,QAAQ,CAACmF,IADpB;;AAGA,UAAIqC,KAAK,IAAI,IAAT,IAAiBrC,IAAI,IAAI,IAA7B,EAAmC;AACjC,SAAC,KAAD,GAAS5D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,qEAAqE,0DAArE,GAAkI,+DAAlI,GAAoM,WAA5M,CAAjD,GAA4QA,SAAS,CAAC,KAAD,CAA9R,GAAwS,KAAK,CAA7S;AACD;;AAEDgI,MAAAA,oBAAoB,CAACtL,IAArB,CAA0B;AACxBwO,QAAAA,KAAK,EAAEA,KADiB;AAExBrC,QAAAA,IAAI,EAAEA,IAFkB;AAGxBnF,QAAAA,QAAQ,EAAEA;AAHc,OAA1B;AAKD,KAbD,MAaO;AACLqE,MAAAA,uBAAuB,CAACrL,IAAxB,CAA6BgH,QAA7B;AACD;AACF,GAjBD;AAkBA,SAAO,CAACqE,uBAAD,EAA0BC,oBAA1B,CAAP;AACD;;AAED,SAASW,iBAAT,CAA2BjF,QAA3B,EAAqCmG,QAArC,EAA+CE,QAA/C,EAAyD4F,OAAzD,EAAkE;AAChE,MAAIC,qBAAJ;;AAEA,MAAI5L,IAAI,GAAGN,QAAQ,CAACM,IAApB;AAAA,MACIuC,MAAM,GAAG7C,QAAQ,CAAC6C,MADtB;AAEA,MAAItJ,MAAM,GAAG6C,iBAAiB,CAAC2F,MAAlB,EAAb;AACA,MAAIoH,MAAM,GAAGjN,iBAAiB,CAAC6F,MAAlB,CAAyBoE,QAAQ,CAACC,MAAlC,EAA0CC,QAA1C,CAAb;AACA9M,EAAAA,MAAM,CAACmI,GAAP,CAAWyE,QAAQ,CAACC,MAApB,EAA4B+C,MAA5B;AACA,MAAItC,YAAY,GAAGxK,uBAAuB,CAAC8P,SAAxB,CAAkC5S,MAAlC,EAA0C4M,QAA1C,EAAoD7F,IAApD,EAA0D2L,OAA1D,CAAnB;AACA,SAAO/S,aAAa,CAAC,EAAD,EAAK2N,YAAL,EAAmB;AACrChE,IAAAA,MAAM,EAAEA,MAD6B;AAErCkB,IAAAA,OAAO,EAAE,CAAC,CAACmI,qBAAqB,GAAGlM,QAAQ,CAAC2C,UAAlC,MAAkD,IAAlD,IAA0DuJ,qBAAqB,KAAK,KAAK,CAAzF,GAA6F,KAAK,CAAlG,GAAsGA,qBAAqB,CAAChI,QAA7H,MAA2I;AAF/G,GAAnB,CAApB;AAID;;AAED,SAASoF,eAAT,CAAyB9O,KAAzB,EAAgC;AAC9B,MAAI4R,eAAJ;;AAEA,SAAO,CAACA,eAAe,GAAGC,IAAI,CAACC,SAAL,CAAe/P,UAAU,CAAC/B,KAAD,CAAzB,CAAnB,MAA0D,IAA1D,IAAkE4R,eAAe,KAAK,KAAK,CAA3F,GAA+FA,eAA/F,GAAiH,EAAxH,CAH8B,CAG8F;AAC7H;;AAED,SAAShH,iCAAT,CAA2CJ,OAA3C,EAAoD;AAClD,MAAIO,uBAAuB,GAAGP,OAAO,CAACO,uBAAtC;;AAEA,MAAIA,uBAAuB,IAAI,IAA3B,IAAmCA,uBAAuB,CAACjM,MAAxB,KAAmC,CAA1E,EAA6E;AAC3E,KAAC,KAAD,GAASiI,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCnF,SAAS,CAAC,KAAD,EAAQ,uEAAuE,6DAAvE,GAAuI,mCAA/I,CAAjD,GAAuOA,SAAS,CAAC,KAAD,CAAzP,GAAmQ,KAAK,CAAxQ;AACD;AACF;;AAEDiQ,MAAM,CAACC,OAAP,GAAiB;AACfvP,EAAAA,OAAO,EAAEA;AADM,CAAjB","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar RelayError = require('../util/RelayError');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayObservable = require('../network/RelayObservable');\n\nvar RelayRecordSource = require('./RelayRecordSource');\n\nvar RelayResponseNormalizer = require('./RelayResponseNormalizer');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar stableCopy = require('../util/stableCopy');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require2.createNormalizationSelector;\n\nvar _require3 = require('./RelayStoreUtils'),\n    ROOT_TYPE = _require3.ROOT_TYPE,\n    TYPENAME_KEY = _require3.TYPENAME_KEY,\n    getStorageKey = _require3.getStorageKey;\n\nfunction execute(config) {\n  return new Executor(config);\n}\n/**\n * Coordinates the execution of a query, handling network callbacks\n * including optimistic payloads, standard payloads, resolution of match\n * dependencies, etc.\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(_ref) {\n    var _this = this;\n\n    var operation = _ref.operation,\n        operationExecutions = _ref.operationExecutions,\n        operationLoader = _ref.operationLoader,\n        optimisticConfig = _ref.optimisticConfig,\n        publishQueue = _ref.publishQueue,\n        scheduler = _ref.scheduler,\n        sink = _ref.sink,\n        source = _ref.source,\n        store = _ref.store,\n        updater = _ref.updater,\n        operationTracker = _ref.operationTracker,\n        treatMissingFieldsAsNull = _ref.treatMissingFieldsAsNull,\n        getDataID = _ref.getDataID,\n        isClientPayload = _ref.isClientPayload;\n    this._getDataID = getDataID;\n    this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;\n    this._incrementalPayloadsPending = false;\n    this._incrementalResults = new Map();\n    this._nextSubscriptionId = 0;\n    this._operation = operation;\n    this._operationExecutions = operationExecutions;\n    this._operationLoader = operationLoader;\n    this._operationTracker = operationTracker;\n    this._operationUpdateEpochs = new Map();\n    this._optimisticUpdates = null;\n    this._pendingModulePayloadsCount = 0;\n    this._publishQueue = publishQueue;\n    this._scheduler = scheduler;\n    this._sink = sink;\n    this._source = new Map();\n    this._state = 'started';\n    this._store = store;\n    this._subscriptions = new Map();\n    this._updater = updater;\n    this._isClientPayload = isClientPayload === true;\n    var id = this._nextSubscriptionId++;\n    source.subscribe({\n      complete: function complete() {\n        return _this._complete(id);\n      },\n      error: function error(_error2) {\n        return _this._error(_error2);\n      },\n      next: function next(response) {\n        try {\n          _this._next(id, response);\n        } catch (error) {\n          sink.error(error);\n        }\n      },\n      start: function start(subscription) {\n        return _this._start(id, subscription);\n      }\n    });\n\n    if (optimisticConfig != null) {\n      this._processOptimisticResponse(optimisticConfig.response != null ? {\n        data: optimisticConfig.response\n      } : null, optimisticConfig.updater, false);\n    }\n  } // Cancel any pending execution tasks and mark the executor as completed.\n\n\n  var _proto = Executor.prototype;\n\n  _proto.cancel = function cancel() {\n    var _this2 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    this._state = 'completed';\n\n    this._operationExecutions[\"delete\"](this._operation.request.identifier);\n\n    if (this._subscriptions.size !== 0) {\n      this._subscriptions.forEach(function (sub) {\n        return sub.unsubscribe();\n      });\n\n      this._subscriptions.clear();\n    }\n\n    var optimisticUpdates = this._optimisticUpdates;\n\n    if (optimisticUpdates !== null) {\n      this._optimisticUpdates = null;\n      optimisticUpdates.forEach(function (update) {\n        return _this2._publishQueue.revertUpdate(update);\n      });\n\n      this._publishQueue.run();\n    }\n\n    this._incrementalResults.clear();\n\n    this._completeOperationTracker();\n  };\n\n  _proto._updateActiveState = function _updateActiveState() {\n    var activeState;\n\n    switch (this._state) {\n      case 'started':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'loading_incremental':\n        {\n          activeState = 'active';\n          break;\n        }\n\n      case 'completed':\n        {\n          activeState = 'inactive';\n          break;\n        }\n\n      case 'loading_final':\n        {\n          activeState = this._pendingModulePayloadsCount > 0 ? 'active' : 'inactive';\n          break;\n        }\n\n      default:\n        this._state;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: invalid executor state.') : invariant(false) : void 0;\n    }\n\n    this._operationExecutions.set(this._operation.request.identifier, activeState);\n  };\n\n  _proto._schedule = function _schedule(task) {\n    var _this3 = this;\n\n    var scheduler = this._scheduler;\n\n    if (scheduler != null) {\n      var _id2 = this._nextSubscriptionId++;\n\n      RelayObservable.create(function (sink) {\n        var cancellationToken = scheduler.schedule(function () {\n          try {\n            task();\n            sink.complete();\n          } catch (error) {\n            sink.error(error);\n          }\n        });\n        return function () {\n          return scheduler.cancel(cancellationToken);\n        };\n      }).subscribe({\n        complete: function complete() {\n          return _this3._complete(_id2);\n        },\n        error: function error(_error3) {\n          return _this3._error(_error3);\n        },\n        start: function start(subscription) {\n          return _this3._start(_id2, subscription);\n        }\n      });\n    } else {\n      task();\n    }\n  };\n\n  _proto._complete = function _complete(id) {\n    this._subscriptions[\"delete\"](id);\n\n    if (this._subscriptions.size === 0) {\n      this.cancel();\n\n      this._sink.complete();\n    }\n  };\n\n  _proto._error = function _error(error) {\n    this.cancel();\n\n    this._sink.error(error);\n  };\n\n  _proto._start = function _start(id, subscription) {\n    this._subscriptions.set(id, subscription);\n\n    this._updateActiveState();\n  } // Handle a raw GraphQL response.\n  ;\n\n  _proto._next = function _next(_id, response) {\n    var _this4 = this;\n\n    this._schedule(function () {\n      _this4._handleNext(response);\n\n      _this4._maybeCompleteSubscriptionOperationTracking();\n    });\n  };\n\n  _proto._handleErrorResponse = function _handleErrorResponse(responses) {\n    var _this5 = this;\n\n    var results = [];\n    responses.forEach(function (response) {\n      if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {\n        // Skip extensions-only payloads\n        return;\n      } else if (response.data == null) {\n        // Error if any other payload in the batch is missing data, regardless of whether\n        // it had `errors` or not.\n        var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;\n        var messages = errors ? errors.map(function (_ref2) {\n          var message = _ref2.message;\n          return message;\n        }).join('\\n') : '(No errors)';\n        var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\\n' + messages + '\\n\\nSee the error `source` property for more information.');\n        error.source = {\n          errors: errors,\n          operation: _this5._operation.request.node,\n          variables: _this5._operation.request.variables\n        }; // In V8, Error objects keep the closure scope chain alive until the\n        // err.stack property is accessed.\n\n        error.stack;\n        throw error;\n      } else {\n        var responseWithData = response;\n        results.push(responseWithData);\n      }\n    });\n    return results;\n  }\n  /**\n   * This method return boolean to indicate if the optimistic\n   * response has been handled\n   */\n  ;\n\n  _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {\n    var _response$extensions;\n\n    if (responses.length > 1) {\n      if (responses.some(function (responsePart) {\n        var _responsePart$extensi;\n\n        return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;\n      })) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Optimistic responses cannot be batched.') : invariant(false) : void 0;\n      }\n\n      return false;\n    }\n\n    var response = responses[0];\n    var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;\n\n    if (isOptimistic && this._state !== 'started') {\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: optimistic payload received after server payload.') : invariant(false) : void 0;\n    }\n\n    if (isOptimistic) {\n      this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);\n\n      this._sink.next(response);\n\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto._handleNext = function _handleNext(response) {\n    if (this._state === 'completed') {\n      return;\n    }\n\n    var responses = Array.isArray(response) ? response : [response];\n\n    var responsesWithData = this._handleErrorResponse(responses);\n\n    if (responsesWithData.length === 0) {\n      // no results with data, nothing to process\n      // this can occur with extensions-only payloads\n      var isFinal = responses.some(function (x) {\n        var _x$extensions;\n\n        return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;\n      });\n\n      if (isFinal) {\n        this._state = 'loading_final';\n\n        this._updateActiveState();\n\n        this._incrementalPayloadsPending = false;\n      }\n\n      this._sink.next(response);\n\n      return;\n    } // Next, handle optimistic responses\n\n\n    var isOptimistic = this._handleOptimisticResponses(responsesWithData);\n\n    if (isOptimistic) {\n      return;\n    }\n\n    var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData),\n        nonIncrementalResponses = _partitionGraphQLResp[0],\n        incrementalResponses = _partitionGraphQLResp[1]; // In theory this doesn't preserve the ordering of the batch.\n    // The idea is that a batch is always:\n    //  * at-most one non-incremental payload\n    //  * followed zero or more incremental payloads\n    // The non-incremental payload can appear if the server sends a batch\n    // w the initial payload followed by some early-to-resolve incremental\n    // payloads (although, can that even happen?)\n\n\n    if (nonIncrementalResponses.length > 0) {\n      var payloadFollowups = this._processResponses(nonIncrementalResponses); // Please note, that we're passing `this._operation` to the publish\n      // queue here, which will later passed to the store (via notify)\n      // to indicate that this is an operation that cause the store to update\n\n\n      var updatedOwners = this._publishQueue.run(this._operation);\n\n      this._updateOperationTracker(updatedOwners);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n\n    if (incrementalResponses.length > 0) {\n      var _payloadFollowups = this._processIncrementalResponses(incrementalResponses); // For the incremental case, we're only handling follow-up responses\n      // for already initiated operation (and we're not passing it to\n      // the run(...) call)\n\n\n      var _updatedOwners = this._publishQueue.run();\n\n      this._updateOperationTracker(_updatedOwners);\n\n      this._processPayloadFollowups(_payloadFollowups);\n    }\n\n    this._sink.next(response);\n  };\n\n  _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {\n    var _this6 = this;\n\n    !(this._optimisticUpdates === null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'environment.execute: only support one optimistic response per ' + 'execute.') : invariant(false) : void 0;\n\n    if (response == null && updater == null) {\n      return;\n    }\n\n    var optimisticUpdates = [];\n\n    if (response) {\n      var payload = normalizeResponse(response, this._operation.root, ROOT_TYPE, {\n        getDataID: this._getDataID,\n        path: [],\n        treatMissingFieldsAsNull: treatMissingFieldsAsNull\n      });\n      validateOptimisticResponsePayload(payload);\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: payload,\n        updater: updater\n      });\n\n      this._processOptimisticFollowups(payload, optimisticUpdates);\n    } else if (updater) {\n      optimisticUpdates.push({\n        operation: this._operation,\n        payload: {\n          errors: null,\n          fieldPayloads: null,\n          incrementalPlaceholders: null,\n          moduleImportPayloads: null,\n          source: RelayRecordSource.create(),\n          isFinal: false\n        },\n        updater: updater\n      });\n    }\n\n    this._optimisticUpdates = optimisticUpdates;\n    optimisticUpdates.forEach(function (update) {\n      return _this6._publishQueue.applyUpdate(update);\n    });\n\n    this._publishQueue.run();\n  };\n\n  _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {\n    if (payload.moduleImportPayloads && payload.moduleImportPayloads.length) {\n      var moduleImportPayloads = payload.moduleImportPayloads;\n      var operationLoader = this._operationLoader;\n      !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n\n      var _iterator = _createForOfIteratorHelper(moduleImportPayloads),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var moduleImportPayload = _step.value;\n          var operation = operationLoader.get(moduleImportPayload.operationReference);\n\n          if (operation == null) {\n            this._processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload);\n          } else {\n            var moduleImportOptimisitcUpdates = this._processOptimisticModuleImport(operation, moduleImportPayload);\n\n            optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisitcUpdates));\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  };\n\n  _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImportPayload, operation) {\n    var selector = createNormalizationSelector(operation, moduleImportPayload.dataID, moduleImportPayload.variables);\n    return normalizeResponse({\n      data: moduleImportPayload.data\n    }, selector, moduleImportPayload.typeName, {\n      getDataID: this._getDataID,\n      path: moduleImportPayload.path,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull\n    });\n  };\n\n  _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(operation, moduleImportPayload) {\n    var optimisticUpdates = [];\n\n    var modulePayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    validateOptimisticResponsePayload(modulePayload);\n    optimisticUpdates.push({\n      operation: this._operation,\n      payload: modulePayload,\n      updater: null\n    });\n\n    this._processOptimisticFollowups(modulePayload, optimisticUpdates);\n\n    return optimisticUpdates;\n  };\n\n  _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(operationLoader, moduleImportPayload) {\n    var _this7 = this;\n\n    operationLoader.load(moduleImportPayload.operationReference).then(function (operation) {\n      if (operation == null || _this7._state !== 'started') {\n        return;\n      }\n\n      var moduleImportOptimisitcUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);\n\n      moduleImportOptimisitcUpdates.forEach(function (update) {\n        return _this7._publishQueue.applyUpdate(update);\n      });\n\n      if (_this7._optimisticUpdates == null) {\n        process.env.NODE_ENV !== \"production\" ? warning(false, 'RelayModernQueryExecutor: Unexpected ModuleImport optimisitc ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : void 0;\n      } else {\n        var _this$_optimisticUpda;\n\n        (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2[\"default\"])(moduleImportOptimisitcUpdates));\n\n        _this7._publishQueue.run();\n      }\n    });\n  };\n\n  _proto._processResponses = function _processResponses(responses) {\n    var _this8 = this;\n\n    if (this._optimisticUpdates !== null) {\n      this._optimisticUpdates.forEach(function (update) {\n        return _this8._publishQueue.revertUpdate(update);\n      });\n\n      this._optimisticUpdates = null;\n    }\n\n    this._incrementalPayloadsPending = false;\n\n    this._incrementalResults.clear();\n\n    this._source.clear();\n\n    return responses.map(function (payloadPart) {\n      var relayPayload = normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {\n        getDataID: _this8._getDataID,\n        treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,\n        path: []\n      });\n\n      _this8._publishQueue.commitPayload(_this8._operation, relayPayload, _this8._updater);\n\n      return relayPayload;\n    });\n  }\n  /**\n   * Handles any follow-up actions for a Relay payload for @match, @defer,\n   * and @stream directives.\n   */\n  ;\n\n  _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {\n    var _this9 = this;\n\n    if (this._state === 'completed') {\n      return;\n    }\n\n    payloads.forEach(function (payload) {\n      var incrementalPlaceholders = payload.incrementalPlaceholders,\n          moduleImportPayloads = payload.moduleImportPayloads,\n          isFinal = payload.isFinal;\n      _this9._state = isFinal ? 'loading_final' : 'loading_incremental';\n\n      _this9._updateActiveState();\n\n      if (isFinal) {\n        _this9._incrementalPayloadsPending = false;\n      }\n\n      if (moduleImportPayloads && moduleImportPayloads.length !== 0) {\n        var operationLoader = _this9._operationLoader;\n        !operationLoader ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected an operationLoader to be ' + 'configured when using `@match`.') : invariant(false) : void 0;\n        moduleImportPayloads.forEach(function (moduleImportPayload) {\n          _this9._processModuleImportPayload(moduleImportPayload, operationLoader);\n        });\n      }\n\n      if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {\n        _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';\n        incrementalPlaceholders.forEach(function (incrementalPlaceholder) {\n          _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);\n        });\n\n        if (_this9._isClientPayload || _this9._state === 'loading_final') {\n          // The query has defer/stream selections that are enabled, but either\n          // the server indicated that this is a \"final\" payload: no incremental\n          // payloads will be delivered, then warn that the query was (likely)\n          // executed on the server in non-streaming mode, with incremental\n          // delivery disabled; or this is a client payload, and there will be\n          // no incremental payload.\n          process.env.NODE_ENV !== \"production\" ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : void 0; // But eagerly process any deferred payloads\n\n          var relayPayloads = [];\n          incrementalPlaceholders.forEach(function (placeholder) {\n            if (placeholder.kind === 'defer') {\n              relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {\n                data: placeholder.data\n              }));\n            }\n          });\n\n          if (relayPayloads.length > 0) {\n            var updatedOwners = _this9._publishQueue.run();\n\n            _this9._updateOperationTracker(updatedOwners);\n\n            _this9._processPayloadFollowups(relayPayloads);\n          }\n        }\n      }\n    });\n  };\n\n  _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {\n    var isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';\n\n    if (!isSubscriptionOperation) {\n      return;\n    }\n\n    if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {\n      this._completeOperationTracker();\n    }\n  }\n  /**\n   * Processes a ModuleImportPayload, asynchronously resolving the normalization\n   * AST and using it to normalize the field data into a RelayResponsePayload.\n   * The resulting payload may contain other incremental payloads (match,\n   * defer, stream, etc); these are handled by calling\n   * `_processPayloadFollowups()`.\n   */\n  ;\n\n  _proto._processModuleImportPayload = function _processModuleImportPayload(moduleImportPayload, operationLoader) {\n    var _this10 = this;\n\n    var syncOperation = operationLoader.get(moduleImportPayload.operationReference);\n\n    if (syncOperation != null) {\n      // If the operation module is available synchronously, normalize the\n      // data synchronously.\n      this._handleModuleImportPayload(moduleImportPayload, syncOperation);\n\n      this._maybeCompleteSubscriptionOperationTracking();\n    } else {\n      // Otherwise load the operation module and schedule a task to normalize\n      // the data when the module is available.\n      var _id3 = this._nextSubscriptionId++;\n\n      this._pendingModulePayloadsCount++;\n\n      var decrementPendingCount = function decrementPendingCount() {\n        _this10._pendingModulePayloadsCount--;\n\n        _this10._maybeCompleteSubscriptionOperationTracking();\n      }; // Observable.from(operationLoader.load()) wouldn't catch synchronous\n      // errors thrown by the load function, which is user-defined. Guard\n      // against that with Observable.from(new Promise(<work>)).\n\n\n      RelayObservable.from(new Promise(function (resolve, reject) {\n        operationLoader.load(moduleImportPayload.operationReference).then(resolve, reject);\n      })).map(function (operation) {\n        if (operation != null) {\n          _this10._schedule(function () {\n            _this10._handleModuleImportPayload(moduleImportPayload, operation);\n          });\n        }\n      }).subscribe({\n        complete: function complete() {\n          _this10._complete(_id3);\n\n          decrementPendingCount();\n        },\n        error: function error(_error4) {\n          _this10._error(_error4);\n\n          decrementPendingCount();\n        },\n        start: function start(subscription) {\n          return _this10._start(_id3, subscription);\n        }\n      });\n    }\n  };\n\n  _proto._handleModuleImportPayload = function _handleModuleImportPayload(moduleImportPayload, operation) {\n    var relayPayload = this._normalizeModuleImport(moduleImportPayload, operation);\n\n    this._publishQueue.commitPayload(this._operation, relayPayload);\n\n    var updatedOwners = this._publishQueue.run();\n\n    this._updateOperationTracker(updatedOwners);\n\n    this._processPayloadFollowups([relayPayload]);\n  }\n  /**\n   * The executor now knows that GraphQL responses are expected for a given\n   * label/path:\n   * - Store the placeholder in order to process any future responses that may\n   *   arrive.\n   * - Then process any responses that had already arrived.\n   *\n   * The placeholder contains the normalization selector, path (for nested\n   * defer/stream), and other metadata used to normalize the incremental\n   * response(s).\n   */\n  ;\n\n  _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {\n    var _relayPayload$fieldPa;\n\n    // Update the label => path => placeholder map\n    var label = placeholder.label,\n        path = placeholder.path;\n    var pathKey = path.map(String).join('.');\n\n    var resultForLabel = this._incrementalResults.get(label);\n\n    if (resultForLabel == null) {\n      resultForLabel = new Map();\n\n      this._incrementalResults.set(label, resultForLabel);\n    }\n\n    var resultForPath = resultForLabel.get(pathKey);\n    var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;\n    resultForLabel.set(pathKey, {\n      kind: 'placeholder',\n      placeholder: placeholder\n    }); // Store references to the parent node to allow detecting concurrent\n    // modifications to the parent before items arrive and to replay\n    // handle field payloads to account for new information on source records.\n\n    var parentID;\n\n    if (placeholder.kind === 'stream') {\n      parentID = placeholder.parentID;\n    } else if (placeholder.kind === 'defer') {\n      parentID = placeholder.selector.dataID;\n    } else {\n      placeholder;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Unsupported incremental placeholder kind `%s`.', placeholder.kind) : invariant(false) : void 0;\n    }\n\n    var parentRecord = relayPayload.source.get(parentID);\n    var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function (fieldPayload) {\n      var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);\n      return (// handlers applied to the streamed field itself\n        fieldPayload.dataID === parentID || // handlers applied to a field on an ancestor object, where\n        // ancestor.field links to the parent record (example: connections)\n        fieldID === parentID\n      );\n    }); // If an incremental payload exists for some id that record should also\n    // exist.\n\n    !(parentRecord != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to exist.', parentID) : invariant(false) : void 0;\n    var nextParentRecord;\n    var nextParentPayloads;\n\n    var previousParentEntry = this._source.get(parentID);\n\n    if (previousParentEntry != null) {\n      // If a previous entry exists, merge the previous/next records and\n      // payloads together.\n      nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);\n      var handlePayloads = new Map();\n\n      var dedupePayload = function dedupePayload(payload) {\n        var key = stableStringify(payload);\n        handlePayloads.set(key, payload);\n      };\n\n      previousParentEntry.fieldPayloads.forEach(dedupePayload);\n      parentPayloads.forEach(dedupePayload);\n      nextParentPayloads = Array.from(handlePayloads.values());\n    } else {\n      nextParentRecord = parentRecord;\n      nextParentPayloads = parentPayloads;\n    }\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: nextParentPayloads\n    }); // If there were any queued responses, process them now that placeholders\n    // are in place\n\n\n    if (pendingResponses != null) {\n      var payloadFollowups = this._processIncrementalResponses(pendingResponses);\n\n      var updatedOwners = this._publishQueue.run();\n\n      this._updateOperationTracker(updatedOwners);\n\n      this._processPayloadFollowups(payloadFollowups);\n    }\n  }\n  /**\n   * Lookup the placeholder the describes how to process an incremental\n   * response, normalize/publish it, and process any nested defer/match/stream\n   * metadata.\n   */\n  ;\n\n  _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {\n    var _this11 = this;\n\n    var relayPayloads = [];\n    incrementalResponses.forEach(function (incrementalResponse) {\n      var label = incrementalResponse.label,\n          path = incrementalResponse.path,\n          response = incrementalResponse.response;\n\n      var resultForLabel = _this11._incrementalResults.get(label);\n\n      if (resultForLabel == null) {\n        resultForLabel = new Map();\n\n        _this11._incrementalResults.set(label, resultForLabel);\n      }\n\n      if (label.indexOf('$defer$') !== -1) {\n        var pathKey = path.map(String).join('.');\n        var resultForPath = resultForLabel.get(pathKey);\n\n        if (resultForPath == null) {\n          resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(pathKey, resultForPath);\n          return;\n        } else if (resultForPath.kind === 'response') {\n          resultForPath.responses.push(incrementalResponse);\n          return;\n        }\n\n        var placeholder = resultForPath.placeholder;\n        !(placeholder.kind === 'defer') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));\n      } else {\n        // @stream payload path values end in the field name and item index,\n        // but Relay records paths relative to the parent of the stream node:\n        // therefore we strip the last two elements just to lookup the path\n        // (the item index is used later to insert the element in the list)\n        var _pathKey = path.slice(0, -2).map(String).join('.');\n\n        var _resultForPath = resultForLabel.get(_pathKey);\n\n        if (_resultForPath == null) {\n          _resultForPath = {\n            kind: 'response',\n            responses: [incrementalResponse]\n          };\n          resultForLabel.set(_pathKey, _resultForPath);\n          return;\n        } else if (_resultForPath.kind === 'response') {\n          _resultForPath.responses.push(incrementalResponse);\n\n          return;\n        }\n\n        var _placeholder = _resultForPath.placeholder;\n        !(_placeholder.kind === 'stream') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : invariant(false) : void 0;\n        relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));\n      }\n    });\n    return relayPayloads;\n  };\n\n  _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {\n    var parentID = placeholder.selector.dataID;\n    var relayPayload = normalizeResponse(response, placeholder.selector, placeholder.typeName, {\n      getDataID: this._getDataID,\n      path: placeholder.path,\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull\n    });\n\n    this._publishQueue.commitPayload(this._operation, relayPayload); // Load the version of the parent record from which this incremental data\n    // was derived\n\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var fieldPayloads = parentEntry.fieldPayloads;\n\n    if (fieldPayloads.length !== 0) {\n      var _response$extensions2;\n\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: ((_response$extensions2 = response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  }\n  /**\n   * Process the data for one item in a @stream field.\n   */\n  ;\n\n  _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {\n    var parentID = placeholder.parentID,\n        node = placeholder.node,\n        variables = placeholder.variables; // Find the LinkedField where @stream was applied\n\n    var field = node.selections[0];\n    !(field != null && field.kind === 'LinkedField' && field.plural === true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream to be used on a plural field.') : invariant(false) : void 0;\n\n    var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path),\n        fieldPayloads = _this$_normalizeStrea.fieldPayloads,\n        itemID = _this$_normalizeStrea.itemID,\n        itemIndex = _this$_normalizeStrea.itemIndex,\n        prevIDs = _this$_normalizeStrea.prevIDs,\n        relayPayload = _this$_normalizeStrea.relayPayload,\n        storageKey = _this$_normalizeStrea.storageKey; // Publish the new item and update the parent record to set\n    // field[index] = item *if* the parent record hasn't been concurrently\n    // modified.\n\n\n    this._publishQueue.commitPayload(this._operation, relayPayload, function (store) {\n      var currentParentRecord = store.get(parentID);\n\n      if (currentParentRecord == null) {\n        // parent has since been deleted, stream data is stale\n        return;\n      }\n\n      var currentItems = currentParentRecord.getLinkedRecords(storageKey);\n\n      if (currentItems == null) {\n        // field has since been deleted, stream data is stale\n        return;\n      }\n\n      if (currentItems.length !== prevIDs.length || currentItems.some(function (currentItem, index) {\n        return prevIDs[index] !== (currentItem && currentItem.getDataID());\n      })) {\n        // field has been modified by something other than this query,\n        // stream data is stale\n        return;\n      } // parent.field has not been concurrently modified:\n      // update `parent.field[index] = item`\n\n\n      var nextItems = (0, _toConsumableArray2[\"default\"])(currentItems);\n      nextItems[itemIndex] = store.get(itemID);\n      currentParentRecord.setLinkedRecords(nextItems, storageKey);\n    }); // Now that the parent record has been updated to include the new item,\n    // also update any handle fields that are derived from the parent record.\n\n\n    if (fieldPayloads.length !== 0) {\n      var handleFieldsRelayPayload = {\n        errors: null,\n        fieldPayloads: fieldPayloads,\n        incrementalPlaceholders: null,\n        moduleImportPayloads: null,\n        source: RelayRecordSource.create(),\n        isFinal: false\n      };\n\n      this._publishQueue.commitPayload(this._operation, handleFieldsRelayPayload);\n    }\n\n    return relayPayload;\n  };\n\n  _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {\n    var _field$alias, _field$concreteType, _this$_getDataID;\n\n    var data = response.data;\n    !(typeof data === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : invariant(false) : void 0;\n    var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, variables); // Load the version of the parent record from which this incremental data\n    // was derived\n\n    var parentEntry = this._source.get(parentID);\n\n    !(parentEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : invariant(false) : void 0;\n    var parentRecord = parentEntry.record,\n        fieldPayloads = parentEntry.fieldPayloads; // Load the field value (items) that were created by *this* query executor\n    // in order to check if there has been any concurrent modifications by some\n    // other operation.\n\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);\n    !(prevIDs != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : invariant(false) : void 0; // Determine the index in the field of the new item\n\n    var finalPathEntry = path[path.length - 1];\n    var itemIndex = parseInt(finalPathEntry, 10);\n    !(itemIndex === finalPathEntry && itemIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : invariant(false) : void 0;\n    var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];\n    !(typeof typeName === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected @stream field `%s` to have a ' + '__typename.', field.name) : invariant(false) : void 0; // Determine the __id of the new item: this must equal the value that would\n    // be assigned had the item not been streamed\n\n    var itemID = // https://github.com/prettier/prettier/issues/6403\n    // prettier-ignore\n    ((_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs && prevIDs[itemIndex]) || // Reuse previously generated client IDs\n    generateClientID(parentID, storageKey, itemIndex);\n    !(typeof itemID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernEnvironment: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0; // Build a selector to normalize the item data with\n\n    var selector = createNormalizationSelector(field, itemID, variables); // Update the cached version of the parent record to reflect the new item:\n    // this is used when subsequent stream payloads arrive to see if there\n    // have been concurrent modifications to the list\n\n    var nextParentRecord = RelayModernRecord.clone(parentRecord);\n    var nextIDs = (0, _toConsumableArray2[\"default\"])(prevIDs);\n    nextIDs[itemIndex] = itemID;\n    RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);\n\n    this._source.set(parentID, {\n      record: nextParentRecord,\n      fieldPayloads: fieldPayloads\n    });\n\n    var relayPayload = normalizeResponse(response, selector, typeName, {\n      getDataID: this._getDataID,\n      path: [].concat((0, _toConsumableArray2[\"default\"])(normalizationPath), [responseKey, String(itemIndex)]),\n      treatMissingFieldsAsNull: this._treatMissingFieldsAsNull\n    });\n    return {\n      fieldPayloads: fieldPayloads,\n      itemID: itemID,\n      itemIndex: itemIndex,\n      prevIDs: prevIDs,\n      relayPayload: relayPayload,\n      storageKey: storageKey\n    };\n  };\n\n  _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {\n    if (this._operationTracker != null && updatedOwners != null && updatedOwners.length > 0) {\n      this._operationTracker.update(this._operation.request, new Set(updatedOwners));\n    }\n  };\n\n  _proto._completeOperationTracker = function _completeOperationTracker() {\n    if (this._operationTracker != null) {\n      this._operationTracker.complete(this._operation.request);\n    }\n  };\n\n  return Executor;\n}();\n\nfunction partitionGraphQLResponses(responses) {\n  var nonIncrementalResponses = [];\n  var incrementalResponses = [];\n  responses.forEach(function (response) {\n    if (response.path != null || response.label != null) {\n      var label = response.label,\n          path = response.path;\n\n      if (label == null || path == null) {\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : invariant(false) : void 0;\n      }\n\n      incrementalResponses.push({\n        label: label,\n        path: path,\n        response: response\n      });\n    } else {\n      nonIncrementalResponses.push(response);\n    }\n  });\n  return [nonIncrementalResponses, incrementalResponses];\n}\n\nfunction normalizeResponse(response, selector, typeName, options) {\n  var _response$extensions3;\n\n  var data = response.data,\n      errors = response.errors;\n  var source = RelayRecordSource.create();\n  var record = RelayModernRecord.create(selector.dataID, typeName);\n  source.set(selector.dataID, record);\n  var relayPayload = RelayResponseNormalizer.normalize(source, selector, data, options);\n  return _objectSpread({}, relayPayload, {\n    errors: errors,\n    isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true\n  });\n}\n\nfunction stableStringify(value) {\n  var _JSON$stringify;\n\n  return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : ''; // null-check for flow\n}\n\nfunction validateOptimisticResponsePayload(payload) {\n  var incrementalPlaceholders = payload.incrementalPlaceholders;\n\n  if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {\n    !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernQueryExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : invariant(false) : void 0;\n  }\n}\n\nmodule.exports = {\n  execute: execute\n};"]},"metadata":{},"sourceType":"script"}