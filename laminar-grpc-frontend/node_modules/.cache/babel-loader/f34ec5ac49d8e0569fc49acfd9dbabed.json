{"ast":null,"code":"export const isEmpty = value => value == null || value.length === 0;\n\nconst contains = (data, item) => {\n  if (!item.value) {\n    return true;\n  }\n\n  return data[item.field].toLowerCase().includes(item.value.toLowerCase());\n};\n\nconst doesNotContain = (data, item) => {\n  if (!item.value) {\n    return true;\n  }\n\n  return !data[item.field].toLowerCase().includes(item.value.toLowerCase());\n};\n\nconst equals = (data, item) => {\n  if (!item.value) {\n    return true;\n  }\n\n  return data[item.field].toString().toLowerCase() === item.value.toString().toLowerCase();\n};\n\nconst isNotEqual = (data, item) => {\n  if (!item.value) {\n    return true;\n  }\n\n  return data[item.field].toString().toLowerCase() !== item.value.toString().toLowerCase();\n};\n\nconst more = (data, item) => data[item.field] > item.value;\n\nconst less = (data, item) => data[item.field] < item.value;\n\nexport const filterItem = (data, filter) => {\n  switch (filter.operator) {\n    case 'contains':\n      return contains(data, filter);\n\n    case 'doesNotContain':\n      return doesNotContain(data, filter);\n\n    case '=':\n      return equals(data, filter);\n\n    case '<>':\n      return isNotEqual(data, filter);\n\n    case '>':\n      return more(data, filter);\n\n    case '<':\n      return less(data, filter);\n\n    default:\n      throw Error('unknown operator');\n  }\n};\nexport const filterGroup = (data, groupName, items) => groupName.toLowerCase() === 'or' ? filterGroupOr(data, items) : filterGroupAnd(data, items);\nexport const filterGroupOr = (data, items) => {\n  const filteredData = items.reduce((initialData, item) => {\n    if (item.items) {\n      const grouped = filterGroup(data, item.groupName, item.items);\n      return initialData.concat(grouped.filter(d => initialData.indexOf(d) < 0));\n    }\n\n    return initialData.concat(data.filter(d => initialData.indexOf(d) < 0 && filterItem(d, item)));\n  }, []);\n  return data.filter(d => filteredData.includes(d));\n};\nexport const filterGroupAnd = (data, items) => {\n  return items.reduce((initialData, item) => {\n    if (item.items) {\n      return filterGroup(initialData, item.groupName, item.items);\n    }\n\n    return initialData.filter(d => filterItem(d, item));\n  }, data);\n};\nexport const filterData = (data, filterValue) => {\n  return filterGroup(data, filterValue.groupName, filterValue.items);\n};","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/src/FilterData.js"],"names":["isEmpty","value","length","contains","data","item","field","toLowerCase","includes","doesNotContain","equals","toString","isNotEqual","more","less","filterItem","filter","operator","Error","filterGroup","groupName","items","filterGroupOr","filterGroupAnd","filteredData","reduce","initialData","grouped","concat","d","indexOf","filterData","filterValue"],"mappings":"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","sourcesContent":["export const isEmpty = (value) => (value == null || value.length === 0);\n\nconst contains = (data, item) => {\n    if (!item.value) { return true; }\n    return data[item.field].toLowerCase().includes(item.value.toLowerCase());\n};\nconst doesNotContain = (data, item) => {\n    if (!item.value) { return true; }\n    return !data[item.field].toLowerCase().includes(item.value.toLowerCase());\n};\nconst equals = (data, item) => {\n    if (!item.value) { return true; }\n    return data[item.field].toString().toLowerCase() === item.value.toString().toLowerCase();\n};\nconst isNotEqual = (data, item) => {\n    if (!item.value) { return true; }\n    return data[item.field].toString().toLowerCase() !== item.value.toString().toLowerCase();\n};\nconst more = (data, item) => data[item.field] > item.value;\nconst less = (data, item) => data[item.field] < item.value;\nexport const filterItem = (data, filter) => {\n    switch (filter.operator) {\n        case 'contains': return contains(data, filter);\n        case 'doesNotContain': return doesNotContain(data, filter);\n        case '=': return equals(data, filter);\n        case '<>': return isNotEqual(data, filter);\n        case '>': return more(data, filter);\n        case '<': return less(data, filter);\n        default: throw Error('unknown operator');\n    }\n};\n\nexport const filterGroup = (data, groupName, items) =>\n    (groupName.toLowerCase() === 'or' ? filterGroupOr(data, items) : filterGroupAnd(data, items));\n\nexport const filterGroupOr = (data, items) => {\n    const filteredData = items.reduce((initialData, item) => {\n        if (item.items) {\n            const grouped = filterGroup(data, item.groupName, item.items);\n            return initialData.concat(grouped.filter((d) => initialData.indexOf(d) < 0));\n        }\n        return initialData.concat(data.filter((d) => initialData.indexOf(d) < 0 && filterItem(d, item)));\n    }, []);\n    return data.filter((d) => filteredData.includes(d));\n};\n\nexport const filterGroupAnd = (data, items) => {\n    return items.reduce((initialData, item) => {\n        if (item.items) { return filterGroup(initialData, item.groupName, item.items); }\n        return initialData.filter((d) => filterItem(d, item));\n    }, data);\n};\n\nexport const filterData = (data, filterValue) => {\n    return filterGroup(data, filterValue.groupName, filterValue.items);\n};\n"]},"metadata":{},"sourceType":"module"}