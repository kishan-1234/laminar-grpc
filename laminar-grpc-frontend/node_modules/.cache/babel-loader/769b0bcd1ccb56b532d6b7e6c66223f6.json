{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayProfiler = require('../util/RelayProfiler');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('../util/RelayConcreteNode'),\n    CONDITION = _require.CONDITION,\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    DEFER = _require.DEFER,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    LINKED_HANDLE = _require.LINKED_HANDLE,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    SCALAR_HANDLE = _require.SCALAR_HANDLE,\n    STREAM = _require.STREAM,\n    TYPE_DISCRIMINATOR = _require.TYPE_DISCRIMINATOR;\n\nvar _require2 = require('./ClientID'),\n    generateClientID = _require2.generateClientID,\n    isClientID = _require2.isClientID;\n\nvar _require3 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require3.createNormalizationSelector;\n\nvar _require4 = require('./RelayStoreUtils'),\n    getArgumentValues = _require4.getArgumentValues,\n    getHandleStorageKey = _require4.getHandleStorageKey,\n    getModuleComponentKey = _require4.getModuleComponentKey,\n    getModuleOperationKey = _require4.getModuleOperationKey,\n    getStorageKey = _require4.getStorageKey,\n    TYPENAME_KEY = _require4.TYPENAME_KEY,\n    ROOT_ID = _require4.ROOT_ID;\n\nvar _require5 = require('./TypeID'),\n    generateTypeID = _require5.generateTypeID,\n    TYPE_SCHEMA_TYPE = _require5.TYPE_SCHEMA_TYPE;\n/**\n * Normalizes the results of a query and standard GraphQL response, writing the\n * normalized records/fields into the given MutableRecordSource.\n */\n\n\nfunction normalize(recordSource, selector, response, options) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var normalizer = new RelayResponseNormalizer(recordSource, variables, options);\n  return normalizer.normalizeResponse(node, dataID, response);\n}\n/**\n * @private\n *\n * Helper for handling payloads.\n */\n\n\nvar RelayResponseNormalizer = /*#__PURE__*/function () {\n  function RelayResponseNormalizer(recordSource, variables, options) {\n    this._getDataId = options.getDataID;\n    this._handleFieldPayloads = [];\n    this._treatMissingFieldsAsNull = options.treatMissingFieldsAsNull;\n    this._incrementalPlaceholders = [];\n    this._isClientExtension = false;\n    this._isUnmatchedAbstractType = false;\n    this._moduleImportPayloads = [];\n    this._path = options.path ? (0, _toConsumableArray2[\"default\"])(options.path) : [];\n    this._recordSource = recordSource;\n    this._variables = variables;\n  }\n\n  var _proto = RelayResponseNormalizer.prototype;\n\n  _proto.normalizeResponse = function normalizeResponse(node, dataID, data) {\n    var record = this._recordSource.get(dataID);\n\n    !record ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Expected root record `%s` to exist.', dataID) : invariant(false) : void 0;\n\n    this._traverseSelections(node, record, data);\n\n    return {\n      errors: null,\n      fieldPayloads: this._handleFieldPayloads,\n      incrementalPlaceholders: this._incrementalPlaceholders,\n      moduleImportPayloads: this._moduleImportPayloads,\n      source: this._recordSource,\n      isFinal: false\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._getRecordType = function _getRecordType(data) {\n    var typeName = data[TYPENAME_KEY];\n    !(typeName != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Expected a typename for record `%s`.', JSON.stringify(data, null, 2)) : invariant(false) : void 0;\n    return typeName;\n  };\n\n  _proto._traverseSelections = function _traverseSelections(node, record, data) {\n    for (var i = 0; i < node.selections.length; i++) {\n      var selection = node.selections[i];\n\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n        case LINKED_FIELD:\n          this._normalizeField(node, selection, record, data);\n\n          break;\n\n        case CONDITION:\n          var conditionValue = this._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            this._traverseSelections(selection, record, data);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              var _typeName = RelayModernRecord.getType(record);\n\n              if (_typeName === selection.type) {\n                this._traverseSelections(selection, record, data);\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              var implementsInterface = data.hasOwnProperty(abstractKey);\n\n              var _typeName2 = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName2);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              if (typeRecord == null) {\n                typeRecord = RelayModernRecord.create(typeID, TYPE_SCHEMA_TYPE);\n\n                this._recordSource.set(typeID, typeRecord);\n              }\n\n              RelayModernRecord.setValue(typeRecord, abstractKey, implementsInterface);\n\n              if (implementsInterface) {\n                this._traverseSelections(selection, record, data);\n              }\n            } else {\n              // legacy behavior for abstract refinements: always normalize even\n              // if the type doesn't conform, but track if the type matches or not\n              // for determining whether response fields are expected to be present\n              var _implementsInterface = data.hasOwnProperty(abstractKey);\n\n              var parentIsUnmatchedAbstractType = this._isUnmatchedAbstractType;\n              this._isUnmatchedAbstractType = this._isUnmatchedAbstractType || !_implementsInterface;\n\n              this._traverseSelections(selection, record, data);\n\n              this._isUnmatchedAbstractType = parentIsUnmatchedAbstractType;\n            }\n\n            break;\n          }\n\n        case TYPE_DISCRIMINATOR:\n          {\n            if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              var _abstractKey = selection.abstractKey;\n\n              var _implementsInterface2 = data.hasOwnProperty(_abstractKey);\n\n              var _typeName3 = RelayModernRecord.getType(record);\n\n              var _typeID = generateTypeID(_typeName3);\n\n              var _typeRecord = this._recordSource.get(_typeID);\n\n              if (_typeRecord == null) {\n                _typeRecord = RelayModernRecord.create(_typeID, TYPE_SCHEMA_TYPE);\n\n                this._recordSource.set(_typeID, _typeRecord);\n              }\n\n              RelayModernRecord.setValue(_typeRecord, _abstractKey, _implementsInterface2);\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n        case SCALAR_HANDLE:\n          var args = selection.args ? getArgumentValues(selection.args, this._variables) : {};\n          var fieldKey = getStorageKey(selection, this._variables);\n          var handleKey = getHandleStorageKey(selection, this._variables);\n\n          this._handleFieldPayloads.push({\n            args: args,\n            dataID: RelayModernRecord.getDataID(record),\n            fieldKey: fieldKey,\n            handle: selection.handle,\n            handleKey: handleKey,\n            handleArgs: selection.handleArgs ? getArgumentValues(selection.handleArgs, this._variables) : {}\n          });\n\n          break;\n\n        case MODULE_IMPORT:\n          this._normalizeModuleImport(node, selection, record, data);\n\n          break;\n\n        case DEFER:\n          this._normalizeDefer(selection, record, data);\n\n          break;\n\n        case STREAM:\n          this._normalizeStream(selection, record, data);\n\n          break;\n\n        case CLIENT_EXTENSION:\n          var isClientExtension = this._isClientExtension;\n          this._isClientExtension = true;\n\n          this._traverseSelections(selection, record, data);\n\n          this._isClientExtension = isClientExtension;\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n  };\n\n  _proto._normalizeDefer = function _normalizeDefer(defer, record, data) {\n    var isDeferred = defer[\"if\"] === null || this._getVariableValue(defer[\"if\"]);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(typeof isDeferred === 'boolean', 'RelayResponseNormalizer: Expected value for @defer `if` argument to ' + 'be a boolean, got `%s`.', isDeferred) : void 0;\n    }\n\n    if (isDeferred === false) {\n      // If defer is disabled there will be no additional response chunk:\n      // normalize the data already present.\n      this._traverseSelections(defer, record, data);\n    } else {\n      // Otherwise data *for this selection* should not be present: enqueue\n      // metadata to process the subsequent response chunk.\n      this._incrementalPlaceholders.push({\n        kind: 'defer',\n        data: data,\n        label: defer.label,\n        path: (0, _toConsumableArray2[\"default\"])(this._path),\n        selector: createNormalizationSelector(defer, RelayModernRecord.getDataID(record), this._variables),\n        typeName: RelayModernRecord.getType(record)\n      });\n    }\n  };\n\n  _proto._normalizeStream = function _normalizeStream(stream, record, data) {\n    // Always normalize regardless of whether streaming is enabled or not,\n    // this populates the initial array value (including any items when\n    // initial_count > 0).\n    this._traverseSelections(stream, record, data);\n\n    var isStreamed = stream[\"if\"] === null || this._getVariableValue(stream[\"if\"]);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(typeof isStreamed === 'boolean', 'RelayResponseNormalizer: Expected value for @stream `if` argument ' + 'to be a boolean, got `%s`.', isStreamed) : void 0;\n    }\n\n    if (isStreamed === true) {\n      // If streaming is enabled, *also* emit metadata to process any\n      // response chunks that may be delivered.\n      this._incrementalPlaceholders.push({\n        kind: 'stream',\n        label: stream.label,\n        path: (0, _toConsumableArray2[\"default\"])(this._path),\n        parentID: RelayModernRecord.getDataID(record),\n        node: stream,\n        variables: this._variables\n      });\n    }\n  };\n\n  _proto._normalizeModuleImport = function _normalizeModuleImport(parent, moduleImport, record, data) {\n    !(typeof data === 'object' && data) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected data for @module to be an object.') : invariant(false) : void 0;\n    var typeName = RelayModernRecord.getType(record);\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var componentReference = data[componentKey];\n    RelayModernRecord.setValue(record, componentKey, componentReference !== null && componentReference !== void 0 ? componentReference : null);\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n    var operationReference = data[operationKey];\n    RelayModernRecord.setValue(record, operationKey, operationReference !== null && operationReference !== void 0 ? operationReference : null);\n\n    if (operationReference != null) {\n      this._moduleImportPayloads.push({\n        data: data,\n        dataID: RelayModernRecord.getDataID(record),\n        operationReference: operationReference,\n        path: (0, _toConsumableArray2[\"default\"])(this._path),\n        typeName: typeName,\n        variables: this._variables\n      });\n    }\n  };\n\n  _proto._normalizeField = function _normalizeField(parent, selection, record, data) {\n    !(typeof data === 'object' && data) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'writeField(): Expected data for field `%s` to be an object.', selection.name) : invariant(false) : void 0;\n    var responseKey = selection.alias || selection.name;\n    var storageKey = getStorageKey(selection, this._variables);\n    var fieldValue = data[responseKey];\n\n    if (fieldValue == null) {\n      if (fieldValue === undefined) {\n        // Fields may be missing in the response in two main cases:\n        // - Inside a client extension: the server will not generally return\n        //   values for these fields, but a local update may provide them.\n        // - Inside an abstract type refinement where the concrete type does\n        //   not conform to the interface/union.\n        // However an otherwise-required field may also be missing if the server\n        // is configured to skip fields with `null` values, in which case the\n        // client is assumed to be correctly configured with\n        // treatMissingFieldsAsNull=true.\n        var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;\n\n        if (isOptionalField) {\n          // Field not expected to exist regardless of whether the server is pruning null\n          // fields or not.\n          return;\n        } else if (!this._treatMissingFieldsAsNull) {\n          // Not optional and the server is not pruning null fields: field is expected\n          // to be present\n          if (process.env.NODE_ENV !== \"production\") {\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s: %s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload.', responseKey, storageKey) : void 0;\n          }\n\n          return;\n        }\n      }\n\n      if (selection.kind === SCALAR_FIELD && process.env.NODE_ENV !== \"production\") {\n        this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);\n      }\n\n      RelayModernRecord.setValue(record, storageKey, null);\n      return;\n    }\n\n    if (selection.kind === SCALAR_FIELD) {\n      this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);\n\n      RelayModernRecord.setValue(record, storageKey, fieldValue);\n    } else if (selection.kind === LINKED_FIELD) {\n      this._path.push(responseKey);\n\n      if (selection.plural) {\n        this._normalizePluralLink(selection, record, storageKey, fieldValue);\n      } else {\n        this._normalizeLink(selection, record, storageKey, fieldValue);\n      }\n\n      this._path.pop();\n    } else {\n      selection;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s` during normalization.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._normalizeLink = function _normalizeLink(field, record, storageKey, fieldValue) {\n    var _field$concreteType;\n\n    !(typeof fieldValue === 'object' && fieldValue) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an object.', storageKey) : invariant(false) : void 0;\n    var nextID = this._getDataId( // $FlowFixMe[incompatible-variance]\n    fieldValue, // $FlowFixMe[incompatible-variance]\n    (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : this._getRecordType(fieldValue)) || // Reuse previously generated client IDs\n    RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID(RelayModernRecord.getDataID(record), storageKey);\n    !(typeof nextID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected id on field `%s` to be a string.', storageKey) : invariant(false) : void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this._validateConflictingLinkedFieldsWithIdenticalId(record, RelayModernRecord.getLinkedRecordID(record, storageKey), nextID, storageKey);\n    }\n\n    RelayModernRecord.setLinkedRecordID(record, storageKey, nextID);\n\n    var nextRecord = this._recordSource.get(nextID);\n\n    if (!nextRecord) {\n      // $FlowFixMe[incompatible-variance]\n      var _typeName4 = field.concreteType || this._getRecordType(fieldValue);\n\n      nextRecord = RelayModernRecord.create(nextID, _typeName4);\n\n      this._recordSource.set(nextID, nextRecord);\n    } else if (process.env.NODE_ENV !== \"production\") {\n      this._validateRecordType(nextRecord, field, fieldValue);\n    } // $FlowFixMe[incompatible-variance]\n\n\n    this._traverseSelections(field, nextRecord, fieldValue);\n  };\n\n  _proto._normalizePluralLink = function _normalizePluralLink(field, record, storageKey, fieldValue) {\n    var _this = this;\n\n    !Array.isArray(fieldValue) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an array ' + 'of objects.', storageKey) : invariant(false) : void 0;\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n    var nextIDs = [];\n    fieldValue.forEach(function (item, nextIndex) {\n      var _field$concreteType2; // validate response data\n\n\n      if (item == null) {\n        nextIDs.push(item);\n        return;\n      }\n\n      _this._path.push(String(nextIndex));\n\n      !(typeof item === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected elements for field `%s` to be ' + 'objects.', storageKey) : invariant(false) : void 0;\n      var nextID = _this._getDataId( // $FlowFixMe[incompatible-variance]\n      item, // $FlowFixMe[incompatible-variance]\n      (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : _this._getRecordType(item)) || prevIDs && prevIDs[nextIndex] || // Reuse previously generated client IDs:\n      generateClientID(RelayModernRecord.getDataID(record), storageKey, nextIndex);\n      !(typeof nextID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0;\n      nextIDs.push(nextID);\n\n      var nextRecord = _this._recordSource.get(nextID);\n\n      if (!nextRecord) {\n        // $FlowFixMe[incompatible-variance]\n        var _typeName5 = field.concreteType || _this._getRecordType(item);\n\n        nextRecord = RelayModernRecord.create(nextID, _typeName5);\n\n        _this._recordSource.set(nextID, nextRecord);\n      } else if (process.env.NODE_ENV !== \"production\") {\n        _this._validateRecordType(nextRecord, field, item);\n      }\n\n      if (prevIDs && process.env.NODE_ENV !== \"production\") {\n        _this._validateConflictingLinkedFieldsWithIdenticalId(record, prevIDs[nextIndex], nextID, storageKey);\n      } // $FlowFixMe[incompatible-variance]\n\n\n      _this._traverseSelections(field, nextRecord, item);\n\n      _this._path.pop();\n    });\n    RelayModernRecord.setLinkedRecordIDs(record, storageKey, nextIDs);\n  }\n  /**\n   * Warns if the type of the record does not match the type of the field/payload.\n   */\n  ;\n\n  _proto._validateRecordType = function _validateRecordType(record, field, payload) {\n    var _field$concreteType3;\n\n    var typeName = (_field$concreteType3 = field.concreteType) !== null && _field$concreteType3 !== void 0 ? _field$concreteType3 : this._getRecordType(payload);\n    var dataID = RelayModernRecord.getDataID(record);\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(dataID) && dataID !== ROOT_ID || RelayModernRecord.getType(record) === typeName, 'RelayResponseNormalizer: Invalid record `%s`. Expected %s to be ' + 'consistent, but the record was assigned conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', dataID, TYPENAME_KEY, RelayModernRecord.getType(record), typeName) : void 0;\n  }\n  /**\n   * Warns if a single response contains conflicting fields with the same id\n   */\n  ;\n\n  _proto._validateConflictingFieldsWithIdenticalId = function _validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue) {\n    if (process.env.NODE_ENV !== \"production\") {\n      var dataID = RelayModernRecord.getDataID(record);\n      var previousValue = RelayModernRecord.getValue(record, storageKey);\n      process.env.NODE_ENV !== \"production\" ? warning(storageKey === TYPENAME_KEY || previousValue === undefined || previousValue === fieldValue, 'RelayResponseNormalizer: Invalid record. The record contains two ' + 'instances of the same id: `%s` with conflicting field, %s and its values: %s and %s. ' + 'If two fields are different but share ' + 'the same id, one field will overwrite the other.', dataID, storageKey, previousValue, fieldValue) : void 0;\n    }\n  }\n  /**\n   * Warns if a single response contains conflicting fields with the same id\n   */\n  ;\n\n  _proto._validateConflictingLinkedFieldsWithIdenticalId = function _validateConflictingLinkedFieldsWithIdenticalId(record, prevID, nextID, storageKey) {\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(prevID === undefined || prevID === nextID, 'RelayResponseNormalizer: Invalid record. The record contains ' + 'references to the conflicting field, %s and its id values: %s and %s. ' + 'We need to make sure that the record the field points ' + 'to remains consistent or one field will overwrite the other.', storageKey, prevID, nextID) : void 0;\n    }\n  };\n\n  return RelayResponseNormalizer;\n}();\n\nvar instrumentedNormalize = RelayProfiler.instrument('RelayResponseNormalizer.normalize', normalize);\nmodule.exports = {\n  normalize: instrumentedNormalize\n};","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js"],"names":["_interopRequireDefault","require","_toConsumableArray2","RelayFeatureFlags","RelayModernRecord","RelayProfiler","invariant","warning","_require","CONDITION","CLIENT_EXTENSION","DEFER","INLINE_FRAGMENT","LINKED_FIELD","LINKED_HANDLE","MODULE_IMPORT","SCALAR_FIELD","SCALAR_HANDLE","STREAM","TYPE_DISCRIMINATOR","_require2","generateClientID","isClientID","_require3","createNormalizationSelector","_require4","getArgumentValues","getHandleStorageKey","getModuleComponentKey","getModuleOperationKey","getStorageKey","TYPENAME_KEY","ROOT_ID","_require5","generateTypeID","TYPE_SCHEMA_TYPE","normalize","recordSource","selector","response","options","dataID","node","variables","normalizer","RelayResponseNormalizer","normalizeResponse","_getDataId","getDataID","_handleFieldPayloads","_treatMissingFieldsAsNull","treatMissingFieldsAsNull","_incrementalPlaceholders","_isClientExtension","_isUnmatchedAbstractType","_moduleImportPayloads","_path","path","_recordSource","_variables","_proto","prototype","data","record","get","process","env","NODE_ENV","_traverseSelections","errors","fieldPayloads","incrementalPlaceholders","moduleImportPayloads","source","isFinal","_getVariableValue","name","hasOwnProperty","_getRecordType","typeName","JSON","stringify","i","selections","length","selection","kind","_normalizeField","conditionValue","condition","passingValue","abstractKey","_typeName","getType","type","ENABLE_PRECISE_TYPE_REFINEMENT","implementsInterface","_typeName2","typeID","typeRecord","create","set","setValue","_implementsInterface","parentIsUnmatchedAbstractType","_abstractKey","_implementsInterface2","_typeName3","_typeID","_typeRecord","args","fieldKey","handleKey","push","handle","handleArgs","_normalizeModuleImport","_normalizeDefer","_normalizeStream","isClientExtension","defer","isDeferred","label","stream","isStreamed","parentID","parent","moduleImport","componentKey","documentName","componentReference","operationKey","operationReference","responseKey","alias","storageKey","fieldValue","undefined","isOptionalField","_validateConflictingFieldsWithIdenticalId","plural","_normalizePluralLink","_normalizeLink","pop","field","_field$concreteType","nextID","concreteType","getLinkedRecordID","_validateConflictingLinkedFieldsWithIdenticalId","setLinkedRecordID","nextRecord","_typeName4","_validateRecordType","_this","Array","isArray","prevIDs","getLinkedRecordIDs","nextIDs","forEach","item","nextIndex","_field$concreteType2","String","_typeName5","setLinkedRecordIDs","payload","_field$concreteType3","previousValue","getValue","prevID","instrumentedNormalize","instrument","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayProfiler = require('../util/RelayProfiler');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('../util/RelayConcreteNode'),\n    CONDITION = _require.CONDITION,\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    DEFER = _require.DEFER,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    LINKED_HANDLE = _require.LINKED_HANDLE,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    SCALAR_HANDLE = _require.SCALAR_HANDLE,\n    STREAM = _require.STREAM,\n    TYPE_DISCRIMINATOR = _require.TYPE_DISCRIMINATOR;\n\nvar _require2 = require('./ClientID'),\n    generateClientID = _require2.generateClientID,\n    isClientID = _require2.isClientID;\n\nvar _require3 = require('./RelayModernSelector'),\n    createNormalizationSelector = _require3.createNormalizationSelector;\n\nvar _require4 = require('./RelayStoreUtils'),\n    getArgumentValues = _require4.getArgumentValues,\n    getHandleStorageKey = _require4.getHandleStorageKey,\n    getModuleComponentKey = _require4.getModuleComponentKey,\n    getModuleOperationKey = _require4.getModuleOperationKey,\n    getStorageKey = _require4.getStorageKey,\n    TYPENAME_KEY = _require4.TYPENAME_KEY,\n    ROOT_ID = _require4.ROOT_ID;\n\nvar _require5 = require('./TypeID'),\n    generateTypeID = _require5.generateTypeID,\n    TYPE_SCHEMA_TYPE = _require5.TYPE_SCHEMA_TYPE;\n\n/**\n * Normalizes the results of a query and standard GraphQL response, writing the\n * normalized records/fields into the given MutableRecordSource.\n */\nfunction normalize(recordSource, selector, response, options) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var normalizer = new RelayResponseNormalizer(recordSource, variables, options);\n  return normalizer.normalizeResponse(node, dataID, response);\n}\n/**\n * @private\n *\n * Helper for handling payloads.\n */\n\n\nvar RelayResponseNormalizer = /*#__PURE__*/function () {\n  function RelayResponseNormalizer(recordSource, variables, options) {\n    this._getDataId = options.getDataID;\n    this._handleFieldPayloads = [];\n    this._treatMissingFieldsAsNull = options.treatMissingFieldsAsNull;\n    this._incrementalPlaceholders = [];\n    this._isClientExtension = false;\n    this._isUnmatchedAbstractType = false;\n    this._moduleImportPayloads = [];\n    this._path = options.path ? (0, _toConsumableArray2[\"default\"])(options.path) : [];\n    this._recordSource = recordSource;\n    this._variables = variables;\n  }\n\n  var _proto = RelayResponseNormalizer.prototype;\n\n  _proto.normalizeResponse = function normalizeResponse(node, dataID, data) {\n    var record = this._recordSource.get(dataID);\n\n    !record ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Expected root record `%s` to exist.', dataID) : invariant(false) : void 0;\n\n    this._traverseSelections(node, record, data);\n\n    return {\n      errors: null,\n      fieldPayloads: this._handleFieldPayloads,\n      incrementalPlaceholders: this._incrementalPlaceholders,\n      moduleImportPayloads: this._moduleImportPayloads,\n      source: this._recordSource,\n      isFinal: false\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._getRecordType = function _getRecordType(data) {\n    var typeName = data[TYPENAME_KEY];\n    !(typeName != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Expected a typename for record `%s`.', JSON.stringify(data, null, 2)) : invariant(false) : void 0;\n    return typeName;\n  };\n\n  _proto._traverseSelections = function _traverseSelections(node, record, data) {\n    for (var i = 0; i < node.selections.length; i++) {\n      var selection = node.selections[i];\n\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n        case LINKED_FIELD:\n          this._normalizeField(node, selection, record, data);\n\n          break;\n\n        case CONDITION:\n          var conditionValue = this._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            this._traverseSelections(selection, record, data);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              var _typeName = RelayModernRecord.getType(record);\n\n              if (_typeName === selection.type) {\n                this._traverseSelections(selection, record, data);\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              var implementsInterface = data.hasOwnProperty(abstractKey);\n\n              var _typeName2 = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName2);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              if (typeRecord == null) {\n                typeRecord = RelayModernRecord.create(typeID, TYPE_SCHEMA_TYPE);\n\n                this._recordSource.set(typeID, typeRecord);\n              }\n\n              RelayModernRecord.setValue(typeRecord, abstractKey, implementsInterface);\n\n              if (implementsInterface) {\n                this._traverseSelections(selection, record, data);\n              }\n            } else {\n              // legacy behavior for abstract refinements: always normalize even\n              // if the type doesn't conform, but track if the type matches or not\n              // for determining whether response fields are expected to be present\n              var _implementsInterface = data.hasOwnProperty(abstractKey);\n\n              var parentIsUnmatchedAbstractType = this._isUnmatchedAbstractType;\n              this._isUnmatchedAbstractType = this._isUnmatchedAbstractType || !_implementsInterface;\n\n              this._traverseSelections(selection, record, data);\n\n              this._isUnmatchedAbstractType = parentIsUnmatchedAbstractType;\n            }\n\n            break;\n          }\n\n        case TYPE_DISCRIMINATOR:\n          {\n            if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              var _abstractKey = selection.abstractKey;\n\n              var _implementsInterface2 = data.hasOwnProperty(_abstractKey);\n\n              var _typeName3 = RelayModernRecord.getType(record);\n\n              var _typeID = generateTypeID(_typeName3);\n\n              var _typeRecord = this._recordSource.get(_typeID);\n\n              if (_typeRecord == null) {\n                _typeRecord = RelayModernRecord.create(_typeID, TYPE_SCHEMA_TYPE);\n\n                this._recordSource.set(_typeID, _typeRecord);\n              }\n\n              RelayModernRecord.setValue(_typeRecord, _abstractKey, _implementsInterface2);\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n        case SCALAR_HANDLE:\n          var args = selection.args ? getArgumentValues(selection.args, this._variables) : {};\n          var fieldKey = getStorageKey(selection, this._variables);\n          var handleKey = getHandleStorageKey(selection, this._variables);\n\n          this._handleFieldPayloads.push({\n            args: args,\n            dataID: RelayModernRecord.getDataID(record),\n            fieldKey: fieldKey,\n            handle: selection.handle,\n            handleKey: handleKey,\n            handleArgs: selection.handleArgs ? getArgumentValues(selection.handleArgs, this._variables) : {}\n          });\n\n          break;\n\n        case MODULE_IMPORT:\n          this._normalizeModuleImport(node, selection, record, data);\n\n          break;\n\n        case DEFER:\n          this._normalizeDefer(selection, record, data);\n\n          break;\n\n        case STREAM:\n          this._normalizeStream(selection, record, data);\n\n          break;\n\n        case CLIENT_EXTENSION:\n          var isClientExtension = this._isClientExtension;\n          this._isClientExtension = true;\n\n          this._traverseSelections(selection, record, data);\n\n          this._isClientExtension = isClientExtension;\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n  };\n\n  _proto._normalizeDefer = function _normalizeDefer(defer, record, data) {\n    var isDeferred = defer[\"if\"] === null || this._getVariableValue(defer[\"if\"]);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(typeof isDeferred === 'boolean', 'RelayResponseNormalizer: Expected value for @defer `if` argument to ' + 'be a boolean, got `%s`.', isDeferred) : void 0;\n    }\n\n    if (isDeferred === false) {\n      // If defer is disabled there will be no additional response chunk:\n      // normalize the data already present.\n      this._traverseSelections(defer, record, data);\n    } else {\n      // Otherwise data *for this selection* should not be present: enqueue\n      // metadata to process the subsequent response chunk.\n      this._incrementalPlaceholders.push({\n        kind: 'defer',\n        data: data,\n        label: defer.label,\n        path: (0, _toConsumableArray2[\"default\"])(this._path),\n        selector: createNormalizationSelector(defer, RelayModernRecord.getDataID(record), this._variables),\n        typeName: RelayModernRecord.getType(record)\n      });\n    }\n  };\n\n  _proto._normalizeStream = function _normalizeStream(stream, record, data) {\n    // Always normalize regardless of whether streaming is enabled or not,\n    // this populates the initial array value (including any items when\n    // initial_count > 0).\n    this._traverseSelections(stream, record, data);\n\n    var isStreamed = stream[\"if\"] === null || this._getVariableValue(stream[\"if\"]);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(typeof isStreamed === 'boolean', 'RelayResponseNormalizer: Expected value for @stream `if` argument ' + 'to be a boolean, got `%s`.', isStreamed) : void 0;\n    }\n\n    if (isStreamed === true) {\n      // If streaming is enabled, *also* emit metadata to process any\n      // response chunks that may be delivered.\n      this._incrementalPlaceholders.push({\n        kind: 'stream',\n        label: stream.label,\n        path: (0, _toConsumableArray2[\"default\"])(this._path),\n        parentID: RelayModernRecord.getDataID(record),\n        node: stream,\n        variables: this._variables\n      });\n    }\n  };\n\n  _proto._normalizeModuleImport = function _normalizeModuleImport(parent, moduleImport, record, data) {\n    !(typeof data === 'object' && data) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected data for @module to be an object.') : invariant(false) : void 0;\n    var typeName = RelayModernRecord.getType(record);\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var componentReference = data[componentKey];\n    RelayModernRecord.setValue(record, componentKey, componentReference !== null && componentReference !== void 0 ? componentReference : null);\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n    var operationReference = data[operationKey];\n    RelayModernRecord.setValue(record, operationKey, operationReference !== null && operationReference !== void 0 ? operationReference : null);\n\n    if (operationReference != null) {\n      this._moduleImportPayloads.push({\n        data: data,\n        dataID: RelayModernRecord.getDataID(record),\n        operationReference: operationReference,\n        path: (0, _toConsumableArray2[\"default\"])(this._path),\n        typeName: typeName,\n        variables: this._variables\n      });\n    }\n  };\n\n  _proto._normalizeField = function _normalizeField(parent, selection, record, data) {\n    !(typeof data === 'object' && data) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'writeField(): Expected data for field `%s` to be an object.', selection.name) : invariant(false) : void 0;\n    var responseKey = selection.alias || selection.name;\n    var storageKey = getStorageKey(selection, this._variables);\n    var fieldValue = data[responseKey];\n\n    if (fieldValue == null) {\n      if (fieldValue === undefined) {\n        // Fields may be missing in the response in two main cases:\n        // - Inside a client extension: the server will not generally return\n        //   values for these fields, but a local update may provide them.\n        // - Inside an abstract type refinement where the concrete type does\n        //   not conform to the interface/union.\n        // However an otherwise-required field may also be missing if the server\n        // is configured to skip fields with `null` values, in which case the\n        // client is assumed to be correctly configured with\n        // treatMissingFieldsAsNull=true.\n        var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;\n\n        if (isOptionalField) {\n          // Field not expected to exist regardless of whether the server is pruning null\n          // fields or not.\n          return;\n        } else if (!this._treatMissingFieldsAsNull) {\n          // Not optional and the server is not pruning null fields: field is expected\n          // to be present\n          if (process.env.NODE_ENV !== \"production\") {\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s: %s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload.', responseKey, storageKey) : void 0;\n          }\n\n          return;\n        }\n      }\n\n      if (selection.kind === SCALAR_FIELD && process.env.NODE_ENV !== \"production\") {\n        this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);\n      }\n\n      RelayModernRecord.setValue(record, storageKey, null);\n      return;\n    }\n\n    if (selection.kind === SCALAR_FIELD) {\n      this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);\n\n      RelayModernRecord.setValue(record, storageKey, fieldValue);\n    } else if (selection.kind === LINKED_FIELD) {\n      this._path.push(responseKey);\n\n      if (selection.plural) {\n        this._normalizePluralLink(selection, record, storageKey, fieldValue);\n      } else {\n        this._normalizeLink(selection, record, storageKey, fieldValue);\n      }\n\n      this._path.pop();\n    } else {\n      selection;\n      !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s` during normalization.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._normalizeLink = function _normalizeLink(field, record, storageKey, fieldValue) {\n    var _field$concreteType;\n\n    !(typeof fieldValue === 'object' && fieldValue) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an object.', storageKey) : invariant(false) : void 0;\n    var nextID = this._getDataId( // $FlowFixMe[incompatible-variance]\n    fieldValue, // $FlowFixMe[incompatible-variance]\n    (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : this._getRecordType(fieldValue)) || // Reuse previously generated client IDs\n    RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID(RelayModernRecord.getDataID(record), storageKey);\n    !(typeof nextID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected id on field `%s` to be a string.', storageKey) : invariant(false) : void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this._validateConflictingLinkedFieldsWithIdenticalId(record, RelayModernRecord.getLinkedRecordID(record, storageKey), nextID, storageKey);\n    }\n\n    RelayModernRecord.setLinkedRecordID(record, storageKey, nextID);\n\n    var nextRecord = this._recordSource.get(nextID);\n\n    if (!nextRecord) {\n      // $FlowFixMe[incompatible-variance]\n      var _typeName4 = field.concreteType || this._getRecordType(fieldValue);\n\n      nextRecord = RelayModernRecord.create(nextID, _typeName4);\n\n      this._recordSource.set(nextID, nextRecord);\n    } else if (process.env.NODE_ENV !== \"production\") {\n      this._validateRecordType(nextRecord, field, fieldValue);\n    } // $FlowFixMe[incompatible-variance]\n\n\n    this._traverseSelections(field, nextRecord, fieldValue);\n  };\n\n  _proto._normalizePluralLink = function _normalizePluralLink(field, record, storageKey, fieldValue) {\n    var _this = this;\n\n    !Array.isArray(fieldValue) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an array ' + 'of objects.', storageKey) : invariant(false) : void 0;\n    var prevIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n    var nextIDs = [];\n    fieldValue.forEach(function (item, nextIndex) {\n      var _field$concreteType2;\n\n      // validate response data\n      if (item == null) {\n        nextIDs.push(item);\n        return;\n      }\n\n      _this._path.push(String(nextIndex));\n\n      !(typeof item === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected elements for field `%s` to be ' + 'objects.', storageKey) : invariant(false) : void 0;\n      var nextID = _this._getDataId( // $FlowFixMe[incompatible-variance]\n      item, // $FlowFixMe[incompatible-variance]\n      (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : _this._getRecordType(item)) || prevIDs && prevIDs[nextIndex] || // Reuse previously generated client IDs:\n      generateClientID(RelayModernRecord.getDataID(record), storageKey, nextIndex);\n      !(typeof nextID === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayResponseNormalizer: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : invariant(false) : void 0;\n      nextIDs.push(nextID);\n\n      var nextRecord = _this._recordSource.get(nextID);\n\n      if (!nextRecord) {\n        // $FlowFixMe[incompatible-variance]\n        var _typeName5 = field.concreteType || _this._getRecordType(item);\n\n        nextRecord = RelayModernRecord.create(nextID, _typeName5);\n\n        _this._recordSource.set(nextID, nextRecord);\n      } else if (process.env.NODE_ENV !== \"production\") {\n        _this._validateRecordType(nextRecord, field, item);\n      }\n\n      if (prevIDs && process.env.NODE_ENV !== \"production\") {\n        _this._validateConflictingLinkedFieldsWithIdenticalId(record, prevIDs[nextIndex], nextID, storageKey);\n      } // $FlowFixMe[incompatible-variance]\n\n\n      _this._traverseSelections(field, nextRecord, item);\n\n      _this._path.pop();\n    });\n    RelayModernRecord.setLinkedRecordIDs(record, storageKey, nextIDs);\n  }\n  /**\n   * Warns if the type of the record does not match the type of the field/payload.\n   */\n  ;\n\n  _proto._validateRecordType = function _validateRecordType(record, field, payload) {\n    var _field$concreteType3;\n\n    var typeName = (_field$concreteType3 = field.concreteType) !== null && _field$concreteType3 !== void 0 ? _field$concreteType3 : this._getRecordType(payload);\n    var dataID = RelayModernRecord.getDataID(record);\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(dataID) && dataID !== ROOT_ID || RelayModernRecord.getType(record) === typeName, 'RelayResponseNormalizer: Invalid record `%s`. Expected %s to be ' + 'consistent, but the record was assigned conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', dataID, TYPENAME_KEY, RelayModernRecord.getType(record), typeName) : void 0;\n  }\n  /**\n   * Warns if a single response contains conflicting fields with the same id\n   */\n  ;\n\n  _proto._validateConflictingFieldsWithIdenticalId = function _validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue) {\n    if (process.env.NODE_ENV !== \"production\") {\n      var dataID = RelayModernRecord.getDataID(record);\n      var previousValue = RelayModernRecord.getValue(record, storageKey);\n      process.env.NODE_ENV !== \"production\" ? warning(storageKey === TYPENAME_KEY || previousValue === undefined || previousValue === fieldValue, 'RelayResponseNormalizer: Invalid record. The record contains two ' + 'instances of the same id: `%s` with conflicting field, %s and its values: %s and %s. ' + 'If two fields are different but share ' + 'the same id, one field will overwrite the other.', dataID, storageKey, previousValue, fieldValue) : void 0;\n    }\n  }\n  /**\n   * Warns if a single response contains conflicting fields with the same id\n   */\n  ;\n\n  _proto._validateConflictingLinkedFieldsWithIdenticalId = function _validateConflictingLinkedFieldsWithIdenticalId(record, prevID, nextID, storageKey) {\n    if (process.env.NODE_ENV !== \"production\") {\n      process.env.NODE_ENV !== \"production\" ? warning(prevID === undefined || prevID === nextID, 'RelayResponseNormalizer: Invalid record. The record contains ' + 'references to the conflicting field, %s and its id values: %s and %s. ' + 'We need to make sure that the record the field points ' + 'to remains consistent or one field will overwrite the other.', storageKey, prevID, nextID) : void 0;\n    }\n  };\n\n  return RelayResponseNormalizer;\n}();\n\nvar instrumentedNormalize = RelayProfiler.instrument('RelayResponseNormalizer.normalize', normalize);\nmodule.exports = {\n  normalize: instrumentedNormalize\n};"]},"metadata":{},"sourceType":"script"}