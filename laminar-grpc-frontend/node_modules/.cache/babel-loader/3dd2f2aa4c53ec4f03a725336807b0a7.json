{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayStoreUtils'),\n    ID_KEY = _require2.ID_KEY,\n    REF_KEY = _require2.REF_KEY,\n    REFS_KEY = _require2.REFS_KEY,\n    TYPENAME_KEY = _require2.TYPENAME_KEY,\n    INVALIDATED_AT_KEY = _require2.INVALIDATED_AT_KEY,\n    ROOT_ID = _require2.ROOT_ID;\n/**\n * @public\n *\n * Low-level record manipulation methods.\n *\n * A note about perf: we use long-hand property access rather than computed\n * properties in this file for speed ie.\n *\n *    const object = {};\n *    object[KEY] = value;\n *    record[storageKey] = object;\n *\n * instead of:\n *\n *    record[storageKey] = {\n *      [KEY]: value,\n *    };\n *\n * The latter gets transformed by Babel into something like:\n *\n *    function _defineProperty(obj, key, value) {\n *      if (key in obj) {\n *        Object.defineProperty(obj, key, {\n *          value: value,\n *          enumerable: true,\n *          configurable: true,\n *          writable: true,\n *        });\n *      } else {\n *        obj[key] = value;\n *      }\n *      return obj;\n *    }\n *\n *    record[storageKey] = _defineProperty({}, KEY, value);\n *\n * A quick benchmark shows that computed property access is an order of\n * magnitude slower (times in seconds for 100,000 iterations):\n *\n *               best     avg     sd\n *    computed 0.02175 0.02292 0.00113\n *      manual 0.00110 0.00123 0.00008\n */\n\n/**\n * @public\n *\n * Clone a record.\n */\n\n\nfunction clone(record) {\n  return _objectSpread({}, record);\n}\n/**\n * @public\n *\n * Copies all fields from `source` to `sink`, excluding `__id` and `__typename`.\n *\n * NOTE: This function does not treat `id` specially. To preserve the id,\n * manually reset it after calling this function. Also note that values are\n * copied by reference and not value; callers should ensure that values are\n * copied on write.\n */\n\n\nfunction copyFields(source, sink) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      if (key !== ID_KEY && key !== TYPENAME_KEY) {\n        sink[key] = source[key];\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Create a new record.\n */\n\n\nfunction create(dataID, typeName) {\n  // See perf note above for why we aren't using computed property access.\n  var record = {};\n  record[ID_KEY] = dataID;\n  record[TYPENAME_KEY] = typeName;\n  return record;\n}\n/**\n * @public\n *\n * Get the record's `id` if available or the client-generated identifier.\n */\n\n\nfunction getDataID(record) {\n  return record[ID_KEY];\n}\n/**\n * @public\n *\n * Get the concrete type of the record.\n */\n\n\nfunction getType(record) {\n  return record[TYPENAME_KEY];\n}\n/**\n * @public\n *\n * Get a scalar (non-link) field value.\n */\n\n\nfunction getValue(record, storageKey) {\n  var value = record[storageKey];\n\n  if (value && typeof value === 'object') {\n    !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : invariant(false) : void 0;\n  }\n\n  return value;\n}\n/**\n * @public\n *\n * Get the value of a field as a reference to another record. Throws if the\n * field has a different type.\n */\n\n\nfunction getLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;\n  return link[REF_KEY];\n}\n/**\n * @public\n *\n * Get the value of a field as a list of references to other records. Throws if\n * the field has a different type.\n */\n\n\nfunction getLinkedRecordIDs(record, storageKey) {\n  var links = record[storageKey];\n\n  if (links == null) {\n    return links;\n  }\n\n  !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.', record[ID_KEY], storageKey, JSON.stringify(links)) : invariant(false) : void 0; // assume items of the array are ids\n\n  return links[REFS_KEY];\n}\n/**\n * @public\n *\n * Returns the epoch at which the record was invalidated, if it\n * ever was; otherwise returns null;\n */\n\n\nfunction getInvalidationEpoch(record) {\n  if (record == null) {\n    return null;\n  }\n\n  var invalidatedAt = record[INVALIDATED_AT_KEY];\n\n  if (typeof invalidatedAt !== 'number') {\n    // If the record has never been invalidated, it isn't stale.\n    return null;\n  }\n\n  return invalidatedAt;\n}\n/**\n * @public\n *\n * Compares the fields of a previous and new record, returning either the\n * previous record if all fields are equal or a new record (with merged fields)\n * if any fields have changed.\n */\n\n\nfunction update(prevRecord, nextRecord) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType, _getType2;\n\n    var prevID = getDataID(prevRecord);\n    var nextID = getDataID(nextRecord);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;\n    var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  var updated = null;\n  var keys = Object.keys(nextRecord);\n\n  for (var ii = 0; ii < keys.length; ii++) {\n    var key = keys[ii];\n\n    if (updated || !areEqual(prevRecord[key], nextRecord[key])) {\n      updated = updated !== null ? updated : _objectSpread({}, prevRecord);\n      updated[key] = nextRecord[key];\n    }\n  }\n\n  return updated !== null ? updated : prevRecord;\n}\n/**\n * @public\n *\n * Returns a new record with the contents of the given records. Fields in the\n * second record will overwrite identical fields in the first record.\n */\n\n\nfunction merge(record1, record2) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType3, _getType4;\n\n    var prevID = getDataID(record1);\n    var nextID = getDataID(record2);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;\n    var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  return Object.assign({}, record1, record2);\n}\n/**\n * @public\n *\n * Prevent modifications to the record. Attempts to call `set*` functions on a\n * frozen record will fatal at runtime.\n */\n\n\nfunction freeze(record) {\n  deepFreeze(record);\n}\n/**\n * @public\n *\n * Set the value of a storageKey to a scalar.\n */\n\n\nfunction setValue(record, storageKey, value) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var prevID = getDataID(record);\n\n    if (storageKey === ID_KEY) {\n      process.env.NODE_ENV !== \"production\" ? warning(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : void 0;\n    } else if (storageKey === TYPENAME_KEY) {\n      var _getType5; // note: coalesce null/undefined to null\n\n\n      var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;\n      var nextType = value !== null && value !== void 0 ? value : null;\n      process.env.NODE_ENV !== \"production\" ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n    }\n  }\n\n  record[storageKey] = value;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record.\n */\n\n\nfunction setLinkedRecordID(record, storageKey, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Set the value of a field to a list of references other records.\n */\n\n\nfunction setLinkedRecordIDs(record, storageKey, linkedIDs) {\n  // See perf note above for why we aren't using computed property access.\n  var links = {};\n  links[REFS_KEY] = linkedIDs;\n  record[storageKey] = links;\n}\n\nmodule.exports = {\n  clone: clone,\n  copyFields: copyFields,\n  create: create,\n  freeze: freeze,\n  getDataID: getDataID,\n  getInvalidationEpoch: getInvalidationEpoch,\n  getLinkedRecordID: getLinkedRecordID,\n  getLinkedRecordIDs: getLinkedRecordIDs,\n  getType: getType,\n  getValue: getValue,\n  merge: merge,\n  setValue: setValue,\n  setLinkedRecordID: setLinkedRecordID,\n  setLinkedRecordIDs: setLinkedRecordIDs,\n  update: update\n};","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/RelayModernRecord.js"],"names":["_interopRequireDefault","require","_defineProperty2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","areEqual","deepFreeze","invariant","warning","_require","isClientID","_require2","ID_KEY","REF_KEY","REFS_KEY","TYPENAME_KEY","INVALIDATED_AT_KEY","ROOT_ID","clone","record","copyFields","sink","hasOwnProperty","create","dataID","typeName","getDataID","getType","getValue","storageKey","value","process","env","NODE_ENV","getLinkedRecordID","link","JSON","stringify","getLinkedRecordIDs","links","Array","isArray","getInvalidationEpoch","invalidatedAt","update","prevRecord","nextRecord","_getType","_getType2","prevID","nextID","prevType","nextType","updated","ii","merge","record1","record2","_getType3","_getType4","assign","freeze","setValue","_getType5","setLinkedRecordID","linkedID","setLinkedRecordIDs","linkedIDs","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayStoreUtils'),\n    ID_KEY = _require2.ID_KEY,\n    REF_KEY = _require2.REF_KEY,\n    REFS_KEY = _require2.REFS_KEY,\n    TYPENAME_KEY = _require2.TYPENAME_KEY,\n    INVALIDATED_AT_KEY = _require2.INVALIDATED_AT_KEY,\n    ROOT_ID = _require2.ROOT_ID;\n\n/**\n * @public\n *\n * Low-level record manipulation methods.\n *\n * A note about perf: we use long-hand property access rather than computed\n * properties in this file for speed ie.\n *\n *    const object = {};\n *    object[KEY] = value;\n *    record[storageKey] = object;\n *\n * instead of:\n *\n *    record[storageKey] = {\n *      [KEY]: value,\n *    };\n *\n * The latter gets transformed by Babel into something like:\n *\n *    function _defineProperty(obj, key, value) {\n *      if (key in obj) {\n *        Object.defineProperty(obj, key, {\n *          value: value,\n *          enumerable: true,\n *          configurable: true,\n *          writable: true,\n *        });\n *      } else {\n *        obj[key] = value;\n *      }\n *      return obj;\n *    }\n *\n *    record[storageKey] = _defineProperty({}, KEY, value);\n *\n * A quick benchmark shows that computed property access is an order of\n * magnitude slower (times in seconds for 100,000 iterations):\n *\n *               best     avg     sd\n *    computed 0.02175 0.02292 0.00113\n *      manual 0.00110 0.00123 0.00008\n */\n\n/**\n * @public\n *\n * Clone a record.\n */\nfunction clone(record) {\n  return _objectSpread({}, record);\n}\n/**\n * @public\n *\n * Copies all fields from `source` to `sink`, excluding `__id` and `__typename`.\n *\n * NOTE: This function does not treat `id` specially. To preserve the id,\n * manually reset it after calling this function. Also note that values are\n * copied by reference and not value; callers should ensure that values are\n * copied on write.\n */\n\n\nfunction copyFields(source, sink) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      if (key !== ID_KEY && key !== TYPENAME_KEY) {\n        sink[key] = source[key];\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Create a new record.\n */\n\n\nfunction create(dataID, typeName) {\n  // See perf note above for why we aren't using computed property access.\n  var record = {};\n  record[ID_KEY] = dataID;\n  record[TYPENAME_KEY] = typeName;\n  return record;\n}\n/**\n * @public\n *\n * Get the record's `id` if available or the client-generated identifier.\n */\n\n\nfunction getDataID(record) {\n  return record[ID_KEY];\n}\n/**\n * @public\n *\n * Get the concrete type of the record.\n */\n\n\nfunction getType(record) {\n  return record[TYPENAME_KEY];\n}\n/**\n * @public\n *\n * Get a scalar (non-link) field value.\n */\n\n\nfunction getValue(record, storageKey) {\n  var value = record[storageKey];\n\n  if (value && typeof value === 'object') {\n    !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : invariant(false) : void 0;\n  }\n\n  return value;\n}\n/**\n * @public\n *\n * Get the value of a field as a reference to another record. Throws if the\n * field has a different type.\n */\n\n\nfunction getLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;\n  return link[REF_KEY];\n}\n/**\n * @public\n *\n * Get the value of a field as a list of references to other records. Throws if\n * the field has a different type.\n */\n\n\nfunction getLinkedRecordIDs(record, storageKey) {\n  var links = record[storageKey];\n\n  if (links == null) {\n    return links;\n  }\n\n  !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.', record[ID_KEY], storageKey, JSON.stringify(links)) : invariant(false) : void 0; // assume items of the array are ids\n\n  return links[REFS_KEY];\n}\n/**\n * @public\n *\n * Returns the epoch at which the record was invalidated, if it\n * ever was; otherwise returns null;\n */\n\n\nfunction getInvalidationEpoch(record) {\n  if (record == null) {\n    return null;\n  }\n\n  var invalidatedAt = record[INVALIDATED_AT_KEY];\n\n  if (typeof invalidatedAt !== 'number') {\n    // If the record has never been invalidated, it isn't stale.\n    return null;\n  }\n\n  return invalidatedAt;\n}\n/**\n * @public\n *\n * Compares the fields of a previous and new record, returning either the\n * previous record if all fields are equal or a new record (with merged fields)\n * if any fields have changed.\n */\n\n\nfunction update(prevRecord, nextRecord) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType, _getType2;\n\n    var prevID = getDataID(prevRecord);\n    var nextID = getDataID(nextRecord);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;\n    var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  var updated = null;\n  var keys = Object.keys(nextRecord);\n\n  for (var ii = 0; ii < keys.length; ii++) {\n    var key = keys[ii];\n\n    if (updated || !areEqual(prevRecord[key], nextRecord[key])) {\n      updated = updated !== null ? updated : _objectSpread({}, prevRecord);\n      updated[key] = nextRecord[key];\n    }\n  }\n\n  return updated !== null ? updated : prevRecord;\n}\n/**\n * @public\n *\n * Returns a new record with the contents of the given records. Fields in the\n * second record will overwrite identical fields in the first record.\n */\n\n\nfunction merge(record1, record2) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType3, _getType4;\n\n    var prevID = getDataID(record1);\n    var nextID = getDataID(record2);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;\n    var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  return Object.assign({}, record1, record2);\n}\n/**\n * @public\n *\n * Prevent modifications to the record. Attempts to call `set*` functions on a\n * frozen record will fatal at runtime.\n */\n\n\nfunction freeze(record) {\n  deepFreeze(record);\n}\n/**\n * @public\n *\n * Set the value of a storageKey to a scalar.\n */\n\n\nfunction setValue(record, storageKey, value) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var prevID = getDataID(record);\n\n    if (storageKey === ID_KEY) {\n      process.env.NODE_ENV !== \"production\" ? warning(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : void 0;\n    } else if (storageKey === TYPENAME_KEY) {\n      var _getType5;\n\n      // note: coalesce null/undefined to null\n      var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;\n      var nextType = value !== null && value !== void 0 ? value : null;\n      process.env.NODE_ENV !== \"production\" ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n    }\n  }\n\n  record[storageKey] = value;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record.\n */\n\n\nfunction setLinkedRecordID(record, storageKey, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Set the value of a field to a list of references other records.\n */\n\n\nfunction setLinkedRecordIDs(record, storageKey, linkedIDs) {\n  // See perf note above for why we aren't using computed property access.\n  var links = {};\n  links[REFS_KEY] = linkedIDs;\n  record[storageKey] = links;\n}\n\nmodule.exports = {\n  clone: clone,\n  copyFields: copyFields,\n  create: create,\n  freeze: freeze,\n  getDataID: getDataID,\n  getInvalidationEpoch: getInvalidationEpoch,\n  getLinkedRecordID: getLinkedRecordID,\n  getLinkedRecordIDs: getLinkedRecordIDs,\n  getType: getType,\n  getValue: getValue,\n  merge: merge,\n  setValue: setValue,\n  setLinkedRecordID: setLinkedRecordID,\n  setLinkedRecordIDs: setLinkedRecordIDs,\n  update: update\n};"]},"metadata":{},"sourceType":"script"}