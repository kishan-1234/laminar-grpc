{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _require = require('relay-runtime'),\n    isRelayModernEnvironment = _require.isRelayModernEnvironment,\n    fetchQuery = _require.__internal.fetchQuery;\n\nvar ReactRelayQueryFetcher = /*#__PURE__*/function () {\n  function ReactRelayQueryFetcher(args) {\n    (0, _defineProperty2[\"default\"])(this, \"_selectionReferences\", []);\n    (0, _defineProperty2[\"default\"])(this, \"_callOnDataChangeWhenSet\", false);\n\n    if (args != null) {\n      this._cacheSelectionReference = args.cacheSelectionReference;\n      this._selectionReferences = args.selectionReferences;\n    }\n  }\n\n  var _proto = ReactRelayQueryFetcher.prototype;\n\n  _proto.getSelectionReferences = function getSelectionReferences() {\n    return {\n      cacheSelectionReference: this._cacheSelectionReference,\n      selectionReferences: this._selectionReferences\n    };\n  };\n\n  _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {\n    if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {\n      if (environment.check(operation).status === 'available') {\n        this._retainCachedOperation(environment, operation);\n\n        return environment.lookup(operation.fragment);\n      }\n    }\n\n    return null;\n  };\n\n  _proto.execute = function execute(_ref) {\n    var _this = this;\n\n    var environment = _ref.environment,\n        operation = _ref.operation,\n        cacheConfig = _ref.cacheConfig,\n        _ref$preservePrevious = _ref.preservePreviousReferences,\n        preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;\n    var reference = environment.retain(operation);\n    var fetchQueryOptions = cacheConfig != null ? {\n      networkCacheConfig: cacheConfig\n    } : {};\n\n    var error = function error() {\n      // We may have partially fulfilled the request, so let the next request\n      // or the unmount dispose of the references.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var complete = function complete() {\n      if (!preservePreviousReferences) {\n        _this.disposeSelectionReferences();\n      }\n\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var unsubscribe = function unsubscribe() {\n      // Let the next request or the unmount code dispose of the references.\n      // We may have partially fulfilled the request.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    if (!isRelayModernEnvironment(environment)) {\n      return environment.execute({\n        operation: operation,\n        cacheConfig: cacheConfig\n      })[\"do\"]({\n        error: error,\n        complete: complete,\n        unsubscribe: unsubscribe\n      });\n    }\n\n    return fetchQuery(environment, operation, fetchQueryOptions)[\"do\"]({\n      error: error,\n      complete: complete,\n      unsubscribe: unsubscribe\n    });\n  };\n\n  _proto.setOnDataChange = function setOnDataChange(onDataChange) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : invariant(false) : void 0;\n\n    if (typeof onDataChange === 'function') {\n      // Mutate the most recent fetchOptions in place,\n      // So that in-progress requests can access the updated callback.\n      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];\n\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n\n      if (this._callOnDataChangeWhenSet) {\n        // We don't reset '_callOnDataChangeWhenSet' because another callback may be set\n        if (this._error != null) {\n          onDataChange({\n            error: this._error\n          });\n        } else if (this._snapshot != null) {\n          onDataChange({\n            snapshot: this._snapshot\n          });\n        }\n      }\n    }\n  }\n  /**\n   * `fetch` fetches the data for the given operation.\n   * If a result is immediately available synchronously, it will be synchronously\n   * returned by this function.\n   *\n   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.\n   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),\n   * and then subsequently whenever the data changes.\n   */\n  ;\n\n  _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {\n    var _this2 = this;\n\n    var cacheConfig = fetchOptions.cacheConfig,\n        environment = fetchOptions.environment,\n        operation = fetchOptions.operation,\n        onDataChange = fetchOptions.onDataChange;\n    var fetchHasReturned = false;\n\n    var _error;\n\n    this.disposeRequest();\n    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;\n    this._fetchOptions = {\n      cacheConfig: cacheConfig,\n      environment: environment,\n      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],\n      operation: operation\n    };\n\n    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n    }\n\n    var request = this.execute({\n      environment: environment,\n      operation: operation,\n      cacheConfig: cacheConfigOverride !== null && cacheConfigOverride !== void 0 ? cacheConfigOverride : cacheConfig\n    })[\"finally\"](function () {\n      _this2._pendingRequest = null;\n    }).subscribe({\n      next: function next() {\n        // If we received a response,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = null; // Only notify of the first result if `next` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        _this2._onQueryDataAvailable({\n          notifyFirstResult: fetchHasReturned\n        });\n      },\n      error: function error(err) {\n        // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = err;\n        _this2._snapshot = null;\n        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks; // Only notify of error if `error` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        if (fetchHasReturned) {\n          if (onDataChangeCallbacks) {\n            onDataChangeCallbacks.forEach(function (onDataChange) {\n              onDataChange({\n                error: err\n              });\n            });\n          }\n        } else {\n          _error = err;\n        }\n      }\n    });\n    this._pendingRequest = {\n      dispose: function dispose() {\n        request.unsubscribe();\n      }\n    };\n    fetchHasReturned = true;\n\n    if (_error) {\n      throw _error;\n    }\n\n    return this._snapshot;\n  };\n\n  _proto.retry = function retry(cacheConfigOverride) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : invariant(false) : void 0;\n    return this.fetch({\n      cacheConfig: this._fetchOptions.cacheConfig,\n      environment: this._fetchOptions.environment,\n      operation: this._fetchOptions.operation,\n      onDataChange: null // If there are onDataChangeCallbacks they will be reused\n\n    }, cacheConfigOverride);\n  };\n\n  _proto.dispose = function dispose() {\n    this.disposeRequest();\n    this.disposeSelectionReferences();\n  };\n\n  _proto.disposeRequest = function disposeRequest() {\n    this._error = null;\n    this._snapshot = null; // order is important, dispose of pendingFetch before selectionReferences\n\n    if (this._pendingRequest) {\n      this._pendingRequest.dispose();\n    }\n\n    if (this._rootSubscription) {\n      this._rootSubscription.dispose();\n\n      this._rootSubscription = null;\n    }\n  };\n\n  _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {\n    this._disposeCacheSelectionReference();\n\n    this._cacheSelectionReference = environment.retain(operation);\n  };\n\n  _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {\n    this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n    this._cacheSelectionReference = null;\n  };\n\n  _proto.disposeSelectionReferences = function disposeSelectionReferences() {\n    this._disposeCacheSelectionReference();\n\n    this._selectionReferences.forEach(function (r) {\n      return r.dispose();\n    });\n\n    this._selectionReferences = [];\n  };\n\n  _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {\n    var _this3 = this;\n\n    var notifyFirstResult = _ref2.notifyFirstResult;\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : invariant(false) : void 0;\n    var _this$_fetchOptions = this._fetchOptions,\n        environment = _this$_fetchOptions.environment,\n        onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks,\n        operation = _this$_fetchOptions.operation; // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n    // multiple times by network layers that support data subscriptions.\n    // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n    if (this._snapshot) {\n      return;\n    }\n\n    this._snapshot = environment.lookup(operation.fragment); // Subscribe to changes in the data of the root fragment\n\n    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {\n      // Read from this._fetchOptions in case onDataChange() was lazily added.\n      if (_this3._fetchOptions != null) {\n        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;\n\n        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {\n          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {\n            return onDataChange({\n              snapshot: snapshot\n            });\n          });\n        }\n      }\n    });\n\n    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {\n      var snapshot = this._snapshot;\n      onDataChangeCallbacks.forEach(function (onDataChange) {\n        return onDataChange({\n          snapshot: snapshot\n        });\n      });\n    }\n  };\n\n  return ReactRelayQueryFetcher;\n}();\n\nmodule.exports = ReactRelayQueryFetcher;","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/react-relay/lib/ReactRelayQueryFetcher.js"],"names":["_interopRequireDefault","require","_defineProperty2","invariant","_require","isRelayModernEnvironment","fetchQuery","__internal","ReactRelayQueryFetcher","args","_cacheSelectionReference","cacheSelectionReference","_selectionReferences","selectionReferences","_proto","prototype","getSelectionReferences","lookupInStore","environment","operation","fetchPolicy","check","status","_retainCachedOperation","lookup","fragment","execute","_ref","_this","cacheConfig","_ref$preservePrevious","preservePreviousReferences","reference","retain","fetchQueryOptions","networkCacheConfig","error","concat","complete","disposeSelectionReferences","unsubscribe","setOnDataChange","onDataChange","_fetchOptions","process","env","NODE_ENV","onDataChangeCallbacks","push","_callOnDataChangeWhenSet","_error","_snapshot","snapshot","fetch","fetchOptions","cacheConfigOverride","_this2","fetchHasReturned","disposeRequest","oldOnDataChangeCallbacks","indexOf","request","_pendingRequest","subscribe","next","_onQueryDataAvailable","notifyFirstResult","err","forEach","dispose","retry","_rootSubscription","_disposeCacheSelectionReference","r","_ref2","_this3","_this$_fetchOptions","maybeNewOnDataChangeCallbacks","Array","isArray","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _require = require('relay-runtime'),\n    isRelayModernEnvironment = _require.isRelayModernEnvironment,\n    fetchQuery = _require.__internal.fetchQuery;\n\nvar ReactRelayQueryFetcher = /*#__PURE__*/function () {\n  function ReactRelayQueryFetcher(args) {\n    (0, _defineProperty2[\"default\"])(this, \"_selectionReferences\", []);\n    (0, _defineProperty2[\"default\"])(this, \"_callOnDataChangeWhenSet\", false);\n\n    if (args != null) {\n      this._cacheSelectionReference = args.cacheSelectionReference;\n      this._selectionReferences = args.selectionReferences;\n    }\n  }\n\n  var _proto = ReactRelayQueryFetcher.prototype;\n\n  _proto.getSelectionReferences = function getSelectionReferences() {\n    return {\n      cacheSelectionReference: this._cacheSelectionReference,\n      selectionReferences: this._selectionReferences\n    };\n  };\n\n  _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {\n    if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {\n      if (environment.check(operation).status === 'available') {\n        this._retainCachedOperation(environment, operation);\n\n        return environment.lookup(operation.fragment);\n      }\n    }\n\n    return null;\n  };\n\n  _proto.execute = function execute(_ref) {\n    var _this = this;\n\n    var environment = _ref.environment,\n        operation = _ref.operation,\n        cacheConfig = _ref.cacheConfig,\n        _ref$preservePrevious = _ref.preservePreviousReferences,\n        preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;\n    var reference = environment.retain(operation);\n    var fetchQueryOptions = cacheConfig != null ? {\n      networkCacheConfig: cacheConfig\n    } : {};\n\n    var error = function error() {\n      // We may have partially fulfilled the request, so let the next request\n      // or the unmount dispose of the references.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var complete = function complete() {\n      if (!preservePreviousReferences) {\n        _this.disposeSelectionReferences();\n      }\n\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var unsubscribe = function unsubscribe() {\n      // Let the next request or the unmount code dispose of the references.\n      // We may have partially fulfilled the request.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    if (!isRelayModernEnvironment(environment)) {\n      return environment.execute({\n        operation: operation,\n        cacheConfig: cacheConfig\n      })[\"do\"]({\n        error: error,\n        complete: complete,\n        unsubscribe: unsubscribe\n      });\n    }\n\n    return fetchQuery(environment, operation, fetchQueryOptions)[\"do\"]({\n      error: error,\n      complete: complete,\n      unsubscribe: unsubscribe\n    });\n  };\n\n  _proto.setOnDataChange = function setOnDataChange(onDataChange) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : invariant(false) : void 0;\n\n    if (typeof onDataChange === 'function') {\n      // Mutate the most recent fetchOptions in place,\n      // So that in-progress requests can access the updated callback.\n      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];\n\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n\n      if (this._callOnDataChangeWhenSet) {\n        // We don't reset '_callOnDataChangeWhenSet' because another callback may be set\n        if (this._error != null) {\n          onDataChange({\n            error: this._error\n          });\n        } else if (this._snapshot != null) {\n          onDataChange({\n            snapshot: this._snapshot\n          });\n        }\n      }\n    }\n  }\n  /**\n   * `fetch` fetches the data for the given operation.\n   * If a result is immediately available synchronously, it will be synchronously\n   * returned by this function.\n   *\n   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.\n   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),\n   * and then subsequently whenever the data changes.\n   */\n  ;\n\n  _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {\n    var _this2 = this;\n\n    var cacheConfig = fetchOptions.cacheConfig,\n        environment = fetchOptions.environment,\n        operation = fetchOptions.operation,\n        onDataChange = fetchOptions.onDataChange;\n    var fetchHasReturned = false;\n\n    var _error;\n\n    this.disposeRequest();\n    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;\n    this._fetchOptions = {\n      cacheConfig: cacheConfig,\n      environment: environment,\n      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],\n      operation: operation\n    };\n\n    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n    }\n\n    var request = this.execute({\n      environment: environment,\n      operation: operation,\n      cacheConfig: cacheConfigOverride !== null && cacheConfigOverride !== void 0 ? cacheConfigOverride : cacheConfig\n    })[\"finally\"](function () {\n      _this2._pendingRequest = null;\n    }).subscribe({\n      next: function next() {\n        // If we received a response,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = null; // Only notify of the first result if `next` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        _this2._onQueryDataAvailable({\n          notifyFirstResult: fetchHasReturned\n        });\n      },\n      error: function error(err) {\n        // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = err;\n        _this2._snapshot = null;\n        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks; // Only notify of error if `error` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        if (fetchHasReturned) {\n          if (onDataChangeCallbacks) {\n            onDataChangeCallbacks.forEach(function (onDataChange) {\n              onDataChange({\n                error: err\n              });\n            });\n          }\n        } else {\n          _error = err;\n        }\n      }\n    });\n    this._pendingRequest = {\n      dispose: function dispose() {\n        request.unsubscribe();\n      }\n    };\n    fetchHasReturned = true;\n\n    if (_error) {\n      throw _error;\n    }\n\n    return this._snapshot;\n  };\n\n  _proto.retry = function retry(cacheConfigOverride) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : invariant(false) : void 0;\n    return this.fetch({\n      cacheConfig: this._fetchOptions.cacheConfig,\n      environment: this._fetchOptions.environment,\n      operation: this._fetchOptions.operation,\n      onDataChange: null // If there are onDataChangeCallbacks they will be reused\n\n    }, cacheConfigOverride);\n  };\n\n  _proto.dispose = function dispose() {\n    this.disposeRequest();\n    this.disposeSelectionReferences();\n  };\n\n  _proto.disposeRequest = function disposeRequest() {\n    this._error = null;\n    this._snapshot = null; // order is important, dispose of pendingFetch before selectionReferences\n\n    if (this._pendingRequest) {\n      this._pendingRequest.dispose();\n    }\n\n    if (this._rootSubscription) {\n      this._rootSubscription.dispose();\n\n      this._rootSubscription = null;\n    }\n  };\n\n  _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {\n    this._disposeCacheSelectionReference();\n\n    this._cacheSelectionReference = environment.retain(operation);\n  };\n\n  _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {\n    this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n    this._cacheSelectionReference = null;\n  };\n\n  _proto.disposeSelectionReferences = function disposeSelectionReferences() {\n    this._disposeCacheSelectionReference();\n\n    this._selectionReferences.forEach(function (r) {\n      return r.dispose();\n    });\n\n    this._selectionReferences = [];\n  };\n\n  _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {\n    var _this3 = this;\n\n    var notifyFirstResult = _ref2.notifyFirstResult;\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : invariant(false) : void 0;\n    var _this$_fetchOptions = this._fetchOptions,\n        environment = _this$_fetchOptions.environment,\n        onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks,\n        operation = _this$_fetchOptions.operation; // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n    // multiple times by network layers that support data subscriptions.\n    // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n    if (this._snapshot) {\n      return;\n    }\n\n    this._snapshot = environment.lookup(operation.fragment); // Subscribe to changes in the data of the root fragment\n\n    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {\n      // Read from this._fetchOptions in case onDataChange() was lazily added.\n      if (_this3._fetchOptions != null) {\n        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;\n\n        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {\n          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {\n            return onDataChange({\n              snapshot: snapshot\n            });\n          });\n        }\n      }\n    });\n\n    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {\n      var snapshot = this._snapshot;\n      onDataChangeCallbacks.forEach(function (onDataChange) {\n        return onDataChange({\n          snapshot: snapshot\n        });\n      });\n    }\n  };\n\n  return ReactRelayQueryFetcher;\n}();\n\nmodule.exports = ReactRelayQueryFetcher;"]},"metadata":{},"sourceType":"script"}