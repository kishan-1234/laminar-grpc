{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar cloneRelayHandleSourceField = require('./cloneRelayHandleSourceField');\n\nvar cloneRelayScalarHandleSourceField = require('./cloneRelayScalarHandleSourceField');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayRecordState'),\n    EXISTENT = _require2.EXISTENT,\n    UNKNOWN = _require2.UNKNOWN;\n\nvar _require3 = require('./TypeID'),\n    generateTypeID = _require3.generateTypeID;\n\nvar CONDITION = RelayConcreteNode.CONDITION,\n    CLIENT_EXTENSION = RelayConcreteNode.CLIENT_EXTENSION,\n    DEFER = RelayConcreteNode.DEFER,\n    FRAGMENT_SPREAD = RelayConcreteNode.FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = RelayConcreteNode.INLINE_FRAGMENT,\n    LINKED_FIELD = RelayConcreteNode.LINKED_FIELD,\n    LINKED_HANDLE = RelayConcreteNode.LINKED_HANDLE,\n    MODULE_IMPORT = RelayConcreteNode.MODULE_IMPORT,\n    SCALAR_FIELD = RelayConcreteNode.SCALAR_FIELD,\n    SCALAR_HANDLE = RelayConcreteNode.SCALAR_HANDLE,\n    STREAM = RelayConcreteNode.STREAM,\n    TYPE_DISCRIMINATOR = RelayConcreteNode.TYPE_DISCRIMINATOR;\nvar getModuleOperationKey = RelayStoreUtils.getModuleOperationKey,\n    getStorageKey = RelayStoreUtils.getStorageKey,\n    getArgumentValues = RelayStoreUtils.getArgumentValues;\n/**\n * Synchronously check whether the records required to fulfill the given\n * `selector` are present in `source`.\n *\n * If a field is missing, it uses the provided handlers to attempt to substitute\n * data. The `target` will store all records that are modified because of a\n * successful substitution.\n *\n * If all records are present, returns `true`, otherwise `false`.\n */\n\nfunction check(source, target, selector, handlers, operationLoader, getDataID) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var checker = new DataChecker(source, target, variables, handlers, operationLoader, getDataID);\n  return checker.check(node, dataID);\n}\n/**\n * @private\n */\n\n\nvar DataChecker = /*#__PURE__*/function () {\n  function DataChecker(source, target, variables, handlers, operationLoader, getDataID) {\n    var mutator = new RelayRecordSourceMutator(source, target);\n    this._mostRecentlyInvalidatedAt = null;\n    this._handlers = handlers;\n    this._mutator = mutator;\n    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;\n    this._recordSourceProxy = new RelayRecordSourceProxy(mutator, getDataID);\n    this._recordWasMissing = false;\n    this._source = source;\n    this._variables = variables;\n  }\n\n  var _proto = DataChecker.prototype;\n\n  _proto.check = function check(node, dataID) {\n    this._traverse(node, dataID);\n\n    return this._recordWasMissing === true ? {\n      status: 'missing',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    } : {\n      status: 'available',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._handleMissing = function _handleMissing() {\n    this._recordWasMissing = true;\n  };\n\n  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {\n    return {\n      args: field.args ? getArgumentValues(field.args, this._variables) : {},\n      // Getting a snapshot of the record state is potentially expensive since\n      // we will need to merge the sink and source records. Since we do not create\n      // any new records in this process, it is probably reasonable to provide\n      // handlers with a copy of the source record.\n      // The only thing that the provided record will not contain is fields\n      // added by previous handlers.\n      record: this._source.get(dataID)\n    };\n  };\n\n  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {\n    if (field.name === 'id' && field.alias == null && isClientID(dataID)) {\n      return undefined;\n    }\n\n    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand.args,\n        record = _this$_getDataForHand.record;\n\n    var _iterator = _createForOfIteratorHelper(this._handlers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var handler = _step.value;\n\n        if (handler.kind === 'scalar') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {\n    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand2.args,\n        record = _this$_getDataForHand2.record;\n\n    var _iterator2 = _createForOfIteratorHelper(this._handlers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n\n        if (handler.kind === 'linked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {\n    var _this = this;\n\n    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand3.args,\n        record = _this$_getDataForHand3.record;\n\n    var _iterator3 = _createForOfIteratorHelper(this._handlers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var handler = _step3.value;\n\n        if (handler.kind === 'pluralLinked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue != null) {\n            var allItemsKnown = newValue.every(function (linkedID) {\n              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;\n            });\n\n            if (allItemsKnown) {\n              return newValue;\n            }\n          } else if (newValue === null) {\n            return null;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._traverse = function _traverse(node, dataID) {\n    var status = this._mutator.getStatus(dataID);\n\n    if (status === UNKNOWN) {\n      this._handleMissing();\n    }\n\n    if (status === EXISTENT) {\n      var record = this._source.get(dataID);\n\n      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);\n\n      if (invalidatedAt != null) {\n        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;\n      }\n\n      this._traverseSelections(node.selections, dataID);\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, dataID) {\n    var _this2 = this;\n\n    selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          _this2._checkScalar(selection, dataID);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            _this2._checkPluralLink(selection, dataID);\n          } else {\n            _this2._checkLink(selection, dataID);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = _this2._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            _this2._traverseSelections(selection.selections, dataID);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only check data if the type exactly matches\n              var typeName = _this2._mutator.getType(dataID);\n\n              if (typeName === selection.type) {\n                _this2._traverseSelections(selection.selections, dataID);\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              // Abstract refinement: check data depending on whether the type\n              // conforms to the interface/union or not:\n              // - Type known to _not_ implement the interface: don't check the selections.\n              // - Type is known _to_ implement the interface: check selections.\n              // - Unknown whether the type implements the interface: don't check the selections\n              //   and treat the data as missing; we do this because the Relay Compiler\n              //   guarantees that the type discriminator will always be fetched.\n              var recordType = _this2._mutator.getType(dataID);\n\n              !(recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n              var typeID = generateTypeID(recordType);\n\n              var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);\n\n              if (implementsInterface === true) {\n                _this2._traverseSelections(selection.selections, dataID);\n              } else if (implementsInterface == null) {\n                // unsure if the type implements the interface: data is\n                // missing so don't bother reading the fragment\n                _this2._handleMissing();\n              } // else false: known to not implement the interface\n\n            } else {\n              // legacy behavior for abstract refinements: always check even\n              // if the type doesn't conform\n              _this2._traverseSelections(selection.selections, dataID);\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n          {\n            // Handles have no selections themselves; traverse the original field\n            // where the handle was set-up instead.\n            var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);\n\n            if (handleField.plural) {\n              _this2._checkPluralLink(handleField, dataID);\n            } else {\n              _this2._checkLink(handleField, dataID);\n            }\n\n            break;\n          }\n\n        case SCALAR_HANDLE:\n          {\n            var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);\n\n            _this2._checkScalar(_handleField, dataID);\n\n            break;\n          }\n\n        case MODULE_IMPORT:\n          _this2._checkModuleImport(selection, dataID);\n\n          break;\n\n        case DEFER:\n        case STREAM:\n          _this2._traverseSelections(selection.selections, dataID);\n\n          break;\n\n        case FRAGMENT_SPREAD:\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0; // $FlowExpectedError[unreachable-code] - we need the break; for OSS linter\n\n          break;\n\n        case CLIENT_EXTENSION:\n          var recordWasMissing = _this2._recordWasMissing;\n\n          _this2._traverseSelections(selection.selections, dataID);\n\n          _this2._recordWasMissing = recordWasMissing;\n          break;\n\n        case TYPE_DISCRIMINATOR:\n          if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n            var _abstractKey = selection.abstractKey;\n\n            var _recordType = _this2._mutator.getType(dataID);\n\n            !(_recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n\n            var _typeID = generateTypeID(_recordType);\n\n            var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);\n\n            if (_implementsInterface == null) {\n              // unsure if the type implements the interface: data is\n              // missing\n              _this2._handleMissing();\n            } // else: if it does or doesn't implement, we don't need to check or skip anything else\n\n          }\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    });\n  };\n\n  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : invariant(false) : void 0;\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n\n    var operationReference = this._mutator.getValue(dataID, operationKey);\n\n    if (operationReference == null) {\n      if (operationReference === undefined) {\n        this._handleMissing();\n      }\n\n      return;\n    }\n\n    var operation = operationLoader.get(operationReference);\n\n    if (operation != null) {\n      this._traverse(operation, dataID);\n    } else {\n      // If the fragment is not available, we assume that the data cannot have been\n      // processed yet and must therefore be missing.\n      this._handleMissing();\n    }\n  };\n\n  _proto._checkScalar = function _checkScalar(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var fieldValue = this._mutator.getValue(dataID, storageKey);\n\n    if (fieldValue === undefined) {\n      fieldValue = this._handleMissingScalarField(field, dataID);\n\n      if (fieldValue !== undefined) {\n        this._mutator.setValue(dataID, storageKey, fieldValue);\n      }\n    }\n  };\n\n  _proto._checkLink = function _checkLink(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID === undefined) {\n      linkedID = this._handleMissingLinkField(field, dataID);\n\n      if (linkedID != null) {\n        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);\n      } else if (linkedID === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedID != null) {\n      this._traverse(field, linkedID);\n    }\n  };\n\n  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {\n    var _this3 = this;\n\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);\n\n    if (linkedIDs === undefined) {\n      linkedIDs = this._handleMissingPluralLinkField(field, dataID);\n\n      if (linkedIDs != null) {\n        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);\n      } else if (linkedIDs === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedIDs) {\n      linkedIDs.forEach(function (linkedID) {\n        if (linkedID != null) {\n          _this3._traverse(field, linkedID);\n        }\n      });\n    }\n  };\n\n  return DataChecker;\n}();\n\nmodule.exports = {\n  check: check\n};","map":{"version":3,"sources":["/Users/gayatri/work/laminar-grpc/frontend/node_modules/relay-runtime/lib/store/DataChecker.js"],"names":["_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","i","F","s","n","length","done","value","e","_e","f","TypeError","it","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","RelayConcreteNode","require","RelayFeatureFlags","RelayModernRecord","RelayRecordSourceMutator","RelayRecordSourceProxy","RelayStoreUtils","cloneRelayHandleSourceField","cloneRelayScalarHandleSourceField","invariant","_require","isClientID","_require2","EXISTENT","UNKNOWN","_require3","generateTypeID","CONDITION","CLIENT_EXTENSION","DEFER","FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","LINKED_HANDLE","MODULE_IMPORT","SCALAR_FIELD","SCALAR_HANDLE","STREAM","TYPE_DISCRIMINATOR","getModuleOperationKey","getStorageKey","getArgumentValues","check","source","target","selector","handlers","operationLoader","getDataID","dataID","node","variables","checker","DataChecker","mutator","_mostRecentlyInvalidatedAt","_handlers","_mutator","_operationLoader","_recordSourceProxy","_recordWasMissing","_source","_variables","_proto","_traverse","status","mostRecentlyInvalidatedAt","_getVariableValue","hasOwnProperty","process","env","NODE_ENV","_handleMissing","_getDataForHandlers","field","args","record","get","_handleMissingScalarField","alias","undefined","_this$_getDataForHand","_iterator","_step","handler","kind","newValue","handle","_handleMissingLinkField","_this$_getDataForHand2","_iterator2","_step2","getStatus","_handleMissingPluralLinkField","_this","_this$_getDataForHand3","_iterator3","_step3","allItemsKnown","every","linkedID","invalidatedAt","getInvalidationEpoch","Math","max","_traverseSelections","selections","_this2","forEach","selection","_checkScalar","plural","_checkPluralLink","_checkLink","conditionValue","condition","passingValue","abstractKey","typeName","getType","type","ENABLE_PRECISE_TYPE_REFINEMENT","recordType","typeID","implementsInterface","getValue","handleField","_handleField","_checkModuleImport","recordWasMissing","_abstractKey","_recordType","_typeID","_implementsInterface","moduleImport","operationKey","documentName","operationReference","operation","storageKey","fieldValue","setValue","getLinkedRecordID","setLinkedRecordID","_this3","linkedIDs","getLinkedRecordIDs","setLinkedRecordIDs","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar RelayConcreteNode = require('../util/RelayConcreteNode');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar RelayRecordSourceMutator = require('../mutations/RelayRecordSourceMutator');\n\nvar RelayRecordSourceProxy = require('../mutations/RelayRecordSourceProxy');\n\nvar RelayStoreUtils = require('./RelayStoreUtils');\n\nvar cloneRelayHandleSourceField = require('./cloneRelayHandleSourceField');\n\nvar cloneRelayScalarHandleSourceField = require('./cloneRelayScalarHandleSourceField');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayRecordState'),\n    EXISTENT = _require2.EXISTENT,\n    UNKNOWN = _require2.UNKNOWN;\n\nvar _require3 = require('./TypeID'),\n    generateTypeID = _require3.generateTypeID;\n\nvar CONDITION = RelayConcreteNode.CONDITION,\n    CLIENT_EXTENSION = RelayConcreteNode.CLIENT_EXTENSION,\n    DEFER = RelayConcreteNode.DEFER,\n    FRAGMENT_SPREAD = RelayConcreteNode.FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = RelayConcreteNode.INLINE_FRAGMENT,\n    LINKED_FIELD = RelayConcreteNode.LINKED_FIELD,\n    LINKED_HANDLE = RelayConcreteNode.LINKED_HANDLE,\n    MODULE_IMPORT = RelayConcreteNode.MODULE_IMPORT,\n    SCALAR_FIELD = RelayConcreteNode.SCALAR_FIELD,\n    SCALAR_HANDLE = RelayConcreteNode.SCALAR_HANDLE,\n    STREAM = RelayConcreteNode.STREAM,\n    TYPE_DISCRIMINATOR = RelayConcreteNode.TYPE_DISCRIMINATOR;\nvar getModuleOperationKey = RelayStoreUtils.getModuleOperationKey,\n    getStorageKey = RelayStoreUtils.getStorageKey,\n    getArgumentValues = RelayStoreUtils.getArgumentValues;\n/**\n * Synchronously check whether the records required to fulfill the given\n * `selector` are present in `source`.\n *\n * If a field is missing, it uses the provided handlers to attempt to substitute\n * data. The `target` will store all records that are modified because of a\n * successful substitution.\n *\n * If all records are present, returns `true`, otherwise `false`.\n */\n\nfunction check(source, target, selector, handlers, operationLoader, getDataID) {\n  var dataID = selector.dataID,\n      node = selector.node,\n      variables = selector.variables;\n  var checker = new DataChecker(source, target, variables, handlers, operationLoader, getDataID);\n  return checker.check(node, dataID);\n}\n/**\n * @private\n */\n\n\nvar DataChecker = /*#__PURE__*/function () {\n  function DataChecker(source, target, variables, handlers, operationLoader, getDataID) {\n    var mutator = new RelayRecordSourceMutator(source, target);\n    this._mostRecentlyInvalidatedAt = null;\n    this._handlers = handlers;\n    this._mutator = mutator;\n    this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;\n    this._recordSourceProxy = new RelayRecordSourceProxy(mutator, getDataID);\n    this._recordWasMissing = false;\n    this._source = source;\n    this._variables = variables;\n  }\n\n  var _proto = DataChecker.prototype;\n\n  _proto.check = function check(node, dataID) {\n    this._traverse(node, dataID);\n\n    return this._recordWasMissing === true ? {\n      status: 'missing',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    } : {\n      status: 'available',\n      mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt\n    };\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : invariant(false) : void 0;\n    return this._variables[name];\n  };\n\n  _proto._handleMissing = function _handleMissing() {\n    this._recordWasMissing = true;\n  };\n\n  _proto._getDataForHandlers = function _getDataForHandlers(field, dataID) {\n    return {\n      args: field.args ? getArgumentValues(field.args, this._variables) : {},\n      // Getting a snapshot of the record state is potentially expensive since\n      // we will need to merge the sink and source records. Since we do not create\n      // any new records in this process, it is probably reasonable to provide\n      // handlers with a copy of the source record.\n      // The only thing that the provided record will not contain is fields\n      // added by previous handlers.\n      record: this._source.get(dataID)\n    };\n  };\n\n  _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {\n    if (field.name === 'id' && field.alias == null && isClientID(dataID)) {\n      return undefined;\n    }\n\n    var _this$_getDataForHand = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand.args,\n        record = _this$_getDataForHand.record;\n\n    var _iterator = _createForOfIteratorHelper(this._handlers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var handler = _step.value;\n\n        if (handler.kind === 'scalar') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {\n    var _this$_getDataForHand2 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand2.args,\n        record = _this$_getDataForHand2.record;\n\n    var _iterator2 = _createForOfIteratorHelper(this._handlers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var handler = _step2.value;\n\n        if (handler.kind === 'linked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {\n            return newValue;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {\n    var _this = this;\n\n    var _this$_getDataForHand3 = this._getDataForHandlers(field, dataID),\n        args = _this$_getDataForHand3.args,\n        record = _this$_getDataForHand3.record;\n\n    var _iterator3 = _createForOfIteratorHelper(this._handlers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var handler = _step3.value;\n\n        if (handler.kind === 'pluralLinked') {\n          var newValue = handler.handle(field, record, args, this._recordSourceProxy);\n\n          if (newValue != null) {\n            var allItemsKnown = newValue.every(function (linkedID) {\n              return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;\n            });\n\n            if (allItemsKnown) {\n              return newValue;\n            }\n          } else if (newValue === null) {\n            return null;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    this._handleMissing();\n  };\n\n  _proto._traverse = function _traverse(node, dataID) {\n    var status = this._mutator.getStatus(dataID);\n\n    if (status === UNKNOWN) {\n      this._handleMissing();\n    }\n\n    if (status === EXISTENT) {\n      var record = this._source.get(dataID);\n\n      var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);\n\n      if (invalidatedAt != null) {\n        this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;\n      }\n\n      this._traverseSelections(node.selections, dataID);\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, dataID) {\n    var _this2 = this;\n\n    selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case SCALAR_FIELD:\n          _this2._checkScalar(selection, dataID);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            _this2._checkPluralLink(selection, dataID);\n          } else {\n            _this2._checkLink(selection, dataID);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = _this2._getVariableValue(selection.condition);\n\n          if (conditionValue === selection.passingValue) {\n            _this2._traverseSelections(selection.selections, dataID);\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only check data if the type exactly matches\n              var typeName = _this2._mutator.getType(dataID);\n\n              if (typeName === selection.type) {\n                _this2._traverseSelections(selection.selections, dataID);\n              }\n            } else if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n              // Abstract refinement: check data depending on whether the type\n              // conforms to the interface/union or not:\n              // - Type known to _not_ implement the interface: don't check the selections.\n              // - Type is known _to_ implement the interface: check selections.\n              // - Unknown whether the type implements the interface: don't check the selections\n              //   and treat the data as missing; we do this because the Relay Compiler\n              //   guarantees that the type discriminator will always be fetched.\n              var recordType = _this2._mutator.getType(dataID);\n\n              !(recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n              var typeID = generateTypeID(recordType);\n\n              var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);\n\n              if (implementsInterface === true) {\n                _this2._traverseSelections(selection.selections, dataID);\n              } else if (implementsInterface == null) {\n                // unsure if the type implements the interface: data is\n                // missing so don't bother reading the fragment\n                _this2._handleMissing();\n              } // else false: known to not implement the interface\n\n            } else {\n              // legacy behavior for abstract refinements: always check even\n              // if the type doesn't conform\n              _this2._traverseSelections(selection.selections, dataID);\n            }\n\n            break;\n          }\n\n        case LINKED_HANDLE:\n          {\n            // Handles have no selections themselves; traverse the original field\n            // where the handle was set-up instead.\n            var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);\n\n            if (handleField.plural) {\n              _this2._checkPluralLink(handleField, dataID);\n            } else {\n              _this2._checkLink(handleField, dataID);\n            }\n\n            break;\n          }\n\n        case SCALAR_HANDLE:\n          {\n            var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);\n\n            _this2._checkScalar(_handleField, dataID);\n\n            break;\n          }\n\n        case MODULE_IMPORT:\n          _this2._checkModuleImport(selection, dataID);\n\n          break;\n\n        case DEFER:\n        case STREAM:\n          _this2._traverseSelections(selection.selections, dataID);\n\n          break;\n\n        case FRAGMENT_SPREAD:\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0; // $FlowExpectedError[unreachable-code] - we need the break; for OSS linter\n\n          break;\n\n        case CLIENT_EXTENSION:\n          var recordWasMissing = _this2._recordWasMissing;\n\n          _this2._traverseSelections(selection.selections, dataID);\n\n          _this2._recordWasMissing = recordWasMissing;\n          break;\n\n        case TYPE_DISCRIMINATOR:\n          if (RelayFeatureFlags.ENABLE_PRECISE_TYPE_REFINEMENT) {\n            var _abstractKey = selection.abstractKey;\n\n            var _recordType = _this2._mutator.getType(dataID);\n\n            !(_recordType != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : invariant(false) : void 0;\n\n            var _typeID = generateTypeID(_recordType);\n\n            var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);\n\n            if (_implementsInterface == null) {\n              // unsure if the type implements the interface: data is\n              // missing\n              _this2._handleMissing();\n            } // else: if it does or doesn't implement, we don't need to check or skip anything else\n\n          }\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    });\n  };\n\n  _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {\n    var operationLoader = this._operationLoader;\n    !(operationLoader !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : invariant(false) : void 0;\n    var operationKey = getModuleOperationKey(moduleImport.documentName);\n\n    var operationReference = this._mutator.getValue(dataID, operationKey);\n\n    if (operationReference == null) {\n      if (operationReference === undefined) {\n        this._handleMissing();\n      }\n\n      return;\n    }\n\n    var operation = operationLoader.get(operationReference);\n\n    if (operation != null) {\n      this._traverse(operation, dataID);\n    } else {\n      // If the fragment is not available, we assume that the data cannot have been\n      // processed yet and must therefore be missing.\n      this._handleMissing();\n    }\n  };\n\n  _proto._checkScalar = function _checkScalar(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var fieldValue = this._mutator.getValue(dataID, storageKey);\n\n    if (fieldValue === undefined) {\n      fieldValue = this._handleMissingScalarField(field, dataID);\n\n      if (fieldValue !== undefined) {\n        this._mutator.setValue(dataID, storageKey, fieldValue);\n      }\n    }\n  };\n\n  _proto._checkLink = function _checkLink(field, dataID) {\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);\n\n    if (linkedID === undefined) {\n      linkedID = this._handleMissingLinkField(field, dataID);\n\n      if (linkedID != null) {\n        this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);\n      } else if (linkedID === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedID != null) {\n      this._traverse(field, linkedID);\n    }\n  };\n\n  _proto._checkPluralLink = function _checkPluralLink(field, dataID) {\n    var _this3 = this;\n\n    var storageKey = getStorageKey(field, this._variables);\n\n    var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);\n\n    if (linkedIDs === undefined) {\n      linkedIDs = this._handleMissingPluralLinkField(field, dataID);\n\n      if (linkedIDs != null) {\n        this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);\n      } else if (linkedIDs === null) {\n        this._mutator.setValue(dataID, storageKey, null);\n      }\n    }\n\n    if (linkedIDs) {\n      linkedIDs.forEach(function (linkedID) {\n        if (linkedID != null) {\n          _this3._traverse(field, linkedID);\n        }\n      });\n    }\n  };\n\n  return DataChecker;\n}();\n\nmodule.exports = {\n  check: check\n};"]},"metadata":{},"sourceType":"script"}