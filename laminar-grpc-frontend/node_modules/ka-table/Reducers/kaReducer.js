var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { newRowId } from '../const';
import { ActionType } from '../enums';
import { kaPropsUtils } from '../utils';
import { getCopyOfArrayAndInsertOrReplaceItem } from '../Utils/ArrayUtils';
import { addItemToEditableCells, removeItemFromEditableCells } from '../Utils/CellUtils';
import { getValueByField, replaceValue } from '../Utils/DataUtils';
import { getExpandedGroups, updateExpandedGroups } from '../Utils/GroupUtils';
import { getSortedColumns } from '../Utils/HeadRowUtils';
import { prepareTableOptions } from '../Utils/PropsUtils';
var addColumnsToRowEditableCells = function (editableCells, columns, rowKeyValue) {
    var newEditableCells = __spreadArrays(editableCells);
    columns.forEach(function (column) {
        if (column.isEditable !== false
            && !newEditableCells.some(function (e) { return e.columnKey === column.key && e.rowKeyValue === rowKeyValue; })) {
            newEditableCells.push({
                columnKey: column.key,
                rowKeyValue: rowKeyValue
            });
        }
    });
    return newEditableCells;
};
var kaReducer = function (props, action) {
    var columns = props.columns, _a = props.data, data = _a === void 0 ? [] : _a, _b = props.detailsRows, detailsRows = _b === void 0 ? [] : _b, _c = props.editableCells, editableCells = _c === void 0 ? [] : _c, groupsExpanded = props.groupsExpanded, loading = props.loading, paging = props.paging, rowKeyField = props.rowKeyField, _d = props.selectedRows, selectedRows = _d === void 0 ? [] : _d, validation = props.validation, virtualScrolling = props.virtualScrolling;
    switch (action.type) {
        case ActionType.ReorderRows: {
            var movedRow_1 = data.find(function (d) { return getValueByField(d, rowKeyField) === action.rowKeyValue; });
            var newData = data.filter(function (d) { return getValueByField(d, rowKeyField) !== getValueByField(movedRow_1, rowKeyField); });
            var targetRowIndex = data.findIndex(function (d) { return getValueByField(d, rowKeyField) === action.targetRowKeyValue; });
            newData.splice(targetRowIndex, 0, movedRow_1);
            return __assign(__assign({}, props), { data: newData });
        }
        case ActionType.ResizeColumn: {
            var columnKey_1 = action.columnKey, width = action.width;
            var column = columns.find(function (c) { return c.key === columnKey_1; });
            var newColumn = __assign(__assign({}, column), { style: __assign(__assign({}, column.style), { width: width }) });
            var newColumns = getCopyOfArrayAndInsertOrReplaceItem(newColumn, 'key', columns);
            return __assign(__assign({}, props), { columns: newColumns });
        }
        case ActionType.UpdatePageIndex: {
            return __assign(__assign({}, props), { paging: __assign(__assign({}, paging), { pageIndex: action.pageIndex }) });
        }
        case ActionType.UpdatePagesCount: {
            return __assign(__assign({}, props), { paging: __assign(__assign({}, paging), { pagesCount: action.pagesCount }) });
        }
        case ActionType.HideLoading: {
            return __assign(__assign({}, props), { loading: __assign(__assign({}, loading), { enabled: false }) });
        }
        case ActionType.ShowLoading: {
            var newLoading = __assign(__assign({}, loading), { enabled: true });
            if (action.text !== undefined) {
                newLoading.text = action.text;
            }
            return __assign(__assign({}, props), { loading: newLoading });
        }
        case ActionType.ShowDetailsRow: {
            var newDetailsRows = __spreadArrays(detailsRows);
            newDetailsRows.push(action.rowKeyValue);
            return __assign(__assign({}, props), { detailsRows: newDetailsRows });
        }
        case ActionType.HideDetailsRow: {
            var newDetailsRows = detailsRows.filter(function (row) { return row !== action.rowKeyValue; });
            return __assign(__assign({}, props), { detailsRows: newDetailsRows });
        }
        case ActionType.OpenEditor: {
            var newEditableCells = addItemToEditableCells(action, editableCells);
            return __assign(__assign({}, props), { editableCells: newEditableCells });
        }
        case ActionType.CloseEditor: {
            var newEditableCells = removeItemFromEditableCells(action, editableCells);
            return __assign(__assign({}, props), { editableCells: newEditableCells });
        }
        case ActionType.UpdateFilterRowValue: {
            var column = columns.find(function (c) { return c.key === action.columnKey; });
            var newColumn = __assign(__assign({}, column), { filterRowValue: action.filterRowValue });
            var newColumns = getCopyOfArrayAndInsertOrReplaceItem(newColumn, 'key', columns);
            return __assign(__assign({}, props), { columns: newColumns });
        }
        case ActionType.UpdateFilterRowOperator: {
            var column = columns.find(function (c) { return c.key === action.columnKey; });
            var newColumn = __assign(__assign({}, column), { filterRowOperator: action.filterRowOperator });
            var newColumns = getCopyOfArrayAndInsertOrReplaceItem(newColumn, 'key', columns);
            return __assign(__assign({}, props), { columns: newColumns });
        }
        case ActionType.UpdateEditorValue: {
            var newEditableCells = __spreadArrays(editableCells);
            var editableCellIndex = newEditableCells.findIndex(function (c) { return c.columnKey === action.columnKey && c.rowKeyValue === action.rowKeyValue; });
            var editableCell = __assign(__assign({}, newEditableCells[editableCellIndex]), { editorValue: action.value });
            newEditableCells[editableCellIndex] = editableCell;
            return __assign(__assign({}, props), { editableCells: newEditableCells });
        }
        case ActionType.UpdateCellValue: {
            var row = data.find(function (d) { return getValueByField(d, rowKeyField) === action.rowKeyValue; });
            var column = columns.find(function (c) { return c.key === action.columnKey; });
            var updatedRowData = replaceValue(row, column, action.value);
            var newData = getCopyOfArrayAndInsertOrReplaceItem(updatedRowData, rowKeyField, data);
            return __assign(__assign({}, props), { data: newData });
        }
        case ActionType.DeleteRow: {
            var newData = data.filter(function (d) { return getValueByField(d, rowKeyField) !== action.rowKeyValue; });
            return __assign(__assign({}, props), { data: newData });
        }
        case ActionType.SelectAllRows: {
            var newSelectedRows = data.map(function (d) { return getValueByField(d, rowKeyField); });
            return __assign(__assign({}, props), { selectedRows: newSelectedRows });
        }
        case ActionType.Search: {
            return __assign(__assign({}, props), { searchText: action.searchText });
        }
        case ActionType.SelectSingleRow: {
            var newSelectedRows = [action.rowKeyValue];
            return __assign(__assign({}, props), { selectedRows: newSelectedRows });
        }
        case ActionType.DeselectAllRows:
            return __assign(__assign({}, props), { selectedRows: [] });
        case ActionType.SelectRow:
            return __assign(__assign({}, props), { selectedRows: __spreadArrays(selectedRows, [action.rowKeyValue]) });
        case ActionType.SelectRowsRange: {
            var rowKeyValueTo_1 = action.rowKeyValueTo;
            if (rowKeyValueTo_1) {
                var shownData = kaPropsUtils.getData(props);
                var rowKeyValueToIndex = shownData.findIndex(function (d) { return getValueByField(d, rowKeyField) === rowKeyValueTo_1; });
                var rowKeyValueFromIndex = shownData.findIndex(function (d) { return getValueByField(d, rowKeyField) === action.rowKeyValueFrom; });
                if (rowKeyValueToIndex != null && rowKeyValueFromIndex != null) {
                    var _e = rowKeyValueToIndex > rowKeyValueFromIndex ? [rowKeyValueFromIndex, rowKeyValueToIndex] : [rowKeyValueToIndex, rowKeyValueFromIndex], start = _e[0], end = _e[1];
                    var rowsToSelect = [];
                    for (var i = start; i <= end; i++) {
                        var value = getValueByField(shownData[i], rowKeyField);
                        if (!selectedRows.includes(value)) {
                            rowsToSelect.push(value);
                        }
                    }
                    return __assign(__assign({}, props), { selectedRows: __spreadArrays(selectedRows, rowsToSelect) });
                }
            }
            return __assign(__assign({}, props), { selectedRows: __spreadArrays(selectedRows, [action.rowKeyValueFrom]) });
        }
        case ActionType.DeselectRow: {
            var newSelectedRows = __spreadArrays(selectedRows).filter(function (s) { return s !== action.rowKeyValue; });
            return __assign(__assign({}, props), { selectedRows: newSelectedRows });
        }
        case ActionType.UpdateSortDirection:
            var sortedColumns = getSortedColumns(columns, action.columnKey);
            return __assign(__assign({}, props), { columns: sortedColumns });
        case ActionType.UpdateVirtualScrolling:
            return __assign(__assign({}, props), { virtualScrolling: action.virtualScrolling });
        case ActionType.UpdateData:
            return __assign(__assign({}, props), { data: action.data });
        case ActionType.ScrollTable:
            if (virtualScrolling) {
                var scrollTop = action.scrollTop;
                return __assign(__assign({}, props), { virtualScrolling: __assign(__assign({}, virtualScrolling), { scrollTop: scrollTop }) });
            }
            break;
        case ActionType.UpdateGroupsExpanded: {
            var currentGroupsExpanded = groupsExpanded;
            if (!currentGroupsExpanded) {
                var preparedOptions = prepareTableOptions(props);
                currentGroupsExpanded = getExpandedGroups(preparedOptions.groupedData);
            }
            var newGroupsExpanded = updateExpandedGroups(currentGroupsExpanded, action.groupKey);
            return __assign(__assign({}, props), { groupsExpanded: newGroupsExpanded });
        }
        case ActionType.ShowNewRow:
        case ActionType.OpenRowEditors: {
            var rowKeyValue = action.type === ActionType.ShowNewRow ? newRowId : action.rowKeyValue;
            var newEditableCells = addColumnsToRowEditableCells(editableCells, columns, rowKeyValue);
            return __assign(__assign({}, props), { editableCells: newEditableCells });
        }
        case ActionType.HideNewRow:
        case ActionType.CloseRowEditors: {
            var rowKeyValue_1 = action.type === ActionType.HideNewRow ? newRowId : action.rowKeyValue;
            var newEditableCells = editableCells.filter(function (e) { return e.rowKeyValue !== rowKeyValue_1; });
            return __assign(__assign({}, props), { editableCells: newEditableCells });
        }
        case ActionType.SaveRowEditors:
        case ActionType.SaveNewRow: {
            var isNewRow_1 = action.type === ActionType.SaveNewRow;
            var rowEditorKeyValue_1 = isNewRow_1 ? newRowId : action.rowKeyValue;
            var updatedRowData_1 = data.find(function (d) { return getValueByField(d, rowKeyField) === rowEditorKeyValue_1; });
            var rowEditableCells = editableCells.filter(function (editableCell) { return editableCell.rowKeyValue === rowEditorKeyValue_1
                && (isNewRow_1 || editableCell.hasOwnProperty('editorValue')); });
            if (action.validate) {
                var validationPassed_1 = true;
                rowEditableCells.forEach(function (cell) {
                    var column = columns.find(function (c) { return c.key === cell.columnKey; });
                    cell.validationMessage = validation && validation({
                        column: column,
                        value: cell.editorValue,
                        rowData: updatedRowData_1
                    });
                    validationPassed_1 = validationPassed_1 && !cell.validationMessage;
                });
                if (!validationPassed_1) {
                    return __assign(__assign({}, props), { editableCells: __spreadArrays(editableCells) });
                }
            }
            var newEditableCells = editableCells.filter(function (e) { return e.rowKeyValue !== rowEditorKeyValue_1; });
            rowEditableCells.forEach(function (cell) {
                var column = columns.find(function (c) { return c.key === cell.columnKey; });
                updatedRowData_1 = replaceValue(updatedRowData_1, column, cell.editorValue);
            });
            var newData = void 0;
            if (isNewRow_1) {
                updatedRowData_1[rowKeyField] = action.rowKeyValue;
                newData = __spreadArrays([updatedRowData_1], data);
            }
            else {
                newData = getCopyOfArrayAndInsertOrReplaceItem(updatedRowData_1, rowKeyField, data);
            }
            return __assign(__assign({}, props), { data: newData, editableCells: newEditableCells });
        }
        case ActionType.UpdateRow: {
            var newData = getCopyOfArrayAndInsertOrReplaceItem(action.rowData, rowKeyField, data);
            return __assign(__assign({}, props), { data: newData });
        }
    }
    return props;
};
export { kaReducer, };